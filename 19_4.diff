# HG changeset patch
# User Cuong Thai <thailycuong1202@gmail.com>
# Date 1396259848 -25200
#      Mon Mar 31 16:57:28 2014 +0700
# Branch hide_address_bar_and_rotation
# Node ID 8912580d52d5dfdd7d752663c1a923a43d5900d1
# Parent  6fa163ff81a310fa4f30d11aa7a5ec8e4ff3e1bf
Workable build

diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/AndroidManifest.xml.in
--- a/mobile/android/base/AndroidManifest.xml.in	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/AndroidManifest.xml.in	Mon Mar 31 16:57:28 2014 +0700
@@ -83,16 +83,26 @@
 		 android:debuggable="true">
 #endif
 
+
+
         <!-- If the windowSoftInputMode adjust* flag changes below, the
              setSoftInputMode call in BrowserSearch#onStop must also be updated. -->
         <activity android:name=".App"
                   android:label="@string/moz_app_displayname"
                   android:taskAffinity="@ANDROID_PACKAGE_NAME@.BROWSER"
                   android:alwaysRetainTaskState="true"
-                  android:configChanges="keyboard|keyboardHidden|mcc|mnc|orientation|screenSize"
+                  android:configChanges="keyboard|keyboardHidden|mcc|mnc|screenSize"
                   android:windowSoftInputMode="stateUnspecified|adjustResize"
+                  android:screenOrientation="landscape"
                   android:launchMode="singleTask"
                   android:theme="@style/Gecko.App">
+            <!-- Allow KidMode to start FlashKid to play flash -->
+            <intent-filter>
+                <action android:name="com.zoodles.action.VIEW_FLASH"/>
+                <category android:name="android.intent.category.DEFAULT"/>
+                <data android:scheme="http" />
+                <data android:scheme="https" />
+            </intent-filter>
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
                 <category android:name="android.intent.category.LAUNCHER" />
@@ -181,6 +191,7 @@
 
 #ifdef MOZ_ANDROID_SYNTHAPKS
         <activity android:name="org.mozilla.gecko.webapp.Dispatcher"
+                          android:screenOrientation="landscape"
             android:noHistory="true" >
             <intent-filter>
                 <!-- catch links from synthetic apks -->
@@ -207,9 +218,10 @@
 
         <activity android:name=".Webapp"
                   android:label="@string/webapp_generic_name"
-                  android:configChanges="keyboard|keyboardHidden|mcc|mnc|orientation|screenSize"
+                  android:configChanges="keyboard|keyboardHidden|mcc|mnc|screenSize"
                   android:windowSoftInputMode="stateUnspecified|adjustResize"
                   android:launchMode="singleTask"
+                  android:screenOrientation="landscape"
                   android:taskAffinity="org.mozilla.gecko.WEBAPP"
                   android:process=":@ANDROID_PACKAGE_NAME@.Webapp"
                   android:excludeFromRecents="true"
@@ -257,7 +269,10 @@
 
         <activity android:name="org.mozilla.gecko.Restarter"
                   android:process="@ANDROID_PACKAGE_NAME@Restarter"
+                  android:screenOrientation="landscape"
                   android:noHistory="true"
+
+
                   android:theme="@style/Gecko">
           <intent-filter>
             <action android:name="org.mozilla.gecko.restart"/>
@@ -275,6 +290,7 @@
             android:label="@string/crash_reporter_title"
             android:icon="@drawable/crash_reporter"
             android:theme="@style/Gecko"
+            android:screenOrientation="landscape"
             android:exported="false"
             android:excludeFromRecents="true">
           <intent-filter>
@@ -284,7 +300,8 @@
 #endif
 
         <activity android:name="org.mozilla.gecko.VideoPlayer"
-                  android:configChanges="keyboard|keyboardHidden|mcc|mnc|orientation"
+                  android:configChanges="keyboard|keyboardHidden|mcc|mnc"
+                  android:screenOrientation="landscape"
                   android:theme="@android:style/Theme.NoTitleBar">
             <intent-filter>
                 <action android:name="org.mozilla.gecko.PLAY_VIDEO" />
@@ -295,11 +312,13 @@
                   android:theme="@style/Gecko.Preferences"
                   android:label="@string/settings_title"
                   android:configChanges="orientation|screenSize"
+                  android:screenOrientation="landscape"
                   android:excludeFromRecents="true"/>
 
         <activity android:name="org.mozilla.gecko.home.HomePanelPicker"
                   android:theme="@style/Gecko.TitleDialog"
                   android:label="@string/home_add_panel_title"
+                  android:screenOrientation="landscape"
                   android:excludeFromRecents="true" />
 
         <provider android:name="org.mozilla.gecko.db.BrowserProvider"
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/AndroidManifest.xml.in~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/AndroidManifest.xml.in~	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,386 @@
+#filter substitution
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="@ANDROID_PACKAGE_NAME@"
+      android:installLocation="auto"
+      android:versionCode="@ANDROID_VERSION_CODE@"
+      android:versionName="@MOZ_APP_VERSION@"
+#ifdef MOZ_ANDROID_SHARED_ID
+      android:sharedUserId="@MOZ_ANDROID_SHARED_ID@"
+#endif
+      >
+    <uses-sdk android:minSdkVersion="8"
+              android:targetSdkVersion="16"/>
+
+#include ../services/manifests/AnnouncementsAndroidManifest_permissions.xml.in
+#include ../services/manifests/FxAccountAndroidManifest_permissions.xml.in
+#include ../services/manifests/HealthReportAndroidManifest_permissions.xml.in
+#include ../services/manifests/SyncAndroidManifest_permissions.xml.in
+
+#ifndef RELEASE_BUILD
+    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
+    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
+#endif
+    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+    <uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT"/>
+    <uses-permission android:name="com.android.launcher.permission.UNINSTALL_SHORTCUT"/>
+    <uses-permission android:name="com.android.browser.permission.READ_HISTORY_BOOKMARKS"/>
+
+    <uses-permission android:name="android.permission.WAKE_LOCK"/>
+    <uses-permission android:name="android.permission.VIBRATE"/>
+    <uses-permission android:name="@ANDROID_PACKAGE_NAME@.permissions.PASSWORD_PROVIDER"/>
+    <uses-permission android:name="@ANDROID_PACKAGE_NAME@.permissions.BROWSER_PROVIDER"/>
+    <uses-permission android:name="@ANDROID_PACKAGE_NAME@.permissions.FORMHISTORY_PROVIDER"/>
+
+#ifdef MOZ_WEBSMS_BACKEND
+    <!-- WebSMS -->
+    <uses-permission android:name="android.permission.SEND_SMS"/>
+    <uses-permission android:name="android.permission.RECEIVE_SMS"/>
+    <uses-permission android:name="android.permission.WRITE_SMS"/>
+    <uses-permission android:name="android.permission.READ_SMS"/>
+#endif
+
+    <uses-feature android:name="android.hardware.location" android:required="false"/>
+    <uses-feature android:name="android.hardware.location.gps" android:required="false"/>
+    <uses-feature android:name="android.hardware.touchscreen"/>
+
+#ifdef NIGHTLY_BUILD
+    <!-- Contacts API -->
+    <uses-permission android:name="android.permission.READ_CONTACTS"/>
+    <uses-permission android:name="android.permission.WRITE_CONTACTS"/>
+    <uses-permission android:name="android.permission.GET_ACCOUNTS"/>
+#endif
+
+#ifdef MOZ_ANDROID_BEAM
+    <!-- Android Beam support -->
+    <uses-permission android:name="android.permission.NFC"/>
+    <uses-feature android:name="android.hardware.nfc" android:required="false"/>
+#endif
+
+#ifdef MOZ_WEBRTC
+    <uses-permission android:name="android.permission.RECORD_AUDIO"/>
+    <uses-feature android:name="android.hardware.audio.low_latency" android:required="false"/>
+    <uses-feature android:name="android.hardware.camera.any" android:required="false"/>
+    <uses-feature android:name="android.hardware.microphone" android:required="false"/>
+#endif
+    <uses-permission android:name="android.permission.CAMERA" />
+    <uses-feature android:name="android.hardware.camera" android:required="false"/>
+    <uses-feature android:name="android.hardware.camera.autofocus" android:required="false"/>
+
+    <!-- App requires OpenGL ES 2.0 -->
+    <uses-feature android:glEsVersion="0x00020000" android:required="true" />
+
+    <application android:label="@string/moz_app_displayname"
+		 android:icon="@drawable/icon"
+                 android:name="org.mozilla.gecko.GeckoApplication"
+		 android:hardwareAccelerated="true"
+#if MOZILLA_OFFICIAL
+		 android:debuggable="false">
+#else
+		 android:debuggable="true">
+#endif
+
+
+
+        <!-- If the windowSoftInputMode adjust* flag changes below, the
+             setSoftInputMode call in BrowserSearch#onStop must also be updated. -->
+        <activity android:name=".App"
+                  android:label="@string/moz_app_displayname"
+                  android:taskAffinity="@ANDROID_PACKAGE_NAME@.BROWSER"
+                  android:alwaysRetainTaskState="true"
+                  android:screenOrientation="landscape"
+                  android:configChanges="keyboard|keyboardHidden|mcc|mnc|screenSize"
+                  android:windowSoftInputMode="stateUnspecified|adjustResize"
+                  android:launchMode="singleTask"
+                  android:theme="@style/Gecko.App">
+            <!-- Allow KidMode to start FlashKid to play flash -->
+            <intent-filter>
+                <action android:name="com.zoodles.action.VIEW_FLASH"/>
+                <category android:name="android.intent.category.DEFAULT"/>
+                <data android:scheme="http" />
+                <data android:scheme="https" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="org.mozilla.gecko.ACTION_ALERT_CALLBACK" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="org.mozilla.gecko.UPDATE"/>
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+
+            <!-- Default browser intents -->
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.BROWSABLE" />
+                <data android:scheme="http" />
+                <data android:scheme="https" />
+                <data android:scheme="about" />
+                <data android:scheme="javascript" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.BROWSABLE" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:scheme="file" />
+                <data android:scheme="http" />
+                <data android:scheme="https" />
+                <data android:mimeType="text/html"/>
+                <data android:mimeType="text/plain"/>
+                <data android:mimeType="application/xhtml+xml"/>
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="android.intent.action.WEB_SEARCH" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.BROWSABLE" />
+                <data android:scheme="" />
+                <data android:scheme="http" />
+                <data android:scheme="https" />
+            </intent-filter>
+
+            <intent-filter>
+                <action android:name="android.intent.action.SEARCH" />
+            </intent-filter>
+
+            <!-- For XPI installs from websites and the download manager. -->
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:scheme="file" />
+                <data android:scheme="http" />
+                <data android:scheme="https" />
+                <data android:mimeType="application/x-xpinstall" />
+            </intent-filter>
+
+            <!-- For XPI installs from file: URLs. -->
+            <intent-filter>
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:host="" />
+                <data android:scheme="file" />
+                <data android:pathPattern=".*\\.xpi" />
+            </intent-filter>
+
+#ifdef MOZ_ANDROID_BEAM
+            <intent-filter>
+                <action android:name="android.nfc.action.NDEF_DISCOVERED"/>
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:scheme="http" />
+                <data android:scheme="https" />
+            </intent-filter>
+#endif
+
+            <meta-data android:name="android.app.searchable"
+                       android:resource="@xml/searchable" />
+
+            <!-- For debugging -->
+            <intent-filter>
+                <action android:name="org.mozilla.gecko.DEBUG" />
+                <category android:name="android.intent.category.DEFAULT" />
+            </intent-filter>
+        </activity>
+
+#ifdef MOZ_ANDROID_SYNTHAPKS
+        <activity android:name="org.mozilla.gecko.webapp.Dispatcher"
+            android:noHistory="true" >
+            <intent-filter>
+                <!-- catch links from synthetic apks -->
+                <action android:name="android.intent.action.VIEW" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <data android:mimeType="application/webapp" />
+            </intent-filter>
+        </activity>
+
+        <receiver android:name="org.mozilla.gecko.webapp.UninstallListener" >
+          <intent-filter>
+             <action android:name="android.intent.action.PACKAGE_REMOVED" />
+             <data android:scheme="package" />
+          </intent-filter>
+        </receiver>
+
+        <receiver android:name="org.mozilla.gecko.webapp.TaskKiller">
+          <intent-filter>
+             <action android:name="org.mozilla.webapp.TASK_REMOVED" />
+             <category android:name="android.intent.category.DEFAULT" />
+          </intent-filter>
+        </receiver>
+#endif
+
+        <activity android:name=".Webapp"
+                  android:label="@string/webapp_generic_name"
+                  android:configChanges="keyboard|keyboardHidden|mcc|mnc|orientation|screenSize"
+                  android:windowSoftInputMode="stateUnspecified|adjustResize"
+                  android:launchMode="singleTask"
+                  android:taskAffinity="org.mozilla.gecko.WEBAPP"
+                  android:process=":@ANDROID_PACKAGE_NAME@.Webapp"
+                  android:excludeFromRecents="true"
+                  android:theme="@style/Gecko.App">
+            <intent-filter>
+                <action android:name="org.mozilla.gecko.WEBAPP" />
+            </intent-filter>
+            <intent-filter>
+                <action android:name="org.mozilla.gecko.ACTION_ALERT_CALLBACK" />
+            </intent-filter>
+        </activity>
+
+        <!-- Declare a predefined number of Webapp<num> activities. These are
+             used so that each web app can launch in its own process. Keep
+             this number in sync with the total number of web apps handled in
+             WebappAllocator. -->
+
+#define FRAGMENT WebappManifestFragment.xml.frag.in
+#include WebappFragmentRepeater.inc
+
+        <!-- Masquerade as the Resolver so that we can be opened from the Marketplace. -->
+        <activity-alias
+            android:name="com.android.internal.app.ResolverActivity"
+            android:targetActivity=".App"
+            android:exported="true" />
+
+        <receiver android:name="org.mozilla.gecko.GeckoUpdateReceiver">
+            <intent-filter>
+                <action android:name="@ANDROID_PACKAGE_NAME@.CHECK_UPDATE_RESULT" />
+            </intent-filter>
+        </receiver>
+
+        <receiver android:name="org.mozilla.gecko.GeckoMessageReceiver"
+                  android:permission="@ANDROID_PACKAGE_NAME@.permissions.PASSWORD_PROVIDER">
+            <intent-filter>
+                  <action android:name="org.mozilla.gecko.INIT_PW"></action>
+            </intent-filter>
+        </receiver>
+
+        <receiver android:name="org.mozilla.gecko.ReferrerReceiver" android:exported="true">
+            <intent-filter>
+                <action android:name="com.android.vending.INSTALL_REFERRER" />
+            </intent-filter>
+        </receiver>
+
+        <activity android:name="org.mozilla.gecko.Restarter"
+                  android:process="@ANDROID_PACKAGE_NAME@Restarter"
+                  android:noHistory="true"
+                  android:theme="@style/Gecko">
+          <intent-filter>
+            <action android:name="org.mozilla.gecko.restart"/>
+            <action android:name="org.mozilla.gecko.restart_update"/>
+          </intent-filter>
+        </activity>
+
+#include ../services/manifests/AnnouncementsAndroidManifest_activities.xml.in
+#include ../services/manifests/FxAccountAndroidManifest_activities.xml.in
+#include ../services/manifests/SyncAndroidManifest_activities.xml.in
+#include ../services/manifests/HealthReportAndroidManifest_activities.xml.in
+
+#if MOZ_CRASHREPORTER
+  <activity android:name="org.mozilla.gecko.CrashReporter"
+            android:label="@string/crash_reporter_title"
+            android:icon="@drawable/crash_reporter"
+            android:theme="@style/Gecko"
+            android:exported="false"
+            android:excludeFromRecents="true">
+          <intent-filter>
+            <action android:name="org.mozilla.gecko.reportCrash" />
+          </intent-filter>
+	</activity>
+#endif
+
+        <activity android:name="org.mozilla.gecko.VideoPlayer"
+                  android:configChanges="keyboard|keyboardHidden|mcc|mnc|orientation"
+                  android:theme="@android:style/Theme.NoTitleBar">
+            <intent-filter>
+                <action android:name="org.mozilla.gecko.PLAY_VIDEO" />
+            </intent-filter>
+        </activity>
+
+        <activity android:name="org.mozilla.gecko.preferences.GeckoPreferences"
+                  android:theme="@style/Gecko.Preferences"
+                  android:label="@string/settings_title"
+                  android:configChanges="orientation|screenSize"
+                  android:excludeFromRecents="true"/>
+
+        <activity android:name="org.mozilla.gecko.home.HomePanelPicker"
+                  android:theme="@style/Gecko.TitleDialog"
+                  android:label="@string/home_add_panel_title"
+                  android:excludeFromRecents="true" />
+
+        <provider android:name="org.mozilla.gecko.db.BrowserProvider"
+                  android:authorities="@ANDROID_PACKAGE_NAME@.db.browser"
+                  android:permission="@ANDROID_PACKAGE_NAME@.permissions.BROWSER_PROVIDER">
+
+            <path-permission android:pathPrefix="/search_suggest_query"
+                             android:readPermission="android.permission.GLOBAL_SEARCH" />
+
+        </provider>
+
+        <!--
+          Ensure that passwords provider runs in its own process. (Bug 718760.)
+          Process name is per-application to avoid loading CPs from multiple
+          Fennec versions into the same process. (Bug 749727.)
+          Process name is a mangled version to avoid a Talos bug. (Bug 750548.)
+          -->
+        <provider android:name="org.mozilla.gecko.db.PasswordsProvider"
+                  android:label="@string/sync_configure_engines_title_passwords"
+                  android:authorities="@ANDROID_PACKAGE_NAME@.db.passwords"
+                  android:permission="@ANDROID_PACKAGE_NAME@.permissions.PASSWORD_PROVIDER"
+                  android:process="@MANGLED_ANDROID_PACKAGE_NAME@.PasswordsProvider"/>
+
+        <provider android:name="org.mozilla.gecko.db.FormHistoryProvider"
+                  android:label="@string/sync_configure_engines_title_history"
+                  android:authorities="@ANDROID_PACKAGE_NAME@.db.formhistory"
+                  android:permission="@ANDROID_PACKAGE_NAME@.permissions.FORMHISTORY_PROVIDER"
+                  android:protectionLevel="signature"/>
+
+        <provider android:name="org.mozilla.gecko.GeckoProfilesProvider"
+                  android:authorities="@ANDROID_PACKAGE_NAME@.profiles"/>
+
+        <provider android:name="org.mozilla.gecko.db.TabsProvider"
+                  android:label="@string/sync_configure_engines_title_tabs"
+                  android:authorities="@ANDROID_PACKAGE_NAME@.db.tabs"
+                  android:permission="@ANDROID_PACKAGE_NAME@.permissions.BROWSER_PROVIDER"/>
+
+        <provider android:name="org.mozilla.gecko.db.HomeProvider"
+                  android:authorities="@ANDROID_PACKAGE_NAME@.db.home"
+                  android:permission="@ANDROID_PACKAGE_NAME@.permissions.BROWSER_PROVIDER"/>
+
+        <provider android:name="org.mozilla.gecko.db.ReadingListProvider"
+                  android:authorities="@ANDROID_PACKAGE_NAME@.db.readinglist"
+                  android:permission="@ANDROID_PACKAGE_NAME@.permissions.BROWSER_PROVIDER"/>
+
+        <service
+            android:exported="false"
+            android:name="org.mozilla.gecko.updater.UpdateService"
+            android:process="@MANGLED_ANDROID_PACKAGE_NAME@.UpdateService">
+        </service>
+
+        <service
+            android:exported="false"
+            android:name="org.mozilla.gecko.NotificationService">
+        </service>
+
+
+#include ../services/manifests/AnnouncementsAndroidManifest_services.xml.in
+#include ../services/manifests/FxAccountAndroidManifest_services.xml.in
+#include ../services/manifests/HealthReportAndroidManifest_services.xml.in
+#include ../services/manifests/SyncAndroidManifest_services.xml.in
+
+    </application>
+
+    <permission android:name="@ANDROID_PACKAGE_NAME@.permissions.BROWSER_PROVIDER"
+                android:protectionLevel="signature"/>
+
+    <permission android:name="@ANDROID_PACKAGE_NAME@.permissions.PASSWORD_PROVIDER"
+                android:protectionLevel="signature"/>
+
+    <permission android:name="@ANDROID_PACKAGE_NAME@.permissions.FORMHISTORY_PROVIDER"
+                android:protectionLevel="signature"/>
+
+</manifest>
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/BrowserApp.java
--- a/mobile/android/base/BrowserApp.java	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/BrowserApp.java	Mon Mar 31 16:57:28 2014 +0700
@@ -48,6 +48,7 @@
 import org.mozilla.gecko.prompts.Prompt;
 import org.mozilla.gecko.prompts.PromptListItem;
 import org.mozilla.gecko.sync.setup.SyncAccounts;
+import org.mozilla.gecko.sync.setup.activities.ActivityUtils;
 import org.mozilla.gecko.toolbar.AutocompleteHandler;
 import org.mozilla.gecko.toolbar.BrowserToolbar;
 import org.mozilla.gecko.toolbar.ToolbarProgressView;
@@ -433,7 +434,9 @@
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
-        mAboutHomeStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_ABOUTHOME");
+	    Log.d("Cuong","Activity BrowserApp");
+
+	    mAboutHomeStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_ABOUTHOME");
 
         final Intent intent = getIntent();
 
@@ -456,7 +459,9 @@
         mBrowserToolbar = (BrowserToolbar) findViewById(R.id.browser_toolbar);
         mProgressView = (ToolbarProgressView) findViewById(R.id.progress);
         mBrowserToolbar.setProgressBar(mProgressView);
-        if (Intent.ACTION_VIEW.equals(intent.getAction())) {
+//	    mBrowserToolbar.setVisibility(View.GONE);
+//	    mDynamicToolbar.setVisible(false,VisibilityTransition.IMMEDIATE);
+	    if (Intent.ACTION_VIEW.equals(intent.getAction())) {
             // Show the target URL immediately in the toolbar.
             mBrowserToolbar.setTitle(intent.getDataString());
         }
@@ -608,21 +613,30 @@
 
     @Override
     public void onBackPressed() {
-        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
-            super.onBackPressed();
-            return;
-        }
-
-        if (mBrowserToolbar.onBackPressed()) {
-            return;
-        }
-
-        if (mActionMode != null) {
-            endActionModeCompat();
-            return;
-        }
-
-        super.onBackPressed();
+	    Log.d("Cuong","Number Of Tabs "+Tabs.getInstance().getDisplayCount() );
+	    Iterable<Tab> tabsInOrder = Tabs.getInstance().getTabsInOrder();
+	    if(tabsInOrder!=null){
+		    for(Tab tab:tabsInOrder){
+			    Tabs.getInstance().closeTab(tab);
+		    }
+	    }
+	    GeckoAppShell.systemExit();
+
+//        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
+//            super.onBackPressed();
+//            return;
+//        }
+//
+//        if (mBrowserToolbar.onBackPressed()) {
+//            return;
+//        }
+//
+//        if (mActionMode != null) {
+//            endActionModeCompat();
+//            return;
+//        }
+
+//        super.onBackPressed();
     }
 
     @Override
@@ -2053,37 +2067,38 @@
             menuItem.setVisible(options.optBoolean("visible", menuItem.isVisible()));
         }
     }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        // Sets mMenu = menu.
-        super.onCreateOptionsMenu(menu);
-
-        // Inform the menu about the action-items bar. 
-        if (menu instanceof GeckoMenu &&
-            HardwareUtils.isTablet()) {
-            ((GeckoMenu) menu).setActionItemBarPresenter(mBrowserToolbar);
-        }
-
-        MenuInflater inflater = getMenuInflater();
-        inflater.inflate(R.menu.browser_app_menu, mMenu);
-
-        // Add add-on menu items, if any exist.
-        if (mAddonMenuItemsCache != null && !mAddonMenuItemsCache.isEmpty()) {
-            for (MenuItemInfo item : mAddonMenuItemsCache) {
-                addAddonMenuItemToMenu(mMenu, item);
-            }
-        }
-
-        // Action providers are available only ICS+.
-        if (Build.VERSION.SDK_INT >= 14) {
-            GeckoMenuItem share = (GeckoMenuItem) mMenu.findItem(R.id.share);
-            GeckoActionProvider provider = new GeckoActionProvider(this);
-            share.setActionProvider(provider);
-        }
-
-        return true;
-    }
+//
+//    @Override
+//    public boolean onCreateOptionsMenu(Menu menu) {
+	    //we dont use Menu in FlashKid
+//        // Sets mMenu = menu.
+//        super.onCreateOptionsMenu(menu);
+//
+//        // Inform the menu about the action-items bar.
+//        if (menu instanceof GeckoMenu &&
+//            HardwareUtils.isTablet()) {
+//            ((GeckoMenu) menu).setActionItemBarPresenter(mBrowserToolbar);
+//        }
+//
+//        MenuInflater inflater = getMenuInflater();
+//        inflater.inflate(R.menu.browser_app_menu, mMenu);
+//
+//        // Add add-on menu items, if any exist.
+//        if (mAddonMenuItemsCache != null && !mAddonMenuItemsCache.isEmpty()) {
+//            for (MenuItemInfo item : mAddonMenuItemsCache) {
+//                addAddonMenuItemToMenu(mMenu, item);
+//            }
+//        }
+//
+//        // Action providers are available only ICS+.
+//        if (Build.VERSION.SDK_INT >= 14) {
+//            GeckoMenuItem share = (GeckoMenuItem) mMenu.findItem(R.id.share);
+//            GeckoActionProvider provider = new GeckoActionProvider(this);
+//            share.setActionProvider(provider);
+//        }
+
+//        return false;
+//    }
 
     @Override
     public void openOptionsMenu() {
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/BrowserApp.java.orig
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/BrowserApp.java.orig	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,2702 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.gecko;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.net.URLEncoder;
+import java.util.EnumSet;
+import java.util.Vector;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.mozilla.gecko.DynamicToolbar.PinReason;
+import org.mozilla.gecko.DynamicToolbar.VisibilityTransition;
+import org.mozilla.gecko.GeckoProfileDirectories.NoMozillaDirectoryException;
+import org.mozilla.gecko.animation.PropertyAnimator;
+import org.mozilla.gecko.animation.ViewHelper;
+import org.mozilla.gecko.db.BrowserContract.Combined;
+import org.mozilla.gecko.db.BrowserContract.ReadingListItems;
+import org.mozilla.gecko.db.BrowserDB;
+import org.mozilla.gecko.favicons.Favicons;
+import org.mozilla.gecko.favicons.LoadFaviconTask;
+import org.mozilla.gecko.favicons.OnFaviconLoadedListener;
+import org.mozilla.gecko.favicons.decoders.IconDirectoryEntry;
+import org.mozilla.gecko.fxa.FirefoxAccounts;
+import org.mozilla.gecko.fxa.activities.FxAccountGetStartedActivity;
+import org.mozilla.gecko.gfx.BitmapUtils;
+import org.mozilla.gecko.gfx.GeckoLayerClient;
+import org.mozilla.gecko.gfx.ImmutableViewportMetrics;
+import org.mozilla.gecko.gfx.LayerMarginsAnimator;
+import org.mozilla.gecko.health.BrowserHealthRecorder;
+import org.mozilla.gecko.health.BrowserHealthReporter;
+import org.mozilla.gecko.health.HealthRecorder;
+import org.mozilla.gecko.health.SessionInformation;
+import org.mozilla.gecko.home.BrowserSearch;
+import org.mozilla.gecko.home.HomeBanner;
+import org.mozilla.gecko.home.HomeConfigInvalidator;
+import org.mozilla.gecko.home.HomePager;
+import org.mozilla.gecko.home.HomePager.OnUrlOpenListener;
+import org.mozilla.gecko.home.SearchEngine;
+import org.mozilla.gecko.menu.GeckoMenu;
+import org.mozilla.gecko.preferences.GeckoPreferences;
+import org.mozilla.gecko.prompts.Prompt;
+import org.mozilla.gecko.sync.setup.SyncAccounts;
+import org.mozilla.gecko.toolbar.AutocompleteHandler;
+import org.mozilla.gecko.toolbar.BrowserToolbar;
+import org.mozilla.gecko.toolbar.ToolbarProgressView;
+import org.mozilla.gecko.util.Clipboard;
+import org.mozilla.gecko.util.GamepadUtils;
+import org.mozilla.gecko.util.HardwareUtils;
+import org.mozilla.gecko.util.MenuUtils;
+import org.mozilla.gecko.util.StringUtils;
+import org.mozilla.gecko.util.ThreadUtils;
+import org.mozilla.gecko.util.UiAsyncTask;
+import org.mozilla.gecko.widget.ButtonToast;
+import org.mozilla.gecko.widget.GeckoActionProvider;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.res.Configuration;
+import android.content.res.Resources;
+import android.database.Cursor;
+import android.graphics.Bitmap;
+import android.graphics.Rect;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.net.Uri;
+import android.nfc.NdefMessage;
+import android.nfc.NdefRecord;
+import android.nfc.NfcAdapter;
+import android.nfc.NfcEvent;
+import android.os.Build;
+import android.os.Bundle;
+import android.support.v4.app.FragmentManager;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.InputDevice;
+import android.view.KeyEvent;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.SubMenu;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.view.ViewTreeObserver;
+import android.view.Window;
+import android.view.animation.Interpolator;
+import android.widget.RelativeLayout;
+import android.widget.ListView;
+import android.widget.Toast;
+import android.widget.ViewFlipper;
+
+abstract public class BrowserApp extends GeckoApp
+                                 implements TabsPanel.TabsLayoutChangeListener,
+                                            PropertyAnimator.PropertyAnimationListener,
+                                            View.OnKeyListener,
+                                            GeckoLayerClient.OnMetricsChangedListener,
+                                            BrowserSearch.OnSearchListener,
+                                            BrowserSearch.OnEditSuggestionListener,
+                                            HomePager.OnNewTabsListener,
+                                            OnUrlOpenListener,
+                                            ActionModeCompat.Presenter {
+    private static final String LOGTAG = "GeckoBrowserApp";
+
+    private static final int TABS_ANIMATION_DURATION = 450;
+
+    private static final int READER_ADD_SUCCESS = 0;
+    private static final int READER_ADD_FAILED = 1;
+    private static final int READER_ADD_DUPLICATE = 2;
+
+    private static final String ADD_SHORTCUT_TOAST = "add_shortcut_toast";
+    public static final String GUEST_BROWSING_ARG = "--guest";
+
+    private static final String STATE_ABOUT_HOME_TOP_PADDING = "abouthome_top_padding";
+
+    private static final String BROWSER_SEARCH_TAG = "browser_search";
+    private BrowserSearch mBrowserSearch;
+    private View mBrowserSearchContainer;
+
+    public ViewFlipper mViewFlipper;
+    public ActionModeCompatView mActionBar;
+    private BrowserToolbar mBrowserToolbar;
+    private ToolbarProgressView mProgressView;
+    private HomePager mHomePager;
+    private TabsPanel mTabsPanel;
+    private ViewGroup mHomePagerContainer;
+    protected Telemetry.Timer mAboutHomeStartupTimer = null;
+    private ActionModeCompat mActionMode;
+    private boolean mShowActionModeEndAnimation = false;
+
+    private static final int GECKO_TOOLS_MENU = -1;
+    private static final int ADDON_MENU_OFFSET = 1000;
+    private static class MenuItemInfo {
+        public int id;
+        public String label;
+        public String icon;
+        public boolean checkable = false;
+        public boolean checked = false;
+        public boolean enabled = true;
+        public boolean visible = true;
+        public int parent;
+        public boolean added = false;    // So we can re-add after a locale change.
+    }
+
+    // The types of guest mdoe dialogs we show
+    private static enum GuestModeDialog {
+        ENTERING,
+        LEAVING
+    }
+
+    private Vector<MenuItemInfo> mAddonMenuItemsCache;
+    private PropertyAnimator mMainLayoutAnimator;
+
+    private static final Interpolator sTabsInterpolator = new Interpolator() {
+        @Override
+        public float getInterpolation(float t) {
+            t -= 1.0f;
+            return t * t * t * t * t + 1.0f;
+        }
+    };
+
+    private FindInPageBar mFindInPageBar;
+    private MediaCastingBar mMediaCastingBar;
+
+    // We'll ask for feedback after the user launches the app this many times.
+    private static final int FEEDBACK_LAUNCH_COUNT = 15;
+
+    // Stored value of the toolbar height, so we know when it's changed.
+    private int mToolbarHeight = 0;
+
+    // Stored value of whether the last metrics change allowed for toolbar
+    // scrolling.
+    private boolean mDynamicToolbarCanScroll = false;
+
+    private SharedPreferencesHelper mSharedPreferencesHelper;
+
+    private OrderedBroadcastHelper mOrderedBroadcastHelper;
+
+    private BrowserHealthReporter mBrowserHealthReporter;
+
+    // The tab to be selected on editing mode exit.
+    private Integer mTargetTabForEditingMode = null;
+
+    // The animator used to toggle HomePager visibility has a race where if the HomePager is shown
+    // (starting the animation), the HomePager is hidden, and the HomePager animation completes,
+    // both the web content and the HomePager will be hidden. This flag is used to prevent the
+    // race by determining if the web content should be hidden at the animation's end.
+    private boolean mHideWebContentOnAnimationEnd = false;
+
+    private DynamicToolbar mDynamicToolbar = new DynamicToolbar();
+
+    @Override
+    public void onTabChanged(Tab tab, Tabs.TabEvents msg, Object data) {
+        if (tab == null) {
+            // Only RESTORED is allowed a null tab: it's the only event that
+            // isn't tied to a specific tab.
+            if (msg != Tabs.TabEvents.RESTORED) {
+                throw new IllegalArgumentException("onTabChanged:" + msg + " must specify a tab.");
+            }
+            return;
+        }
+
+        Log.d(LOGTAG, "BrowserApp.onTabChanged: " + tab.getId() + ": " + msg);
+        switch(msg) {
+            case LOCATION_CHANGE:
+                if (Tabs.getInstance().isSelectedTab(tab)) {
+                    maybeCancelFaviconLoad(tab);
+                }
+                // fall through
+            case SELECTED:
+                if (Tabs.getInstance().isSelectedTab(tab)) {
+                    updateHomePagerForTab(tab);
+
+                    final TabsPanel.Panel panel = tab.isPrivate()
+                                                ? TabsPanel.Panel.PRIVATE_TABS
+                                                : TabsPanel.Panel.NORMAL_TABS;
+                    // Delay calling showTabs so that it does not modify the mTabsChangedListeners
+                    // array while we are still iterating through the array.
+                    ThreadUtils.postToUiThread(new Runnable() {
+                        @Override
+                        public void run() {
+                            if (areTabsShown() && mTabsPanel.getCurrentPanel() != panel)
+                                showTabs(panel);
+                        }
+                    });
+                }
+                break;
+            case START:
+                if (Tabs.getInstance().isSelectedTab(tab)) {
+                    invalidateOptionsMenu();
+
+                    if (mDynamicToolbar.isEnabled()) {
+                        mDynamicToolbar.setVisible(true, VisibilityTransition.ANIMATE);
+                    }
+                }
+                break;
+            case LOAD_ERROR:
+            case STOP:
+            case MENU_UPDATED:
+                if (Tabs.getInstance().isSelectedTab(tab)) {
+                    invalidateOptionsMenu();
+                }
+                break;
+            case PAGE_SHOW:
+                loadFavicon(tab);
+                break;
+            case LINK_FAVICON:
+                // If tab is not loading and the favicon is updated, we
+                // want to load the image straight away. If tab is still
+                // loading, we only load the favicon once the page's content
+                // is fully loaded.
+                if (tab.getState() != Tab.STATE_LOADING) {
+                    loadFavicon(tab);
+                }
+                break;
+        }
+        super.onTabChanged(tab, msg, data);
+    }
+
+    @Override
+    public boolean onKey(View v, int keyCode, KeyEvent event) {
+        // Global onKey handler. This is called if the focused UI doesn't
+        // handle the key event, and before Gecko swallows the events.
+        if (event.getAction() != KeyEvent.ACTION_DOWN) {
+            return false;
+        }
+
+        // Gamepad support only exists in API-level >= 9
+        if (Build.VERSION.SDK_INT >= 9 &&
+            (event.getSource() & InputDevice.SOURCE_GAMEPAD) == InputDevice.SOURCE_GAMEPAD) {
+            switch (keyCode) {
+                case KeyEvent.KEYCODE_BUTTON_Y:
+                    // Toggle/focus the address bar on gamepad-y button.
+                    if (mViewFlipper.getVisibility() == View.VISIBLE) {
+                        if (mDynamicToolbar.isEnabled() && !isHomePagerVisible()) {
+                            mDynamicToolbar.setVisible(false, VisibilityTransition.ANIMATE);
+                            if (mLayerView != null) {
+                                mLayerView.requestFocus();
+                            }
+                        } else {
+                            // Just focus the address bar when about:home is visible
+                            // or when the dynamic toolbar isn't enabled.
+                            mBrowserToolbar.requestFocusFromTouch();
+                        }
+                    } else {
+                        mDynamicToolbar.setVisible(true, VisibilityTransition.ANIMATE);
+                        mBrowserToolbar.requestFocusFromTouch();
+                    }
+                    return true;
+                case KeyEvent.KEYCODE_BUTTON_L1:
+                    // Go back on L1
+                    Tabs.getInstance().getSelectedTab().doBack();
+                    return true;
+                case KeyEvent.KEYCODE_BUTTON_R1:
+                    // Go forward on R1
+                    Tabs.getInstance().getSelectedTab().doForward();
+                    return true;
+            }
+        }
+
+        // Check if this was a shortcut. Meta keys exists only on 11+.
+        final Tab tab = Tabs.getInstance().getSelectedTab();
+        if (Build.VERSION.SDK_INT >= 11 && tab != null && event.isCtrlPressed()) {
+            switch (keyCode) {
+                case KeyEvent.KEYCODE_LEFT_BRACKET:
+                    tab.doBack();
+                    return true;
+
+                case KeyEvent.KEYCODE_RIGHT_BRACKET:
+                    tab.doForward();
+                    return true;
+
+                case KeyEvent.KEYCODE_R:
+                    tab.doReload();
+                    return true;
+
+                case KeyEvent.KEYCODE_PERIOD:
+                    tab.doStop();
+                    return true;
+
+                case KeyEvent.KEYCODE_T:
+                    addTab();
+                    return true;
+
+                case KeyEvent.KEYCODE_W:
+                    Tabs.getInstance().closeTab(tab);
+                    return true;
+
+                case KeyEvent.KEYCODE_F:
+                    mFindInPageBar.show();
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        if (!mBrowserToolbar.isEditing() && onKey(null, keyCode, event)) {
+            return true;
+        }
+
+        if (mBrowserToolbar.onKey(keyCode, event)) {
+            return true;
+        }
+
+        return super.onKeyDown(keyCode, event);
+    }
+
+    void handleReaderListCountRequest() {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                final int count = BrowserDB.getReadingListCount(getContentResolver());
+                GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Reader:ListCountReturn", Integer.toString(count)));
+            }
+        });
+    }
+
+    void handleReaderListStatusRequest(final String url) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                final int inReadingList = BrowserDB.isReadingListItem(getContentResolver(), url) ? 1 : 0;
+
+                final JSONObject json = new JSONObject();
+                try {
+                    json.put("url", url);
+                    json.put("inReadingList", inReadingList);
+                } catch (JSONException e) {
+                    Log.e(LOGTAG, "JSON error - failed to return inReadingList status", e);
+                    return;
+                }
+
+                GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Reader:ListStatusReturn", json.toString()));
+            }
+        });
+    }
+
+    private void handleReaderAdded(int result, final ContentValues values) {
+        if (result != READER_ADD_SUCCESS) {
+            if (result == READER_ADD_FAILED) {
+                showToast(R.string.reading_list_failed, Toast.LENGTH_SHORT);
+            } else if (result == READER_ADD_DUPLICATE) {
+                showToast(R.string.reading_list_duplicate, Toast.LENGTH_SHORT);
+            }
+
+            return;
+        }
+
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                BrowserDB.addReadingListItem(getContentResolver(), values);
+                showToast(R.string.reading_list_added, Toast.LENGTH_SHORT);
+
+                final int count = BrowserDB.getReadingListCount(getContentResolver());
+                GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Reader:ListCountUpdated", Integer.toString(count)));
+            }
+        });
+    }
+
+    private ContentValues messageToReadingListContentValues(JSONObject message) {
+        final ContentValues values = new ContentValues();
+        values.put(ReadingListItems.URL, message.optString("url"));
+        values.put(ReadingListItems.TITLE, message.optString("title"));
+        values.put(ReadingListItems.LENGTH, message.optInt("length"));
+        values.put(ReadingListItems.EXCERPT, message.optString("excerpt"));
+        return values;
+    }
+
+    void handleReaderRemoved(final String url) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                BrowserDB.removeReadingListItemWithURL(getContentResolver(), url);
+                showToast(R.string.reading_list_removed, Toast.LENGTH_SHORT);
+
+                final int count = BrowserDB.getReadingListCount(getContentResolver());
+                GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Reader:ListCountUpdated", Integer.toString(count)));
+            }
+        });
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        mAboutHomeStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_ABOUTHOME");
+
+        final Intent intent = getIntent();
+
+        String args = intent.getStringExtra("args");
+        if (args != null && args.contains(GUEST_BROWSING_ARG)) {
+            mProfile = GeckoProfile.createGuestProfile(this);
+        } else {
+            GeckoProfile.maybeCleanupGuestProfile(this);
+        }
+
+        // This has to be prepared prior to calling GeckoApp.onCreate, because
+        // widget code and BrowserToolbar need it, and they're created by the
+        // layout, which GeckoApp takes care of.
+        ((GeckoApplication) getApplication()).prepareLightweightTheme();
+        super.onCreate(savedInstanceState);
+
+        mViewFlipper = (ViewFlipper) findViewById(R.id.browser_actionbar);
+        mActionBar = (ActionModeCompatView) findViewById(R.id.actionbar);
+
+        mBrowserToolbar = (BrowserToolbar) findViewById(R.id.browser_toolbar);
+        mProgressView = (ToolbarProgressView) findViewById(R.id.progress);
+        mBrowserToolbar.setProgressBar(mProgressView);
+        if (Intent.ACTION_VIEW.equals(intent.getAction())) {
+            // Show the target URL immediately in the toolbar.
+            mBrowserToolbar.setTitle(intent.getDataString());
+        }
+
+//        ((GeckoApp.MainLayout) mMainLayout).setTouchEventInterceptor(new HideTabsTouchListener());
+//        ((GeckoApp.MainLayout) mMainLayout).setMotionEventInterceptor(new MotionEventInterceptor() {
+//            @Override
+//            public boolean onInterceptMotionEvent(View view, MotionEvent event) {
+//                // If we get a gamepad panning MotionEvent while the focus is not on the layerview,
+//                // put the focus on the layerview and carry on
+//                if (mLayerView != null && !mLayerView.hasFocus() && GamepadUtils.isPanningControl(event)) {
+//                    if (mHomePager == null) {
+//                        return false;
+//                    }
+//
+//                    if (isHomePagerVisible()) {
+//                        mLayerView.requestFocus();
+//                    } else {
+//                        mHomePager.requestFocus();
+//                    }
+//                }
+//                return false;
+//            }
+//        });
+
+        mHomePagerContainer = (ViewGroup) findViewById(R.id.home_pager_container);
+
+        mBrowserSearchContainer = findViewById(R.id.search_container);
+        mBrowserSearch = (BrowserSearch) getSupportFragmentManager().findFragmentByTag(BROWSER_SEARCH_TAG);
+        if (mBrowserSearch == null) {
+            mBrowserSearch = BrowserSearch.newInstance();
+            mBrowserSearch.setUserVisibleHint(false);
+        }
+
+        mBrowserToolbar.setOnActivateListener(new BrowserToolbar.OnActivateListener() {
+            public void onActivate() {
+                enterEditingMode();
+            }
+        });
+
+        mBrowserToolbar.setOnCommitListener(new BrowserToolbar.OnCommitListener() {
+            public void onCommit() {
+                commitEditingMode();
+            }
+        });
+
+        mBrowserToolbar.setOnDismissListener(new BrowserToolbar.OnDismissListener() {
+            public void onDismiss() {
+                mBrowserToolbar.cancelEdit();
+            }
+        });
+
+        mBrowserToolbar.setOnFilterListener(new BrowserToolbar.OnFilterListener() {
+            public void onFilter(String searchText, AutocompleteHandler handler) {
+                filterEditingMode(searchText, handler);
+            }
+        });
+
+        mBrowserToolbar.setOnFocusChangeListener(new View.OnFocusChangeListener() {
+            @Override
+            public void onFocusChange(View v, boolean hasFocus) {
+                if (isHomePagerVisible()) {
+                    mHomePager.onToolbarFocusChange(hasFocus);
+                }
+            }
+        });
+
+        mBrowserToolbar.setOnStartEditingListener(new BrowserToolbar.OnStartEditingListener() {
+            public void onStartEditing() {
+                // Temporarily disable doorhanger notifications.
+                mDoorHangerPopup.disable();
+            }
+        });
+
+        mBrowserToolbar.setOnStopEditingListener(new BrowserToolbar.OnStopEditingListener() {
+            public void onStopEditing() {
+                selectTargetTabForEditingMode();
+
+                // Since the underlying LayerView is set visible in hideHomePager, we would
+                // ordinarily want to call it first. However, hideBrowserSearch changes the
+                // visibility of the HomePager and hideHomePager will take no action if the
+                // HomePager is hidden, so we want to call hideBrowserSearch to restore the
+                // HomePager visibility first.
+                hideBrowserSearch();
+                hideHomePager();
+
+                // Re-enable doorhanger notifications. They may trigger on the selected tab above.
+                mDoorHangerPopup.enable();
+            }
+        });
+
+        // Intercept key events for gamepad shortcuts
+        mBrowserToolbar.setOnKeyListener(this);
+
+        mFindInPageBar = (FindInPageBar) findViewById(R.id.find_in_page);
+        mMediaCastingBar = (MediaCastingBar) findViewById(R.id.media_casting);
+
+        registerEventListener("CharEncoding:Data");
+        registerEventListener("CharEncoding:State");
+        registerEventListener("Feedback:LastUrl");
+        registerEventListener("Feedback:OpenPlayStore");
+        registerEventListener("Feedback:MaybeLater");
+        registerEventListener("Telemetry:Gather");
+        registerEventListener("Settings:Show");
+        registerEventListener("Updater:Launch");
+        registerEventListener("Menu:Add");
+        registerEventListener("Menu:Remove");
+        registerEventListener("Menu:Update");
+        registerEventListener("Accounts:Create");
+        registerEventListener("Accounts:Exist");
+
+        Distribution.init(this);
+        JavaAddonManager.getInstance().init(getApplicationContext());
+        mSharedPreferencesHelper = new SharedPreferencesHelper(getApplicationContext());
+        mOrderedBroadcastHelper = new OrderedBroadcastHelper(getApplicationContext());
+        mBrowserHealthReporter = new BrowserHealthReporter();
+
+        if (AppConstants.MOZ_ANDROID_BEAM && Build.VERSION.SDK_INT >= 14) {
+            NfcAdapter nfc = NfcAdapter.getDefaultAdapter(this);
+            if (nfc != null) {
+                nfc.setNdefPushMessageCallback(new NfcAdapter.CreateNdefMessageCallback() {
+                    @Override
+                    public NdefMessage createNdefMessage(NfcEvent event) {
+                        Tab tab = Tabs.getInstance().getSelectedTab();
+                        if (tab == null || tab.isPrivate()) {
+                            return null;
+                        }
+                        return new NdefMessage(new NdefRecord[] { NdefRecord.createUri(tab.getURL()) });
+                    }
+                }, this);
+            }
+        }
+
+        if (savedInstanceState != null) {
+            mDynamicToolbar.onRestoreInstanceState(savedInstanceState);
+            mHomePagerContainer.setPadding(0, savedInstanceState.getInt(STATE_ABOUT_HOME_TOP_PADDING), 0, 0);
+        }
+
+        mDynamicToolbar.setEnabledChangedListener(new DynamicToolbar.OnEnabledChangedListener() {
+            @Override
+            public void onEnabledChanged(boolean enabled) {
+                setDynamicToolbarEnabled(enabled);
+            }
+        });
+
+        // Set the maximum bits-per-pixel the favicon system cares about.
+        IconDirectoryEntry.setMaxBPP(GeckoAppShell.getScreenDepth());
+    }
+
+    @Override
+    public void onBackPressed() {
+        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
+            super.onBackPressed();
+            return;
+        }
+
+        if (mBrowserToolbar.onBackPressed()) {
+            return;
+        }
+
+        if (mActionMode != null) {
+            endActionModeCompat();
+            return;
+        }
+
+        super.onBackPressed();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        unregisterEventListener("Prompt:ShowTop");
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        // Register for Prompt:ShowTop so we can foreground this activity even if it's hidden.
+        registerEventListener("Prompt:ShowTop");
+    }
+
+    private void setDynamicToolbarEnabled(boolean enabled) {
+        ThreadUtils.assertOnUiThread();
+
+        if (enabled) {
+            if (mLayerView != null) {
+                mLayerView.getLayerClient().setOnMetricsChangedListener(this);
+            }
+            setToolbarMargin(0);
+            mHomePagerContainer.setPadding(0, mViewFlipper.getHeight(), 0, 0);
+        } else {
+            // Immediately show the toolbar when disabling the dynamic
+            // toolbar.
+            if (mLayerView != null) {
+                mLayerView.getLayerClient().setOnMetricsChangedListener(null);
+            }
+            mHomePagerContainer.setPadding(0, 0, 0, 0);
+            if (mViewFlipper != null) {
+                ViewHelper.setTranslationY(mViewFlipper, 0);
+            }
+        }
+
+        refreshToolbarHeight();
+    }
+
+    private static boolean isAboutHome(final Tab tab) {
+        return AboutPages.isAboutHome(tab.getURL());
+    }
+
+    @Override
+    public boolean onSearchRequested() {
+        enterEditingMode();
+        return true;
+    }
+
+    @Override
+    public boolean onContextItemSelected(MenuItem item) {
+        final int itemId = item.getItemId();
+        if (itemId == R.id.pasteandgo) {
+            String text = Clipboard.getText();
+            if (!TextUtils.isEmpty(text)) {
+                Tabs.getInstance().loadUrl(text);
+            }
+            return true;
+        }
+
+        if (itemId == R.id.site_settings) {
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Permissions:Get", null));
+            return true;
+        }
+
+        if (itemId == R.id.paste) {
+            String text = Clipboard.getText();
+            if (!TextUtils.isEmpty(text)) {
+                enterEditingMode(text);
+            }
+            return true;
+        }
+
+        if (itemId == R.id.share) {
+            shareCurrentUrl();
+            return true;
+        }
+
+        if (itemId == R.id.subscribe) {
+            subscribeToFeeds(Tabs.getInstance().getSelectedTab());
+            return true;
+        }
+
+        if (itemId == R.id.add_search_engine) {
+            Tab tab = Tabs.getInstance().getSelectedTab();
+            if (tab != null && tab.hasOpenSearch()) {
+                JSONObject args = new JSONObject();
+                try {
+                    args.put("tabId", tab.getId());
+                } catch (JSONException e) {
+                    Log.e(LOGTAG, "error building json arguments");
+                    return true;
+                }
+                GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("SearchEngines:Add", args.toString()));
+            }
+            return true;
+        }
+
+        if (itemId == R.id.copyurl) {
+            Tab tab = Tabs.getInstance().getSelectedTab();
+            if (tab != null) {
+                String url = tab.getURL();
+                if (url != null) {
+                    Clipboard.setText(url);
+                }
+            }
+            return true;
+        }
+
+        return false;
+    }
+
+    @Override
+    public void setAccessibilityEnabled(boolean enabled) {
+        mDynamicToolbar.setAccessibilityEnabled(enabled);
+    }
+
+    @Override
+    public void onDestroy() {
+        mDynamicToolbar.destroy();
+
+        if (mBrowserToolbar != null)
+            mBrowserToolbar.onDestroy();
+
+        if (mFindInPageBar != null) {
+            mFindInPageBar.onDestroy();
+            mFindInPageBar = null;
+        }
+
+        if (mMediaCastingBar != null) {
+            mMediaCastingBar.onDestroy();
+            mMediaCastingBar = null;
+        }
+
+        if (mSharedPreferencesHelper != null) {
+            mSharedPreferencesHelper.uninit();
+            mSharedPreferencesHelper = null;
+        }
+
+        if (mOrderedBroadcastHelper != null) {
+            mOrderedBroadcastHelper.uninit();
+            mOrderedBroadcastHelper = null;
+        }
+
+        if (mBrowserHealthReporter != null) {
+            mBrowserHealthReporter.uninit();
+            mBrowserHealthReporter = null;
+        }
+
+        unregisterEventListener("CharEncoding:Data");
+        unregisterEventListener("CharEncoding:State");
+        unregisterEventListener("Feedback:LastUrl");
+        unregisterEventListener("Feedback:OpenPlayStore");
+        unregisterEventListener("Feedback:MaybeLater");
+        unregisterEventListener("Telemetry:Gather");
+        unregisterEventListener("Settings:Show");
+        unregisterEventListener("Updater:Launch");
+        unregisterEventListener("Menu:Add");
+        unregisterEventListener("Menu:Remove");
+        unregisterEventListener("Menu:Update");
+        unregisterEventListener("Accounts:Create");
+        unregisterEventListener("Accounts:Exist");
+
+        if (AppConstants.MOZ_ANDROID_BEAM && Build.VERSION.SDK_INT >= 14) {
+            NfcAdapter nfc = NfcAdapter.getDefaultAdapter(this);
+            if (nfc != null) {
+                // null this out even though the docs say it's not needed,
+                // because the source code looks like it will only do this
+                // automatically on API 14+
+                nfc.setNdefPushMessageCallback(null, this);
+            }
+        }
+
+        super.onDestroy();
+    }
+
+    @Override
+    protected void initializeChrome() {
+        super.initializeChrome();
+
+        mDoorHangerPopup.setAnchor(mBrowserToolbar.getDoorHangerAnchor());
+
+        mDynamicToolbar.setLayerView(mLayerView);
+        setDynamicToolbarEnabled(mDynamicToolbar.isEnabled());
+
+        // Intercept key events for gamepad shortcuts
+        mLayerView.setOnKeyListener(this);
+
+        // Initialize the actionbar menu items on startup for both large and small tablets
+        if (HardwareUtils.isTablet()) {
+            onCreatePanelMenu(Window.FEATURE_OPTIONS_PANEL, null);
+            invalidateOptionsMenu();
+        }
+    }
+
+    private void shareCurrentUrl() {
+        Tab tab = Tabs.getInstance().getSelectedTab();
+        if (tab == null) {
+            return;
+        }
+
+        String url = tab.getURL();
+        if (url == null) {
+            return;
+        }
+
+        if (AboutPages.isAboutReader(url)) {
+            url = ReaderModeUtils.getUrlFromAboutReader(url);
+        }
+
+        GeckoAppShell.openUriExternal(url, "text/plain", "", "",
+                                      Intent.ACTION_SEND, tab.getDisplayTitle());
+    }
+
+    @Override
+    protected void loadStartupTab(String url) {
+        // We aren't showing about:home, so cancel the telemetry timer
+        if (url != null || mShouldRestore) {
+            mAboutHomeStartupTimer.cancel();
+        }
+
+        super.loadStartupTab(url);
+    }
+
+    private void setToolbarMargin(int margin) {
+        ((RelativeLayout.LayoutParams) mGeckoLayout.getLayoutParams()).topMargin = margin;
+        mGeckoLayout.requestLayout();
+    }
+
+    @Override
+    public void onMetricsChanged(ImmutableViewportMetrics aMetrics) {
+        if (isHomePagerVisible() || mViewFlipper == null) {
+            return;
+        }
+
+        // If the page has shrunk so that the toolbar no longer scrolls, make
+        // sure the toolbar is visible.
+        if (aMetrics.getPageHeight() <= aMetrics.getHeight()) {
+            if (mDynamicToolbarCanScroll) {
+                mDynamicToolbarCanScroll = false;
+                if (mViewFlipper.getVisibility() != View.VISIBLE) {
+                    ThreadUtils.postToUiThread(new Runnable() {
+                        public void run() {
+                            mDynamicToolbar.setVisible(true, VisibilityTransition.ANIMATE);
+                        }
+                    });
+                }
+            }
+        } else {
+            mDynamicToolbarCanScroll = true;
+        }
+
+        final View toolbarLayout = mViewFlipper;
+        final int marginTop = Math.round(aMetrics.marginTop);
+        ThreadUtils.postToUiThread(new Runnable() {
+            public void run() {
+                final float translationY = marginTop - toolbarLayout.getHeight();
+                ViewHelper.setTranslationY(toolbarLayout, translationY);
+                ViewHelper.setTranslationY(mProgressView, translationY);
+
+                if (mDoorHangerPopup.isShowing()) {
+                    mDoorHangerPopup.updatePopup();
+                }
+            }
+        });
+
+        if (mFormAssistPopup != null)
+            mFormAssistPopup.onMetricsChanged(aMetrics);
+    }
+
+    @Override
+    public void onPanZoomStopped() {
+        if (!mDynamicToolbar.isEnabled() || isHomePagerVisible()) {
+            return;
+        }
+
+        // Make sure the toolbar is fully hidden or fully shown when the user
+        // lifts their finger. If the page is shorter than the viewport, the
+        // toolbar is always shown.
+        ImmutableViewportMetrics metrics = mLayerView.getViewportMetrics();
+        if (metrics.getPageHeight() < metrics.getHeight()
+              || metrics.marginTop >= mToolbarHeight / 2) {
+            mDynamicToolbar.setVisible(true, VisibilityTransition.ANIMATE);
+        } else {
+            mDynamicToolbar.setVisible(false, VisibilityTransition.ANIMATE);
+        }
+    }
+
+    public void refreshToolbarHeight() {
+        ThreadUtils.assertOnUiThread();
+
+        int height = 0;
+        if (mViewFlipper != null) {
+            height = mViewFlipper.getHeight();
+        }
+
+        if (!mDynamicToolbar.isEnabled() || isHomePagerVisible()) {
+            // Use aVisibleHeight here so that when the dynamic toolbar is
+            // enabled, the padding will animate with the toolbar becoming
+            // visible.
+            if (mDynamicToolbar.isEnabled()) {
+                // When the dynamic toolbar is enabled, set the padding on the
+                // about:home widget directly - this is to avoid resizing the
+                // LayerView, which can cause visible artifacts.
+                mHomePagerContainer.setPadding(0, height, 0, 0);
+            } else {
+                setToolbarMargin(height);
+                height = 0;
+            }
+        } else {
+            setToolbarMargin(0);
+        }
+
+        if (mLayerView != null && height != mToolbarHeight) {
+            mToolbarHeight = height;
+            mLayerView.getLayerMarginsAnimator().setMaxMargins(0, height, 0, 0);
+            mDynamicToolbar.setVisible(true, VisibilityTransition.IMMEDIATE);
+        }
+    }
+
+    @Override
+    void toggleChrome(final boolean aShow) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                if (aShow) {
+                    mViewFlipper.setVisibility(View.VISIBLE);
+                } else {
+                    mViewFlipper.setVisibility(View.GONE);
+                    if (hasTabsSideBar()) {
+                        hideTabs();
+                    }
+                }
+            }
+        });
+
+        super.toggleChrome(aShow);
+    }
+
+    @Override
+    void focusChrome() {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                mViewFlipper.setVisibility(View.VISIBLE);
+                mViewFlipper.requestFocusFromTouch();
+            }
+        });
+    }
+
+    @Override
+    public void refreshChrome() {
+        invalidateOptionsMenu();
+
+        if (mTabsPanel != null) {
+            updateSideBarState();
+            mTabsPanel.refresh();
+        }
+
+        mBrowserToolbar.refresh();
+    }
+
+    @Override
+    public boolean hasTabsSideBar() {
+        return (mTabsPanel != null && mTabsPanel.isSideBar());
+    }
+
+    private void updateSideBarState() {
+        if (mMainLayoutAnimator != null)
+            mMainLayoutAnimator.stop();
+
+        boolean isSideBar = (HardwareUtils.isTablet() && getOrientation() == Configuration.ORIENTATION_LANDSCAPE);
+        final int sidebarWidth = getResources().getDimensionPixelSize(R.dimen.tabs_sidebar_width);
+
+        ViewGroup.MarginLayoutParams lp = (ViewGroup.MarginLayoutParams) mTabsPanel.getLayoutParams();
+        lp.width = (isSideBar ? sidebarWidth : ViewGroup.LayoutParams.FILL_PARENT);
+        mTabsPanel.requestLayout();
+
+        final boolean sidebarIsShown = (isSideBar && mTabsPanel.isShown());
+        final int mainLayoutScrollX = (sidebarIsShown ? -sidebarWidth : 0);
+        mMainLayout.scrollTo(mainLayoutScrollX, 0);
+
+        mTabsPanel.setIsSideBar(isSideBar);
+    }
+
+    @Override
+    public void handleMessage(String event, JSONObject message) {
+        try {
+            if (event.equals("Menu:Add")) {
+                MenuItemInfo info = new MenuItemInfo();
+                info.label = message.getString("name");
+                info.id = message.getInt("id") + ADDON_MENU_OFFSET;
+                info.icon = message.optString("icon", null);
+                info.checked = message.optBoolean("checked", false);
+                info.enabled = message.optBoolean("enabled", true);
+                info.visible = message.optBoolean("visible", true);
+                info.checkable = message.optBoolean("checkable", false);
+                int parent = message.optInt("parent", 0);
+                info.parent = parent <= 0 ? parent : parent + ADDON_MENU_OFFSET;
+                final MenuItemInfo menuItemInfo = info;
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        addAddonMenuItem(menuItemInfo);
+                    }
+                });
+            } else if (event.equals("Menu:Remove")) {
+                final int id = message.getInt("id") + ADDON_MENU_OFFSET;
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        removeAddonMenuItem(id);
+                    }
+                });
+            } else if (event.equals("Menu:Update")) {
+                final int id = message.getInt("id") + ADDON_MENU_OFFSET;
+                final JSONObject options = message.getJSONObject("options");
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        updateAddonMenuItem(id, options);
+                    }
+                });
+            } else if (event.equals("CharEncoding:Data")) {
+                final JSONArray charsets = message.getJSONArray("charsets");
+                int selected = message.getInt("selected");
+
+                final int len = charsets.length();
+                final String[] titleArray = new String[len];
+                for (int i = 0; i < len; i++) {
+                    JSONObject charset = charsets.getJSONObject(i);
+                    titleArray[i] = charset.getString("title");
+                }
+
+                final AlertDialog.Builder dialogBuilder = new AlertDialog.Builder(this);
+                dialogBuilder.setSingleChoiceItems(titleArray, selected, new AlertDialog.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        try {
+                            JSONObject charset = charsets.getJSONObject(which);
+                            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("CharEncoding:Set", charset.getString("code")));
+                            dialog.dismiss();
+                        } catch (JSONException e) {
+                            Log.e(LOGTAG, "error parsing json", e);
+                        }
+                    }
+                });
+                dialogBuilder.setNegativeButton(R.string.button_cancel, new AlertDialog.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        dialog.dismiss();
+                    }
+                });
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        dialogBuilder.show();
+                    }
+                });
+            } else if (event.equals("CharEncoding:State")) {
+                final boolean visible = message.getString("visible").equals("true");
+                GeckoPreferences.setCharEncodingState(visible);
+                final Menu menu = mMenu;
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (menu != null)
+                            menu.findItem(R.id.char_encoding).setVisible(visible);
+                    }
+                });
+            } else if (event.equals("Feedback:OpenPlayStore")) {
+                Intent intent = new Intent(Intent.ACTION_VIEW);
+                intent.setData(Uri.parse("market://details?id=" + getPackageName()));
+                startActivity(intent);
+            } else if (event.equals("Feedback:MaybeLater")) {
+                resetFeedbackLaunchCount();
+            } else if (event.equals("Feedback:LastUrl")) {
+                getLastUrl();
+            } else if (event.equals("Gecko:DelayedStartup")) {
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        // Force tabs panel inflation once the initial
+                        // pageload is finished.
+                        ensureTabsPanelExists();
+                    }
+                });
+
+                super.handleMessage(event, message);
+            } else if (event.equals("Gecko:Ready")) {
+                // Handle this message in GeckoApp, but also enable the Settings
+                // menuitem, which is specific to BrowserApp.
+                super.handleMessage(event, message);
+                final Menu menu = mMenu;
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (menu != null)
+                            menu.findItem(R.id.settings).setEnabled(true);
+                    }
+                });
+
+                // Display notification for Mozilla data reporting, if data should be collected.
+                if (AppConstants.MOZ_DATA_REPORTING) {
+                    DataReportingNotification.checkAndNotifyPolicy(GeckoAppShell.getContext());
+                }
+
+            } else if (event.equals("Telemetry:Gather")) {
+                Telemetry.HistogramAdd("PLACES_PAGES_COUNT", BrowserDB.getCount(getContentResolver(), "history"));
+                Telemetry.HistogramAdd("PLACES_BOOKMARKS_COUNT", BrowserDB.getCount(getContentResolver(), "bookmarks"));
+                Telemetry.HistogramAdd("FENNEC_FAVICONS_COUNT", BrowserDB.getCount(getContentResolver(), "favicons"));
+                Telemetry.HistogramAdd("FENNEC_THUMBNAILS_COUNT", BrowserDB.getCount(getContentResolver(), "thumbnails"));
+            } else if (event.equals("Reader:ListCountRequest")) {
+                handleReaderListCountRequest();
+            } else if (event.equals("Reader:ListStatusRequest")) {
+                handleReaderListStatusRequest(message.getString("url"));
+            } else if (event.equals("Reader:Added")) {
+                final int result = message.getInt("result");
+                handleReaderAdded(result, messageToReadingListContentValues(message));
+            } else if (event.equals("Reader:Removed")) {
+                final String url = message.getString("url");
+                handleReaderRemoved(url);
+            } else if (event.equals("Reader:Share")) {
+                final String title = message.getString("title");
+                final String url = message.getString("url");
+                GeckoAppShell.openUriExternal(url, "text/plain", "", "",
+                                              Intent.ACTION_SEND, title);
+            } else if (event.equals("Settings:Show")) {
+                // null strings return "null" (http://code.google.com/p/android/issues/detail?id=13830)
+                String resource = null;
+                if (!message.isNull(GeckoPreferences.INTENT_EXTRA_RESOURCES)) {
+                    resource = message.getString(GeckoPreferences.INTENT_EXTRA_RESOURCES);
+                }
+                Intent settingsIntent = new Intent(this, GeckoPreferences.class);
+                GeckoPreferences.setResourceToOpen(settingsIntent, resource);
+                startActivity(settingsIntent);
+            } else if (event.equals("Updater:Launch")) {
+                handleUpdaterLaunch();
+            } else if (event.equals("Prompt:ShowTop")) {
+                // Bring this activity to front so the prompt is visible..
+                Intent bringToFrontIntent = new Intent();
+                bringToFrontIntent.setClassName(AppConstants.ANDROID_PACKAGE_NAME, AppConstants.BROWSER_INTENT_CLASS);
+                bringToFrontIntent.setFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
+                startActivity(bringToFrontIntent);
+            } else if (event.equals("Accounts:Create")) {
+                // Do exactly the same thing as if you tapped 'Sync'
+                // in Settings.
+                final Intent intent = new Intent(getContext(), FxAccountGetStartedActivity.class);
+                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                getContext().startActivity(intent);
+            } else if (event.equals("Accounts:Exist")) {
+                final String kind = message.getString("kind");
+                final JSONObject response = new JSONObject();
+
+                if ("any".equals(kind)) {
+                    response.put("exists", SyncAccounts.syncAccountsExist(getContext()) ||
+                                           FirefoxAccounts.firefoxAccountsExist(getContext()));
+                    EventDispatcher.sendResponse(message, response);
+                } else if ("fxa".equals(kind)) {
+                    response.put("exists", FirefoxAccounts.firefoxAccountsExist(getContext()));
+                    EventDispatcher.sendResponse(message, response);
+                } else if ("sync11".equals(kind)) {
+                    response.put("exists", SyncAccounts.syncAccountsExist(getContext()));
+                    EventDispatcher.sendResponse(message, response);
+                } else {
+                    response.put("error", "Unknown kind");
+                    EventDispatcher.sendError(message, response);
+                }
+            } else {
+                super.handleMessage(event, message);
+            }
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Exception handling message \"" + event + "\":", e);
+        }
+    }
+
+    @Override
+    public void addTab() {
+        // Always load about:home when opening a new tab.
+        Tabs.getInstance().loadUrl(AboutPages.HOME, Tabs.LOADURL_NEW_TAB);
+    }
+
+    @Override
+    public void addPrivateTab() {
+        Tabs.getInstance().loadUrl(AboutPages.PRIVATEBROWSING, Tabs.LOADURL_NEW_TAB | Tabs.LOADURL_PRIVATE);
+    }
+
+    @Override
+    public void showNormalTabs() {
+        showTabs(TabsPanel.Panel.NORMAL_TABS);
+    }
+
+    @Override
+    public void showPrivateTabs() {
+        showTabs(TabsPanel.Panel.PRIVATE_TABS);
+    }
+
+    @Override
+    public void showRemoteTabs() {
+        showTabs(TabsPanel.Panel.REMOTE_TABS);
+    }
+
+    /**
+     * Ensure the TabsPanel view is properly inflated and returns
+     * true when the view has been inflated, false otherwise.
+     */
+    private boolean ensureTabsPanelExists() {
+        if (mTabsPanel != null) {
+            return false;
+        }
+
+        ViewStub tabsPanelStub = (ViewStub) findViewById(R.id.tabs_panel);
+        mTabsPanel = (TabsPanel) tabsPanelStub.inflate();
+
+        mTabsPanel.setTabsLayoutChangeListener(this);
+        updateSideBarState();
+
+        return true;
+    }
+
+    private void showTabs(final TabsPanel.Panel panel) {
+        if (Tabs.getInstance().getDisplayCount() == 0)
+            return;
+
+        if (ensureTabsPanelExists()) {
+            // If we've just inflated the tabs panel, only show it once the current
+            // layout pass is done to avoid displayed temporary UI states during
+            // relayout.
+            ViewTreeObserver vto = mTabsPanel.getViewTreeObserver();
+            if (vto.isAlive()) {
+                vto.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
+                    @Override
+                    public void onGlobalLayout() {
+                        mTabsPanel.getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                        mTabsPanel.show(panel);
+                    }
+                });
+            }
+        } else {
+            mTabsPanel.show(panel);
+        }
+    }
+
+    @Override
+    public void hideTabs() {
+        mTabsPanel.hide();
+    }
+
+    @Override
+    public boolean autoHideTabs() {
+        if (areTabsShown()) {
+            hideTabs();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean areTabsShown() {
+        return (mTabsPanel != null && mTabsPanel.isShown());
+    }
+
+    @Override
+    public void onTabsLayoutChange(int width, int height) {
+        int animationLength = TABS_ANIMATION_DURATION;
+
+        if (mMainLayoutAnimator != null) {
+            animationLength = Math.max(1, animationLength - (int)mMainLayoutAnimator.getRemainingTime());
+            mMainLayoutAnimator.stop(false);
+        }
+
+        if (areTabsShown()) {
+            mTabsPanel.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
+        }
+
+        mMainLayoutAnimator = new PropertyAnimator(animationLength, sTabsInterpolator);
+        mMainLayoutAnimator.addPropertyAnimationListener(this);
+
+        if (hasTabsSideBar()) {
+            mMainLayoutAnimator.attach(mMainLayout,
+                                       PropertyAnimator.Property.SCROLL_X,
+                                       -width);
+        } else {
+            mMainLayoutAnimator.attach(mMainLayout,
+                                       PropertyAnimator.Property.SCROLL_Y,
+                                       -height);
+        }
+
+        mTabsPanel.prepareTabsAnimation(mMainLayoutAnimator);
+        mBrowserToolbar.prepareTabsAnimation(mMainLayoutAnimator, areTabsShown());
+
+        // If the tabs layout is animating onto the screen, pin the dynamic
+        // toolbar.
+        if (mDynamicToolbar.isEnabled()) {
+            if (width > 0 && height > 0) {
+                mDynamicToolbar.setPinned(true, PinReason.RELAYOUT);
+                mDynamicToolbar.setVisible(true, VisibilityTransition.ANIMATE);
+            } else {
+                mDynamicToolbar.setPinned(false, PinReason.RELAYOUT);
+            }
+        }
+
+        mMainLayoutAnimator.start();
+    }
+
+    @Override
+    public void onPropertyAnimationStart() {
+    }
+
+    @Override
+    public void onPropertyAnimationEnd() {
+        if (!areTabsShown()) {
+            mTabsPanel.setVisibility(View.INVISIBLE);
+            mTabsPanel.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
+        }
+
+        mTabsPanel.finishTabsAnimation();
+
+        mMainLayoutAnimator = null;
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        mDynamicToolbar.onSaveInstanceState(outState);
+        outState.putInt(STATE_ABOUT_HOME_TOP_PADDING, mHomePagerContainer.getPaddingTop());
+    }
+
+    /**
+     * Attempts to switch to an open tab with the given URL.
+     *
+     * @return true if we successfully switched to a tab, false otherwise.
+     */
+    private boolean maybeSwitchToTab(String url, EnumSet<OnUrlOpenListener.Flags> flags) {
+        if (!flags.contains(OnUrlOpenListener.Flags.ALLOW_SWITCH_TO_TAB)) {
+            return false;
+        }
+
+        final Tabs tabs = Tabs.getInstance();
+        final Tab tab = tabs.getFirstTabForUrl(url, tabs.getSelectedTab().isPrivate());
+        if (tab == null) {
+            return false;
+        }
+
+        // Set the target tab to null so it does not get selected (on editing
+        // mode exit) in lieu of the tab we are about to select.
+        mTargetTabForEditingMode = null;
+        tabs.selectTab(tab.getId());
+
+        mBrowserToolbar.cancelEdit();
+
+        return true;
+    }
+
+    private void openUrlAndStopEditing(String url) {
+        openUrlAndStopEditing(url, null, false);
+    }
+
+    private void openUrlAndStopEditing(String url, boolean newTab) {
+        openUrlAndStopEditing(url, null, newTab);
+    }
+
+    private void openUrlAndStopEditing(String url, String searchEngine) {
+        openUrlAndStopEditing(url, searchEngine, false);
+    }
+
+    private void openUrlAndStopEditing(String url, String searchEngine, boolean newTab) {
+        int flags = Tabs.LOADURL_NONE;
+        if (newTab) {
+            flags |= Tabs.LOADURL_NEW_TAB;
+        }
+
+        Tabs.getInstance().loadUrl(url, searchEngine, -1, flags);
+
+        mBrowserToolbar.cancelEdit();
+    }
+
+    private boolean isHomePagerVisible() {
+        return (mHomePager != null && mHomePager.isLoaded()
+            && mHomePagerContainer != null && mHomePagerContainer.getVisibility() == View.VISIBLE);
+    }
+
+    /* Favicon stuff. */
+    private static OnFaviconLoadedListener sFaviconLoadedListener = new OnFaviconLoadedListener() {
+        @Override
+        public void onFaviconLoaded(String pageUrl, String faviconURL, Bitmap favicon) {
+            // If we failed to load a favicon, we use the default favicon instead.
+            Tabs.getInstance()
+                .updateFaviconForURL(pageUrl,
+                                     (favicon == null) ? Favicons.defaultFavicon : favicon);
+        }
+    };
+
+    private void loadFavicon(final Tab tab) {
+        maybeCancelFaviconLoad(tab);
+
+        final int tabFaviconSize = getResources().getDimensionPixelSize(R.dimen.browser_toolbar_favicon_size);
+
+        int flags = (tab.isPrivate() || tab.getErrorType() != Tab.ErrorType.NONE) ? 0 : LoadFaviconTask.FLAG_PERSIST;
+        int id = Favicons.getSizedFavicon(tab.getURL(), tab.getFaviconURL(), tabFaviconSize, flags, sFaviconLoadedListener);
+
+        tab.setFaviconLoadId(id);
+    }
+
+    private void maybeCancelFaviconLoad(Tab tab) {
+        int faviconLoadId = tab.getFaviconLoadId();
+
+        if (Favicons.NOT_LOADING == faviconLoadId) {
+            return;
+        }
+
+        // Cancel load task and reset favicon load state if it wasn't already
+        // in NOT_LOADING state.
+        Favicons.cancelFaviconLoad(faviconLoadId);
+        tab.setFaviconLoadId(Favicons.NOT_LOADING);
+    }
+
+    /**
+     * Enters editing mode with the current tab's URL. There might be no
+     * tabs loaded by the time the user enters editing mode e.g. just after
+     * the app starts. In this case, we simply fallback to an empty URL.
+     */
+    private void enterEditingMode() {
+        String url = "";
+
+        final Tab tab = Tabs.getInstance().getSelectedTab();
+        if (tab != null) {
+            final String userSearch = tab.getUserSearch();
+
+            // Check to see if there's a user-entered search term,
+            // which we save whenever the user performs a search.
+            url = (TextUtils.isEmpty(userSearch) ? tab.getURL() : userSearch);
+        }
+
+        enterEditingMode(url);
+    }
+
+    /**
+     * Enters editing mode with the specified URL. This method will
+     * always open the HISTORY page on about:home.
+     */
+    private void enterEditingMode(String url) {
+        if (url == null) {
+            throw new IllegalArgumentException("Cannot handle null URLs in enterEditingMode");
+        }
+
+        final Tab selectedTab = Tabs.getInstance().getSelectedTab();
+        mTargetTabForEditingMode = (selectedTab != null ? selectedTab.getId() : null);
+
+        final PropertyAnimator animator = new PropertyAnimator(250);
+        animator.setUseHardwareLayer(false);
+
+        mBrowserToolbar.startEditing(url, animator);
+        showHomePagerWithAnimator(animator);
+
+        animator.start();
+    }
+
+    private void commitEditingMode() {
+        if (!mBrowserToolbar.isEditing()) {
+            return;
+        }
+
+        final String url = mBrowserToolbar.commitEdit();
+
+        // HACK: We don't know the url that will be loaded when hideHomePager is initially called
+        // in BrowserToolbar's onStopEditing listener so on the awesomescreen, hideHomePager will
+        // use the url "about:home" and return without taking any action. hideBrowserSearch is
+        // then called, but since hideHomePager changes both HomePager and LayerView visibility
+        // and exited without taking an action, no Views are displayed and graphical corruption is
+        // visible instead.
+        //
+        // Here we call hideHomePager for the second time with the URL to be loaded so that
+        // hideHomePager is called with the correct state for the upcoming page load.
+        //
+        // Expected to be fixed by bug 915825.
+        hideHomePager(url);
+
+        // Don't do anything if the user entered an empty URL.
+        if (TextUtils.isEmpty(url)) {
+            return;
+        }
+
+        // If the URL doesn't look like a search query, just load it.
+        if (!StringUtils.isSearchQuery(url, true)) {
+            Tabs.getInstance().loadUrl(url, Tabs.LOADURL_USER_ENTERED);
+            return;
+        }
+
+        // Otherwise, check for a bookmark keyword.
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                final String keyword;
+                final String keywordSearch;
+
+                final int index = url.indexOf(" ");
+                if (index == -1) {
+                    keyword = url;
+                    keywordSearch = "";
+                } else {
+                    keyword = url.substring(0, index);
+                    keywordSearch = url.substring(index + 1);
+                }
+
+                final String keywordUrl = BrowserDB.getUrlForKeyword(getContentResolver(), keyword);
+
+                // If there isn't a bookmark keyword, load the url. This may result in a query
+                // using the default search engine.
+                if (TextUtils.isEmpty(keywordUrl)) {
+                    Tabs.getInstance().loadUrl(url, Tabs.LOADURL_USER_ENTERED);
+                    return;
+                }
+
+                recordSearch(null, "barkeyword");
+
+                // Otherwise, construct a search query from the bookmark keyword.
+                final String searchUrl = keywordUrl.replace("%s", URLEncoder.encode(keywordSearch));
+                Tabs.getInstance().loadUrl(searchUrl, Tabs.LOADURL_USER_ENTERED);
+            }
+        });
+    }
+
+    /**
+     * Record in Health Report that a search has occurred.
+     *
+     * @param engine
+     *        a search engine instance. Can be null.
+     * @param where
+     *        where the search was initialized; one of the values in
+     *        {@link BrowserHealthRecorder#SEARCH_LOCATIONS}.
+     */
+    private static void recordSearch(SearchEngine engine, String where) {
+        Log.i(LOGTAG, "Recording search: " +
+                      ((engine == null) ? "null" : engine.name) +
+                      ", " + where);
+        try {
+            String identifier = (engine == null) ? "other" : engine.getEngineIdentifier();
+            JSONObject message = new JSONObject();
+            message.put("type", BrowserHealthRecorder.EVENT_SEARCH);
+            message.put("location", where);
+            message.put("identifier", identifier);
+            GeckoAppShell.getEventDispatcher().dispatchEvent(message);
+        } catch (Exception e) {
+            Log.w(LOGTAG, "Error recording search.", e);
+        }
+    }
+
+    void filterEditingMode(String searchTerm, AutocompleteHandler handler) {
+        if (TextUtils.isEmpty(searchTerm)) {
+            hideBrowserSearch();
+        } else {
+            showBrowserSearch();
+            mBrowserSearch.filter(searchTerm, handler);
+        }
+    }
+
+    /**
+     * Selects the target tab for editing mode. This is expected to be the tab selected on editing
+     * mode entry, unless it is subsequently overridden.
+     *
+     * A background tab may be selected while editing mode is active (e.g. popups), causing the
+     * new url to load in the newly selected tab. Call this method on editing mode exit to
+     * mitigate this.
+     */
+    private void selectTargetTabForEditingMode() {
+        if (mTargetTabForEditingMode != null) {
+            Tabs.getInstance().selectTab(mTargetTabForEditingMode);
+        }
+
+        mTargetTabForEditingMode = null;
+    }
+
+    /**
+     * Shows or hides the home pager for the given tab.
+     */
+    private void updateHomePagerForTab(Tab tab) {
+        // Don't change the visibility of the home pager if we're in editing mode.
+        if (mBrowserToolbar.isEditing()) {
+            return;
+        }
+
+        if (isAboutHome(tab)) {
+            final String pageId = AboutPages.getPageIdFromAboutHomeUrl(tab.getURL());
+            showHomePager(pageId);
+
+            if (mDynamicToolbar.isEnabled()) {
+                mDynamicToolbar.setVisible(true, VisibilityTransition.ANIMATE);
+            }
+        } else {
+            hideHomePager();
+        }
+    }
+
+    @Override
+    public void onLocaleReady(final String locale) {
+        super.onLocaleReady(locale);
+
+        HomeConfigInvalidator.getInstance().onLocaleReady(locale);
+
+        if (mMenu != null) {
+            mMenu.clear();
+            onCreateOptionsMenu(mMenu);
+        }
+    }
+
+    private void showHomePager(String pageId) {
+        showHomePagerWithAnimator(pageId, null);
+    }
+
+    private void showHomePagerWithAnimator(PropertyAnimator animator) {
+        // Passing null here means the default page will be defined
+        // by the HomePager's configuration.
+        showHomePagerWithAnimator(null, animator);
+    }
+
+    private void showHomePagerWithAnimator(String pageId, PropertyAnimator animator) {
+        if (isHomePagerVisible()) {
+            return;
+        }
+
+        // Refresh toolbar height to possibly restore the toolbar padding
+        refreshToolbarHeight();
+
+        // Show the toolbar before hiding about:home so the
+        // onMetricsChanged callback still works.
+        if (mDynamicToolbar.isEnabled()) {
+            mDynamicToolbar.setVisible(true, VisibilityTransition.IMMEDIATE);
+        }
+
+        if (mHomePager == null) {
+            final ViewStub homePagerStub = (ViewStub) findViewById(R.id.home_pager_stub);
+            mHomePager = (HomePager) homePagerStub.inflate();
+
+            // Don't show the banner in guest mode.
+            if (!getProfile().inGuestMode()) {
+                final ViewStub homeBannerStub = (ViewStub) findViewById(R.id.home_banner_stub);
+                final HomeBanner homeBanner = (HomeBanner) homeBannerStub.inflate();
+                mHomePager.setBanner(homeBanner);
+
+                // Remove the banner from the view hierarchy if it is dismissed.
+                homeBanner.setOnDismissListener(new HomeBanner.OnDismissListener() {
+                    @Override
+                    public void onDismiss() {
+                        mHomePager.setBanner(null);
+                        mHomePagerContainer.removeView(homeBanner);
+                    }
+                });
+            }
+        }
+
+        mHomePagerContainer.setVisibility(View.VISIBLE);
+        mHomePager.load(getSupportLoaderManager(),
+                        getSupportFragmentManager(),
+                        pageId, animator);
+
+        // Hide the web content so it cannot be focused by screen readers.
+        hideWebContentOnPropertyAnimationEnd(animator);
+    }
+
+    private void hideWebContentOnPropertyAnimationEnd(final PropertyAnimator animator) {
+        if (animator == null) {
+            hideWebContent();
+            return;
+        }
+
+        animator.addPropertyAnimationListener(new PropertyAnimator.PropertyAnimationListener() {
+            @Override
+            public void onPropertyAnimationStart() {
+                mHideWebContentOnAnimationEnd = true;
+            }
+
+            @Override
+            public void onPropertyAnimationEnd() {
+                if (mHideWebContentOnAnimationEnd) {
+                    hideWebContent();
+                }
+            }
+        });
+    }
+
+    private void hideWebContent() {
+        // The view is set to INVISIBLE, rather than GONE, to avoid
+        // the additional requestLayout() call.
+        mLayerView.setVisibility(View.INVISIBLE);
+    }
+
+    /**
+     * Hides the HomePager, using the url of the currently selected tab as the url to be
+     * loaded.
+     */
+    private void hideHomePager() {
+        final Tab selectedTab = Tabs.getInstance().getSelectedTab();
+        final String url = (selectedTab != null) ? selectedTab.getURL() : null;
+
+        hideHomePager(url);
+    }
+
+    /**
+     * Hides the HomePager. The given url should be the url of the page to be loaded, or null
+     * if a new page is not being loaded.
+     */
+    private void hideHomePager(final String url) {
+        if (!isHomePagerVisible() || AboutPages.isAboutHome(url)) {
+            return;
+        }
+
+        // Prevent race in hiding web content - see declaration for more info.
+        mHideWebContentOnAnimationEnd = false;
+
+        // Display the previously hidden web content (which prevented screen reader access).
+        mLayerView.setVisibility(View.VISIBLE);
+        mHomePagerContainer.setVisibility(View.GONE);
+
+        if (mHomePager != null) {
+            mHomePager.unload();
+        }
+
+        mBrowserToolbar.setNextFocusDownId(R.id.layer_view);
+
+        // Refresh toolbar height to possibly restore the toolbar padding
+        refreshToolbarHeight();
+    }
+
+    private void showBrowserSearch() {
+        if (mBrowserSearch.getUserVisibleHint()) {
+            return;
+        }
+
+        mBrowserSearchContainer.setVisibility(View.VISIBLE);
+
+        // Prevent overdraw by hiding the underlying HomePager View.
+        mHomePager.setVisibility(View.INVISIBLE);
+
+        final FragmentManager fm = getSupportFragmentManager();
+
+        // In certain situations, showBrowserSearch() can be called immediately after hideBrowserSearch()
+        // (see bug 925012). Because of an Android bug (http://code.google.com/p/android/issues/detail?id=61179),
+        // calling FragmentTransaction#add immediately after FragmentTransaction#remove won't add the fragment's
+        // view to the layout. Calling FragmentManager#executePendingTransactions before re-adding the fragment
+        // prevents this issue.
+        fm.executePendingTransactions();
+
+        fm.beginTransaction().add(R.id.search_container, mBrowserSearch, BROWSER_SEARCH_TAG).commitAllowingStateLoss();
+        mBrowserSearch.setUserVisibleHint(true);
+    }
+
+    private void hideBrowserSearch() {
+        if (!mBrowserSearch.getUserVisibleHint()) {
+            return;
+        }
+
+        // To prevent overdraw, the HomePager is hidden when BrowserSearch is displayed:
+        // reverse that.
+        mHomePager.setVisibility(View.VISIBLE);
+
+        mBrowserSearchContainer.setVisibility(View.INVISIBLE);
+
+        getSupportFragmentManager().beginTransaction()
+                .remove(mBrowserSearch).commitAllowingStateLoss();
+        mBrowserSearch.setUserVisibleHint(false);
+    }
+
+    private class HideTabsTouchListener implements TouchEventInterceptor {
+        private boolean mIsHidingTabs = false;
+
+        @Override
+        public boolean onInterceptTouchEvent(View view, MotionEvent event) {
+            // We need to account for scroll state for the touched view otherwise
+            // tapping on an "empty" part of the view will still be considered a
+            // valid touch event.
+            if (view.getScrollX() != 0 || view.getScrollY() != 0) {
+                Rect rect = new Rect();
+                view.getHitRect(rect);
+                rect.offset(-view.getScrollX(), -view.getScrollY());
+
+                int[] viewCoords = new int[2];
+                view.getLocationOnScreen(viewCoords);
+
+                int x = (int) event.getRawX() - viewCoords[0];
+                int y = (int) event.getRawY() - viewCoords[1];
+
+                if (!rect.contains(x, y))
+                    return false;
+            }
+
+            // If the tab tray is showing, hide the tab tray and don't send the event to content.
+            if (event.getActionMasked() == MotionEvent.ACTION_DOWN && autoHideTabs()) {
+                mIsHidingTabs = true;
+                return true;
+            }
+            return false;
+        }
+
+        @Override
+        public boolean onTouch(View view, MotionEvent event) {
+            if (mIsHidingTabs) {
+                // Keep consuming events until the gesture finishes.
+                int action = event.getActionMasked();
+                if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
+                    mIsHidingTabs = false;
+                }
+                return true;
+            }
+            return false;
+        }
+    }
+
+    private static Menu findParentMenu(Menu menu, MenuItem item) {
+        final int itemId = item.getItemId();
+
+        final int count = (menu != null) ? menu.size() : 0;
+        for (int i = 0; i < count; i++) {
+            MenuItem menuItem = menu.getItem(i);
+            if (menuItem.getItemId() == itemId) {
+                return menu;
+            }
+            if (menuItem.hasSubMenu()) {
+                Menu parent = findParentMenu(menuItem.getSubMenu(), item);
+                if (parent != null) {
+                    return parent;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Add the provided item to the provided menu, which should be
+     * the root (mMenu).
+     */
+    private void addAddonMenuItemToMenu(final Menu menu, final MenuItemInfo info) {
+        info.added = true;
+        
+        final Menu destination;
+        if (info.parent == 0) {
+            destination = menu;
+        } else if (info.parent == GECKO_TOOLS_MENU) {
+            MenuItem tools = menu.findItem(R.id.tools);
+            destination = tools != null ? tools.getSubMenu() : menu;
+        } else {
+            MenuItem parent = menu.findItem(info.parent);
+            if (parent == null) {
+                return;
+            }
+
+            Menu parentMenu = findParentMenu(menu, parent);
+
+            if (!parent.hasSubMenu()) {
+                parentMenu.removeItem(parent.getItemId());
+                destination = parentMenu.addSubMenu(Menu.NONE, parent.getItemId(), Menu.NONE, parent.getTitle());
+                if (parent.getIcon() != null) {
+                    ((SubMenu) destination).getItem().setIcon(parent.getIcon());
+                }
+            } else {
+                destination = parent.getSubMenu();
+            }
+        }
+
+        MenuItem item = destination.add(Menu.NONE, info.id, Menu.NONE, info.label);
+
+        item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {
+            @Override
+            public boolean onMenuItemClick(MenuItem item) {
+                Log.i(LOGTAG, "Menu item clicked");
+                GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Menu:Clicked", Integer.toString(info.id - ADDON_MENU_OFFSET)));
+                return true;
+            }
+        });
+
+        if (info.icon == null) {
+            item.setIcon(R.drawable.ic_menu_addons_filler);
+        } else {
+            final int id = info.id;
+            BitmapUtils.getDrawable(this, info.icon, new BitmapUtils.BitmapLoader() {
+                @Override
+                public void onBitmapFound(Drawable d) {
+                    // TODO: why do we re-find the item?
+                    MenuItem item = destination.findItem(id);
+                    if (item == null) {
+                        return;
+                    }
+                    if (d == null) {
+                        item.setIcon(R.drawable.ic_menu_addons_filler);
+                        return;
+                    }
+                    item.setIcon(d);
+                }
+            });
+        }
+
+        item.setCheckable(info.checkable);
+        item.setChecked(info.checked);
+        item.setEnabled(info.enabled);
+        item.setVisible(info.visible);
+    }
+
+    private void addAddonMenuItem(final MenuItemInfo info) {
+        if (mAddonMenuItemsCache == null) {
+            mAddonMenuItemsCache = new Vector<MenuItemInfo>();
+        }
+
+        // Mark it as added if the menu was ready.
+        info.added = (mMenu != null);
+
+        // Always cache so we can rebuild after a locale switch.
+        mAddonMenuItemsCache.add(info);
+
+        if (mMenu == null) {
+            return;
+        }
+
+        addAddonMenuItemToMenu(mMenu, info);
+    }
+
+    private void removeAddonMenuItem(int id) {
+        // Remove add-on menu item from cache, if available.
+        if (mAddonMenuItemsCache != null && !mAddonMenuItemsCache.isEmpty()) {
+            for (MenuItemInfo item : mAddonMenuItemsCache) {
+                 if (item.id == id) {
+                     mAddonMenuItemsCache.remove(item);
+                     break;
+                 }
+            }
+        }
+
+        if (mMenu == null)
+            return;
+
+        MenuItem menuItem = mMenu.findItem(id);
+        if (menuItem != null)
+            mMenu.removeItem(id);
+    }
+
+    private void updateAddonMenuItem(int id, JSONObject options) {
+        // Set attribute for the menu item in cache, if available
+        if (mAddonMenuItemsCache != null && !mAddonMenuItemsCache.isEmpty()) {
+            for (MenuItemInfo item : mAddonMenuItemsCache) {
+                if (item.id == id) {
+                    item.label = options.optString("name", item.label);
+                    item.checkable = options.optBoolean("checkable", item.checkable);
+                    item.checked = options.optBoolean("checked", item.checked);
+                    item.enabled = options.optBoolean("enabled", item.enabled);
+                    item.visible = options.optBoolean("visible", item.visible);
+                    item.added = (mMenu != null);
+                    break;
+                }
+            }
+        }
+
+        if (mMenu == null) {
+            return;
+        }
+
+        MenuItem menuItem = mMenu.findItem(id);
+        if (menuItem != null) {
+            menuItem.setTitle(options.optString("name", menuItem.getTitle().toString()));
+            menuItem.setCheckable(options.optBoolean("checkable", menuItem.isCheckable()));
+            menuItem.setChecked(options.optBoolean("checked", menuItem.isChecked()));
+            menuItem.setEnabled(options.optBoolean("enabled", menuItem.isEnabled()));
+            menuItem.setVisible(options.optBoolean("visible", menuItem.isVisible()));
+        }
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        // Sets mMenu = menu.
+        super.onCreateOptionsMenu(menu);
+
+        // Inform the menu about the action-items bar. 
+        if (menu instanceof GeckoMenu &&
+            HardwareUtils.isTablet()) {
+            ((GeckoMenu) menu).setActionItemBarPresenter(mBrowserToolbar);
+        }
+
+        MenuInflater inflater = getMenuInflater();
+        inflater.inflate(R.menu.browser_app_menu, mMenu);
+
+        // Add add-on menu items, if any exist.
+        if (mAddonMenuItemsCache != null && !mAddonMenuItemsCache.isEmpty()) {
+            for (MenuItemInfo item : mAddonMenuItemsCache) {
+                addAddonMenuItemToMenu(mMenu, item);
+            }
+        }
+
+        // Action providers are available only ICS+.
+        if (Build.VERSION.SDK_INT >= 14) {
+            MenuItem share = mMenu.findItem(R.id.share);
+            GeckoActionProvider provider = new GeckoActionProvider(this);
+            share.setActionProvider(provider);
+        }
+
+        return true;
+    }
+
+    @Override
+    public void openOptionsMenu() {
+        if (!hasTabsSideBar() && areTabsShown())
+            return;
+
+        // Scroll custom menu to the top
+        if (mMenuPanel != null)
+            mMenuPanel.scrollTo(0, 0);
+
+        if (!mBrowserToolbar.openOptionsMenu())
+            super.openOptionsMenu();
+
+        if (mDynamicToolbar.isEnabled()) {
+            mDynamicToolbar.setVisible(true, VisibilityTransition.ANIMATE);
+        }
+    }
+
+    @Override
+    public void closeOptionsMenu() {
+        if (!mBrowserToolbar.closeOptionsMenu())
+            super.closeOptionsMenu();
+    }
+
+    @Override
+    public void setFullScreen(final boolean fullscreen) {
+        super.setFullScreen(fullscreen);
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                if (fullscreen) {
+                    mViewFlipper.setVisibility(View.GONE);
+                    if (mDynamicToolbar.isEnabled()) {
+                        mDynamicToolbar.setVisible(false, VisibilityTransition.IMMEDIATE);
+                        mLayerView.getLayerMarginsAnimator().setMaxMargins(0, 0, 0, 0);
+                    } else {
+                        setToolbarMargin(0);
+                    }
+                } else {
+                    mViewFlipper.setVisibility(View.VISIBLE);
+                    if (mDynamicToolbar.isEnabled()) {
+                        mDynamicToolbar.setVisible(true, VisibilityTransition.IMMEDIATE);
+                        mLayerView.getLayerMarginsAnimator().setMaxMargins(0, mToolbarHeight, 0, 0);
+                    }
+                }
+            }
+        });
+    }
+
+    @Override
+    public boolean onPrepareOptionsMenu(Menu aMenu) {
+        if (aMenu == null)
+            return false;
+
+        if (!GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoRunning))
+            aMenu.findItem(R.id.settings).setEnabled(false);
+
+        Tab tab = Tabs.getInstance().getSelectedTab();
+        MenuItem bookmark = aMenu.findItem(R.id.bookmark);
+        MenuItem back = aMenu.findItem(R.id.back);
+        MenuItem forward = aMenu.findItem(R.id.forward);
+        MenuItem share = aMenu.findItem(R.id.share);
+        MenuItem saveAsPDF = aMenu.findItem(R.id.save_as_pdf);
+        MenuItem charEncoding = aMenu.findItem(R.id.char_encoding);
+        MenuItem findInPage = aMenu.findItem(R.id.find_in_page);
+        MenuItem desktopMode = aMenu.findItem(R.id.desktop_mode);
+        MenuItem enterGuestMode = aMenu.findItem(R.id.new_guest_session);
+        MenuItem exitGuestMode = aMenu.findItem(R.id.exit_guest_session);
+        MenuItem subscribe = aMenu.findItem(R.id.save_subscribe);
+        MenuItem addToReadingList = aMenu.findItem(R.id.reading_list_add);
+        MenuItem save = aMenu.findItem(R.id.save);
+
+        // Only show the "Quit" menu item on pre-ICS or television devices.
+        // In ICS+, it's easy to kill an app through the task switcher.
+        aMenu.findItem(R.id.quit).setVisible(Build.VERSION.SDK_INT < 14 || HardwareUtils.isTelevision());
+
+        if (tab == null || tab.getURL() == null) {
+            bookmark.setEnabled(false);
+            back.setEnabled(false);
+            forward.setEnabled(false);
+            share.setEnabled(false);
+            saveAsPDF.setEnabled(false);
+            findInPage.setEnabled(false);
+
+            // NOTE: Use MenuUtils.safeSetEnabled because some actions might
+            // be on the BrowserToolbar context menu
+            MenuUtils.safeSetEnabled(aMenu, R.id.page, false);
+            MenuUtils.safeSetEnabled(aMenu, R.id.subscribe, false);
+            MenuUtils.safeSetEnabled(aMenu, R.id.add_search_engine, false);
+            MenuUtils.safeSetEnabled(aMenu, R.id.site_settings, false);
+            MenuUtils.safeSetEnabled(aMenu, R.id.add_to_launcher, false);
+
+            return true;
+        }
+
+        save.setVisible(!GeckoProfile.get(this).inGuestMode());
+        if (tab.isBookmark() || tab.isReadingListItem()) {
+            save.setIcon(R.drawable.ic_menu_bookmark_remove);
+        } else {
+            save.setIcon(R.drawable.ic_menu_bookmark_add);
+        }
+
+        bookmark.setEnabled(!AboutPages.isAboutReader(tab.getURL()));
+        bookmark.setChecked(tab.isBookmark());
+
+        back.setEnabled(tab.canDoBack());
+        forward.setEnabled(tab.canDoForward());
+        desktopMode.setChecked(tab.getDesktopMode());
+        desktopMode.setIcon(tab.getDesktopMode() ? R.drawable.ic_menu_desktop_mode_on : R.drawable.ic_menu_desktop_mode_off);
+
+        String url = tab.getURL();
+        if (AboutPages.isAboutReader(url)) {
+            String urlFromReader = ReaderModeUtils.getUrlFromAboutReader(url);
+            if (urlFromReader != null) {
+                url = urlFromReader;
+            }
+        }
+
+        // Disable share menuitem for about:, chrome:, file:, and resource: URIs
+        String scheme = Uri.parse(url).getScheme();
+        share.setVisible(!GeckoProfile.get(this).inGuestMode());
+        share.setEnabled(!(scheme.equals("about") || scheme.equals("chrome") ||
+                           scheme.equals("file") || scheme.equals("resource")));
+
+        // NOTE: Use MenuUtils.safeSetEnabled because some actions might
+        // be on the BrowserToolbar context menu
+        MenuUtils.safeSetEnabled(aMenu, R.id.page, !isAboutHome(tab));
+        MenuUtils.safeSetEnabled(aMenu, R.id.subscribe, tab.hasFeeds());
+        MenuUtils.safeSetEnabled(aMenu, R.id.add_search_engine, tab.hasOpenSearch());
+        MenuUtils.safeSetEnabled(aMenu, R.id.site_settings, !isAboutHome(tab));
+        MenuUtils.safeSetEnabled(aMenu, R.id.add_to_launcher, !isAboutHome(tab));
+
+        // Action providers are available only ICS+.
+        if (Build.VERSION.SDK_INT >= 14) {
+            GeckoActionProvider provider = (GeckoActionProvider) share.getActionProvider();
+            if (provider != null) {
+                Intent shareIntent = provider.getIntent();
+
+                // For efficiency, the provider's intent is only set once
+                if (shareIntent == null) {
+                    shareIntent = new Intent(Intent.ACTION_SEND);
+                    shareIntent.setType("text/plain");
+                    provider.setIntent(shareIntent);
+                }
+
+                // Replace the existing intent's extras
+                shareIntent.putExtra(Intent.EXTRA_TEXT, url);
+                shareIntent.putExtra(Intent.EXTRA_SUBJECT, tab.getDisplayTitle());
+                shareIntent.putExtra(Intent.EXTRA_TITLE, tab.getDisplayTitle());
+
+                // Clear the existing thumbnail extras so we don't share an old thumbnail.
+                shareIntent.removeExtra("share_screenshot_uri");
+
+                // Include the thumbnail of the page being shared.
+                BitmapDrawable drawable = tab.getThumbnail();
+                if (drawable != null) {
+                    Bitmap thumbnail = drawable.getBitmap();
+
+                    // Kobo uses a custom intent extra for sharing thumbnails.
+                    if (Build.MANUFACTURER.equals("Kobo") && thumbnail != null) {
+                        File cacheDir = getExternalCacheDir();
+
+                        if (cacheDir != null) {
+                            File outFile = new File(cacheDir, "thumbnail.png");
+
+                            try {
+                                java.io.FileOutputStream out = new java.io.FileOutputStream(outFile);
+                                thumbnail.compress(Bitmap.CompressFormat.PNG, 90, out);
+                            } catch (FileNotFoundException e) {
+                                Log.e(LOGTAG, "File not found", e);
+                            }
+
+                            shareIntent.putExtra("share_screenshot_uri", Uri.parse(outFile.getPath()));
+                        }
+                    }
+                }
+            }
+        }
+
+        // Disable save as PDF for about:home and xul pages.
+        saveAsPDF.setEnabled(!(isAboutHome(tab) ||
+                               tab.getContentType().equals("application/vnd.mozilla.xul+xml")));
+
+        // Disable find in page for about:home, since it won't work on Java content.
+        findInPage.setEnabled(!isAboutHome(tab));
+
+        charEncoding.setVisible(GeckoPreferences.getCharEncodingState());
+
+        if (mProfile.inGuestMode())
+            exitGuestMode.setVisible(true);
+        else
+            enterGuestMode.setVisible(true);
+
+        addToReadingList.setChecked(tab.isReadingListItem());
+        addToReadingList.setEnabled(tab.getReaderEnabled());
+
+        subscribe.setEnabled(tab.hasFeeds());
+
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        final Tab tab = Tabs.getInstance().getSelectedTab();
+        Intent intent = null;
+
+        final int itemId = item.getItemId();
+
+        if (itemId == R.id.bookmark) {
+            if (tab != null) {
+                if (item.isChecked()) {
+                    tab.removeBookmark();
+                    Toast.makeText(this, R.string.bookmark_removed, Toast.LENGTH_SHORT).show();
+                    item.setIcon(R.drawable.ic_menu_bookmark_add);
+                } else {
+                    tab.addBookmark();
+                    getButtonToast().show(false,
+                        getResources().getString(R.string.bookmark_added),
+                        getResources().getString(R.string.contextmenu_edit_bookmark),
+                        null,
+                        new ButtonToast.ToastListener() {
+                            @Override
+                            public void onButtonClicked() {
+                                new EditBookmarkDialog(BrowserApp.this).show(tab.getURL());
+                            }
+
+                            @Override
+                            public void onToastHidden(ButtonToast.ReasonHidden reason) { }
+                        });
+                    item.setIcon(R.drawable.ic_menu_bookmark_remove);
+                }
+            }
+            return true;
+        }
+
+        if (itemId == R.id.share) {
+            shareCurrentUrl();
+            return true;
+        }
+
+        if (itemId == R.id.reload) {
+            if (tab != null)
+                tab.doReload();
+            return true;
+        }
+
+        if (itemId == R.id.back) {
+            if (tab != null)
+                tab.doBack();
+            return true;
+        }
+
+        if (itemId == R.id.forward) {
+            if (tab != null)
+                tab.doForward();
+            return true;
+        }
+
+        if (itemId == R.id.save_as_pdf) {
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("SaveAs:PDF", null));
+            return true;
+        }
+
+        if (itemId == R.id.settings) {
+            intent = new Intent(this, GeckoPreferences.class);
+            startActivity(intent);
+            return true;
+        }
+
+        if (itemId == R.id.addons) {
+            Tabs.getInstance().loadUrlInTab(AboutPages.ADDONS);
+            return true;
+        }
+
+        if (itemId == R.id.apps) {
+            Tabs.getInstance().loadUrlInTab(AboutPages.APPS);
+            return true;
+        }
+
+        if (itemId == R.id.downloads) {
+            Tabs.getInstance().loadUrlInTab(AboutPages.DOWNLOADS);
+            return true;
+        }
+
+        if (itemId == R.id.char_encoding) {
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("CharEncoding:Get", null));
+            return true;
+        }
+
+        if (itemId == R.id.find_in_page) {
+            mFindInPageBar.show();
+            return true;
+        }
+
+        if (itemId == R.id.desktop_mode) {
+            if (tab == null)
+                return true;
+            JSONObject args = new JSONObject();
+            try {
+                args.put("desktopMode", !item.isChecked());
+                args.put("tabId", tab.getId());
+            } catch (JSONException e) {
+                Log.e(LOGTAG, "error building json arguments");
+            }
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("DesktopMode:Change", args.toString()));
+            return true;
+        }
+
+        if (itemId == R.id.new_tab) {
+            addTab();
+            return true;
+        }
+
+        if (itemId == R.id.new_private_tab) {
+            addPrivateTab();
+            return true;
+        }
+
+        if (itemId == R.id.new_guest_session) {
+            showGuestModeDialog(GuestModeDialog.ENTERING);
+            return true;
+        }
+
+        if (itemId == R.id.exit_guest_session) {
+            showGuestModeDialog(GuestModeDialog.LEAVING);
+            return true;
+        }
+
+        // We have a few menu items that can also be in the context menu. If
+        // we have not already handled the item, give the context menu handler
+        // a chance.
+        if (onContextItemSelected(item)) {
+            return true;
+        }
+
+        if (itemId == R.id.launcher_add) {
+            addToLauncher(tab.getURL(), tab.getTitle(), tab.getFaviconURL());
+            return true;
+        }
+
+        if (itemId == R.id.reading_list_add) {
+            if (item.isChecked()) {
+                ReaderModeUtils.removeFromReadingList(tab.getURL());
+            } else {
+                ReaderModeUtils.addToReadingList(tab);
+            }
+            return true;
+        }
+
+        if (itemId == R.id.subscribe || itemId == R.id.save_subscribe) {
+            subscribeToFeeds(tab);
+            return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+
+    private void showGuestModeDialog(final GuestModeDialog type) {
+        final Prompt ps = new Prompt(this, new Prompt.PromptCallback() {
+            @Override
+            public void onPromptFinished(String result) {
+                try {
+                    int itemId = new JSONObject(result).getInt("button");
+                    if (itemId == 0) {
+                        String args = "";
+                        if (type == GuestModeDialog.ENTERING) {
+                            args = GUEST_BROWSING_ARG;
+                        } else {
+                            GeckoProfile.leaveGuestSession(BrowserApp.this);
+                        }
+                        doRestart(args);
+                        GeckoAppShell.systemExit();
+                    }
+                } catch(JSONException ex) {
+                    Log.e(LOGTAG, "Exception reading guest mode prompt result", ex);
+                }
+            }
+        });
+
+        Resources res = getResources();
+        ps.setButtons(new String[] {
+            res.getString(R.string.guest_session_dialog_continue),
+            res.getString(R.string.guest_session_dialog_cancel)
+        });
+
+        int titleString = 0;
+        int msgString = 0;
+        if (type == GuestModeDialog.ENTERING) {
+            titleString = R.string.new_guest_session_title;
+            msgString = R.string.new_guest_session_text;
+        } else {
+            titleString = R.string.exit_guest_session_title;
+            msgString = R.string.exit_guest_session_text;
+        }
+
+        ps.show(res.getString(titleString), res.getString(msgString), null, ListView.CHOICE_MODE_NONE);
+    }
+
+    public void subscribeToFeeds(Tab tab) {
+        if (!tab.hasFeeds()) {
+            return;
+        }
+
+        JSONObject args = new JSONObject();
+        try {
+            args.put("tabId", tab.getId());
+        } catch (JSONException e) {
+            Log.e(LOGTAG, "JSON error", e);
+        }
+        GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Feeds:Subscribe", args.toString()));
+    }
+
+    private void addToLauncher(String url, String title, String faviconUrl) {
+        if (url == null || title == null) {
+            return;
+        }
+
+        final OnFaviconLoadedListener listener = new GeckoAppShell.CreateShortcutFaviconLoadedListener(url, title);
+        Favicons.getSizedFavicon(url,
+                faviconUrl,
+                Integer.MAX_VALUE,
+                LoadFaviconTask.FLAG_PERSIST,
+                listener);
+    }
+
+    /**
+     * This will detect if the key pressed is back. If so, will show the history.
+     */
+    @Override
+    public boolean onKeyLongPress(int keyCode, KeyEvent event) {
+        if (keyCode == KeyEvent.KEYCODE_BACK) {
+            Tab tab = Tabs.getInstance().getSelectedTab();
+            if (tab != null) {
+                return tab.showAllHistory();
+            }
+        }
+        return super.onKeyLongPress(keyCode, event);
+    }
+
+    /*
+     * If the app has been launched a certain number of times, and we haven't asked for feedback before,
+     * open a new tab with about:feedback when launching the app from the icon shortcut.
+     */ 
+    @Override
+    protected void onNewIntent(Intent intent) {
+        super.onNewIntent(intent);
+
+        String action = intent.getAction();
+
+        if (AppConstants.MOZ_ANDROID_BEAM && Build.VERSION.SDK_INT >= 10 && NfcAdapter.ACTION_NDEF_DISCOVERED.equals(action)) {
+            String uri = intent.getDataString();
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createURILoadEvent(uri));
+        }
+
+        if (!mInitialized) {
+            return;
+        }
+
+        // Dismiss editing mode if the user is loading a URL from an external app.
+        if (Intent.ACTION_VIEW.equals(action)) {
+            mBrowserToolbar.cancelEdit();
+            return;
+        }
+
+        // Only solicit feedback when the app has been launched from the icon shortcut.
+        if (!Intent.ACTION_MAIN.equals(action)) {
+            return;
+        }
+
+        (new UiAsyncTask<Void, Void, Boolean>(ThreadUtils.getBackgroundHandler()) {
+            @Override
+            public synchronized Boolean doInBackground(Void... params) {
+                // Check to see how many times the app has been launched.
+                SharedPreferences settings = getPreferences(Activity.MODE_PRIVATE);
+                String keyName = getPackageName() + ".feedback_launch_count";
+                int launchCount = settings.getInt(keyName, 0);
+                if (launchCount >= FEEDBACK_LAUNCH_COUNT)
+                    return false;
+
+                // Increment the launch count and store the new value.
+                launchCount++;
+                settings.edit().putInt(keyName, launchCount).commit();
+
+                // If we've reached our magic number, show the feedback page.
+                return launchCount == FEEDBACK_LAUNCH_COUNT;
+            }
+
+            @Override
+            public void onPostExecute(Boolean shouldShowFeedbackPage) {
+                if (shouldShowFeedbackPage)
+                    GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Feedback:Show", null));
+            }
+        }).execute();
+    }
+
+    @Override
+    protected NotificationClient makeNotificationClient() {
+        // The service is local to Fennec, so we can use it to keep
+        // Fennec alive during downloads.
+        return new ServiceNotificationClient(getApplicationContext());
+    }
+
+    private void resetFeedbackLaunchCount() {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public synchronized void run() {
+                SharedPreferences settings = getPreferences(Activity.MODE_PRIVATE);
+                settings.edit().putInt(getPackageName() + ".feedback_launch_count", 0).commit();
+            }
+        });
+    }
+
+    private void getLastUrl() {
+        (new UiAsyncTask<Void, Void, String>(ThreadUtils.getBackgroundHandler()) {
+            @Override
+            public synchronized String doInBackground(Void... params) {
+                // Get the most recent URL stored in browser history.
+                String url = "";
+                Cursor c = null;
+                try {
+                    c = BrowserDB.getRecentHistory(getContentResolver(), 1);
+                    if (c.moveToFirst()) {
+                        url = c.getString(c.getColumnIndexOrThrow(Combined.URL));
+                    }
+                } finally {
+                    if (c != null)
+                        c.close();
+                }
+                return url;
+            }
+
+            @Override
+            public void onPostExecute(String url) {
+                // Don't bother sending a message if there is no URL.
+                if (url.length() > 0)
+                    GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Feedback:LastUrl", url));
+            }
+        }).execute();
+    }
+
+    // HomePager.OnNewTabsListener
+    @Override
+    public void onNewTabs(String[] urls) {
+        final EnumSet<OnUrlOpenListener.Flags> flags = EnumSet.of(OnUrlOpenListener.Flags.ALLOW_SWITCH_TO_TAB);
+ 
+        for (String url : urls) {
+            if (!maybeSwitchToTab(url, flags)) {
+                openUrlAndStopEditing(url, true);
+            }
+        }
+    }
+
+    // HomePager.OnUrlOpenListener
+    @Override
+    public void onUrlOpen(String url, EnumSet<OnUrlOpenListener.Flags> flags) {
+        if (flags.contains(OnUrlOpenListener.Flags.OPEN_WITH_INTENT)) {
+            Intent intent = new Intent(Intent.ACTION_VIEW);
+            intent.setData(Uri.parse(url));
+            startActivity(intent);
+        } else if (!maybeSwitchToTab(url, flags)) {
+            openUrlAndStopEditing(url);
+        }
+    }
+
+    // BrowserSearch.OnSearchListener
+    @Override
+    public void onSearch(SearchEngine engine, String text) {
+        recordSearch(engine, "barsuggest");
+        openUrlAndStopEditing(text, engine.name);
+    }
+
+    // BrowserSearch.OnEditSuggestionListener
+    @Override
+    public void onEditSuggestion(String suggestion) {
+        mBrowserToolbar.onEditSuggestion(suggestion);
+    }
+
+    @Override
+    public int getLayout() { return R.layout.gecko_app; }
+
+    @Override
+    protected String getDefaultProfileName() throws NoMozillaDirectoryException {
+        return GeckoProfile.getDefaultProfileName(this);
+    }
+
+    /**
+     * Launch UI that lets the user update Firefox.
+     *
+     * This depends on the current channel: Release and Beta both direct to the
+     * Google Play Store.  If updating is enabled, Aurora, Nightly, and custom
+     * builds open about:, which provides an update interface.
+     *
+     * If updating is not enabled, this simply logs an error.
+     *
+     * @return true if update UI was launched.
+     */
+    protected boolean handleUpdaterLaunch() {
+        if (AppConstants.RELEASE_BUILD) {
+            Intent intent = new Intent(Intent.ACTION_VIEW);
+            intent.setData(Uri.parse("market://details?id=" + getPackageName()));
+            startActivity(intent);
+            return true;
+        }
+
+        if (AppConstants.MOZ_UPDATER) {
+            Tabs.getInstance().loadUrlInTab(AboutPages.UPDATER);
+            return true;
+        }
+
+        Log.w(LOGTAG, "No candidate updater found; ignoring launch request.");
+        return false;
+    }
+
+    /* Implementing ActionModeCompat.Presenter */
+    @Override
+    public void startActionModeCompat(final ActionModeCompat.Callback callback) {
+        // If actionMode is null, we're not currently showing one. Flip to the action mode view
+        if (mActionMode == null) {
+            mViewFlipper.showNext();
+            LayerMarginsAnimator margins = mLayerView.getLayerMarginsAnimator();
+
+            // If the toolbar is dynamic and not currently showing, just slide it in
+            if (mDynamicToolbar.isEnabled() && !margins.areMarginsShown()) {
+                margins.setMaxMargins(0, mViewFlipper.getHeight(), 0, 0);
+                mDynamicToolbar.setVisible(true, VisibilityTransition.ANIMATE);
+                mShowActionModeEndAnimation = true;
+            } else {
+                // Otherwise, we animate the actionbar itself
+                mActionBar.animateIn();
+            }
+
+            mDynamicToolbar.setPinned(true, PinReason.ACTION_MODE);
+        } else {
+            // Otherwise, we're already showing an action mode. Just finish it and show the new one
+            mActionMode.finish();
+        }
+
+        mActionMode = new ActionModeCompat(BrowserApp.this, callback, mActionBar);
+        if (callback.onCreateActionMode(mActionMode, mActionMode.getMenu())) {
+            mActionMode.invalidate();
+        }
+    }
+
+    /* Implementing ActionModeCompat.Presenter */
+    @Override
+    public void endActionModeCompat() {
+        if (mActionMode == null) {
+            return;
+        }
+
+        mActionMode.finish();
+        mActionMode = null;
+        mDynamicToolbar.setPinned(false, PinReason.ACTION_MODE);
+
+        mViewFlipper.showPrevious();
+
+        // Only slide the urlbar out if it was hidden when the action mode started
+        // Don't animate hiding it so that there's no flash as we switch back to url mode
+        if (mShowActionModeEndAnimation) {
+            mDynamicToolbar.setVisible(false, VisibilityTransition.IMMEDIATE);
+            mShowActionModeEndAnimation = false;
+        }
+    }
+
+    @Override
+    protected HealthRecorder createHealthRecorder(final Context context,
+                                                  final String profilePath,
+                                                  final EventDispatcher dispatcher,
+                                                  final String osLocale,
+                                                  final String appLocale,
+                                                  final SessionInformation previousSession) {
+        return new BrowserHealthRecorder(context,
+                                         profilePath,
+                                         dispatcher,
+                                         osLocale,
+                                         appLocale,
+                                         previousSession);
+    }
+}
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/FlashKidActivity.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/FlashKidActivity.java	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,15 @@
+import android.app.Activity;
+import android.os.Bundle;
+import org.mozilla.gecko.sync.setup.activities.ActivityUtils;
+
+/**
+ * Created by steve on 3/29/14.
+ */
+public class FlashKidActivity extends Activity {
+	@Override
+	protected void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		ActivityUtils.openURLInFennec(this.getContext(), "http://www-tc.pbskids.org/curiousgeorge/games/i_love_shapes/i_love_shapesV5.swf");
+		finish();
+	}
+}
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/GeckoActivity.java
--- a/mobile/android/base/GeckoActivity.java	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/GeckoActivity.java	Mon Mar 31 16:57:28 2014 +0700
@@ -7,6 +7,7 @@
 import android.content.ComponentName;
 import android.content.Intent;
 import android.support.v4.app.FragmentActivity;
+import android.util.Log;
 
 public class GeckoActivity extends FragmentActivity implements GeckoActivityStatus {
     // has this activity recently started another Gecko activity?
@@ -43,7 +44,9 @@
     @Override
     public void onCreate(android.os.Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        if (AppConstants.MOZ_ANDROID_ANR_REPORTER) {
+	    Log.d("Cuong", "Activity GeckoActivity");
+
+	    if (AppConstants.MOZ_ANDROID_ANR_REPORTER) {
             ANRReporter.register(getApplicationContext());
         }
     }
@@ -97,4 +100,5 @@
         MemoryMonitor.getInstance().onTrimMemory(level);
         super.onTrimMemory(level);
     }
+
 }
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/GeckoApp.java
--- a/mobile/android/base/GeckoApp.java	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/GeckoApp.java	Mon Mar 31 16:57:28 2014 +0700
@@ -32,6 +32,7 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.mozilla.gecko.GeckoProfileDirectories.NoMozillaDirectoryException;
+import org.mozilla.gecko.LocaleManager;
 import org.mozilla.gecko.background.announcements.AnnouncementsBroadcastService;
 import org.mozilla.gecko.db.BrowserDB;
 import org.mozilla.gecko.favicons.Favicons;
@@ -48,6 +49,7 @@
 import org.mozilla.gecko.mozglue.GeckoLoader;
 import org.mozilla.gecko.preferences.GeckoPreferences;
 import org.mozilla.gecko.prompts.PromptService;
+import org.mozilla.gecko.sync.setup.activities.ActivityUtils;
 import org.mozilla.gecko.updater.UpdateService;
 import org.mozilla.gecko.updater.UpdateServiceHelper;
 import org.mozilla.gecko.util.ActivityResultHandler;
@@ -322,33 +324,34 @@
 
     public void refreshChrome() { }
 
-    @Override
-    public void invalidateOptionsMenu() {
-        if (mMenu == null)
-            return;
-
-        onPrepareOptionsMenu(mMenu);
-
-        if (Build.VERSION.SDK_INT >= 11)
-            super.invalidateOptionsMenu();
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        mMenu = menu;
-
-        MenuInflater inflater = getMenuInflater();
-        inflater.inflate(R.menu.gecko_app_menu, mMenu);
-        return true;
-    }
-
-    @Override
-    public MenuInflater getMenuInflater() {
-        if (Build.VERSION.SDK_INT >= 11)
-            return new GeckoMenuInflater(this);
-        else
-            return super.getMenuInflater();
-    }
+//    @Override
+//    public void invalidateOptionsMenu() {
+//        if (mMenu == null)
+//            return;
+//
+//        onPrepareOptionsMenu(mMenu);
+//
+//        if (Build.VERSION.SDK_INT >= 11)
+//            super.invalidateOptionsMenu();
+//    }
+
+//    @Override
+//    public boolean onCreateOptionsMenu(Menu menu) {
+	    // We dont use menu in FlashKid
+//        mMenu = menu;
+//
+//        MenuInflater inflater = getMenuInflater();
+//        inflater.inflate(R.menu.gecko_app_menu, mMenu);
+//        return false;
+//    }
+
+//    @Override
+//    public MenuInflater getMenuInflater() {
+//        if (Build.VERSION.SDK_INT >= 11)
+//            return new GeckoMenuInflater(this);
+//        else
+//            return super.getMenuInflater();
+//    }
 
     public MenuPanel getMenuPanel() {
         if (mMenuPanel == null) {
@@ -401,24 +404,24 @@
         return super.onCreatePanelView(featureId);
     }
 
-    @Override
-    public boolean onCreatePanelMenu(int featureId, Menu menu) {
-        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
-            if (mMenuPanel == null) {
-                mMenuPanel = (MenuPanel) onCreatePanelView(featureId);
-            }
-
-            GeckoMenu gMenu = new GeckoMenu(this, null);
-            gMenu.setCallback(this);
-            gMenu.setMenuPresenter(this);
-            menu = gMenu;
-            mMenuPanel.addView(gMenu);
-
-            return onCreateOptionsMenu(menu);
-        }
-
-        return super.onCreatePanelMenu(featureId, menu);
-    }
+//    @Override
+//    public boolean onCreatePanelMenu(int featureId, Menu menu) {
+//        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+//            if (mMenuPanel == null) {
+//                mMenuPanel = (MenuPanel) onCreatePanelView(featureId);
+//            }
+//
+//            GeckoMenu gMenu = new GeckoMenu(this, null);
+//            gMenu.setCallback(this);
+//            gMenu.setMenuPresenter(this);
+//            menu = gMenu;
+//            mMenuPanel.addView(gMenu);
+//
+//            return onCreateOptionsMenu(menu);
+//        }
+//
+//        return super.onCreatePanelMenu(featureId, menu);
+//    }
 
     @Override
     public boolean onPreparePanel(int featureId, View view, Menu menu) {
@@ -430,26 +433,26 @@
 
     @Override
     public boolean onMenuOpened(int featureId, Menu menu) {
-        // exit full-screen mode whenever the menu is opened
-        if (mLayerView != null && mLayerView.isFullScreen()) {
-            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
-        }
-
-        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
-            if (mMenu == null) {
-                // getMenuPanel() will force the creation of the menu as well
-                MenuPanel panel = getMenuPanel();
-                onPreparePanel(featureId, panel, mMenu);
-            }
-
-            // Scroll custom menu to the top
-            if (mMenuPanel != null)
-                mMenuPanel.scrollTo(0, 0);
-
-            return true;
-        }
-
-        return super.onMenuOpened(featureId, menu);
+	    return super.onMenuOpened(featureId, menu);
+//        // exit full-screen mode whenever the menu is opened
+//        if (mLayerView != null && mLayerView.isFullScreen()) {
+//            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
+//        }
+//
+//        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+//            if (mMenu == null) {
+//                // getMenuPanel() will force the creation of the menu as well
+//                MenuPanel panel = getMenuPanel();
+//                onPreparePanel(featureId, panel, mMenu);
+//            }
+//
+//            // Scroll custom menu to the top
+//            if (mMenuPanel != null)
+//                mMenuPanel.scrollTo(0, 0);
+//
+//            return true;
+//        }
+
     }
 
     @Override
@@ -466,13 +469,14 @@
         return super.onOptionsItemSelected(item);
     }
 
-    @Override
-    public void onOptionsMenuClosed(Menu menu) {
-        if (Build.VERSION.SDK_INT >= 11) {
-            mMenuPanel.removeAllViews();
-            mMenuPanel.addView((GeckoMenu) mMenu);
-        }
-    }
+//    @Override
+//    public void onOptionsMenuClosed(Menu menu) {
+	    //Nothing to do in FlashKid
+//        if (Build.VERSION.SDK_INT >= 11) {
+//            mMenuPanel.removeAllViews();
+//            mMenuPanel.addView((GeckoMenu) mMenu);
+//        }
+//    }
  
     @Override
     public boolean onKeyDown(int keyCode, KeyEvent event) {
@@ -971,7 +975,7 @@
 
         mFullScreenPluginView = null;
 
-        GeckoScreenOrientation.getInstance().unlock();
+//        GeckoScreenOrientation.getInstance().unlock();
         setFullScreen(false);
     }
 
@@ -1166,6 +1170,7 @@
     @Override
     public void onCreate(Bundle savedInstanceState)
     {
+
         GeckoAppShell.registerGlobalExceptionHandler();
 
         // Enable Android Strict Mode for developers' local builds (the "default" channel).
@@ -1295,9 +1300,11 @@
 
         super.onCreate(savedInstanceState);
 
-        GeckoScreenOrientation.getInstance().update(getResources().getConfiguration().orientation);
-
-        setContentView(getLayout());
+//        GeckoScreenOrientation.getInstance().update(getResources().getConfiguration().orientation);
+//	    GeckoScreenOrientation.getInstance().lock(org.mozilla.gecko.GeckoScreenOrientation.ScreenOrientation.LANDSCAPE_PRIMARY);
+
+
+	    setContentView(getLayout());
 
         // Set up Gecko layout.
         mGeckoLayout = (RelativeLayout) findViewById(R.id.gecko_layout);
@@ -1305,6 +1312,8 @@
 
         // Determine whether we should restore tabs.
         mShouldRestore = getSessionRestoreState(savedInstanceState);
+	    //We dont want to restore in FlashKid
+//	    mShouldRestore = false;
         if (mShouldRestore && savedInstanceState != null) {
             boolean wasInBackground =
                 savedInstanceState.getBoolean(SAVED_STATE_IN_BACKGROUND, false);
@@ -1318,13 +1327,13 @@
             mPrivateBrowsingSession = savedInstanceState.getString(SAVED_STATE_PRIVATE_SESSION);
         }
 
-        // Perform background initialization.
+//        // Perform background initialization.
         ThreadUtils.postToBackgroundThread(new Runnable() {
             @Override
             public void run() {
                 final SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
 
-                // Wait until now to set this, because we'd rather throw an exception than 
+                // Wait until now to set this, because we'd rather throw an exception than
                 // have a caller of LocaleManager regress startup.
                 LocaleManager.setContextGetter(GeckoApp.this);
                 LocaleManager.initialize();
@@ -1377,6 +1386,7 @@
 
         GeckoAppShell.setNotificationClient(makeNotificationClient());
         NotificationHelper.init(getApplicationContext());
+
     }
 
     /**
@@ -1437,10 +1447,12 @@
      * @param url External URL to load, or null to load the default URL
      */
     protected void loadStartupTab(String url) {
+	    Log.d("Cuong","Load startup tab "+url);
         if (url == null) {
             if (!mShouldRestore) {
                 // Show about:home if we aren't restoring previous session and
                 // there's no external URL.
+	              //We dont show about:home in FlashKid, simply exit it
                 Tabs.getInstance().loadUrl(AboutPages.HOME, Tabs.LOADURL_NEW_TAB);
             }
         } else {
@@ -1506,8 +1518,9 @@
 
             GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Session:Restore", restoreMessage));
         }
-
-        // External URLs should always be loaded regardless of whether Gecko is
+	    Log.d("Cuong","isExternalURL "+isExternalURL);
+
+	    // External URLs should always be loaded regardless of whether Gecko is
         // already running.
         if (isExternalURL) {
             loadStartupTab(passedUri);
@@ -1611,11 +1624,12 @@
                                            GeckoAppShell.getEventDispatcher(),
                                            this);
 
-        PrefsHelper.getPref("app.update.autodownload", new PrefsHelper.PrefHandlerBase() {
-            @Override public void prefValue(String pref, String value) {
-                UpdateServiceHelper.registerForUpdates(GeckoApp.this, value);
-            }
-        });
+	    //Dont support auto download in FlashKid
+//        PrefsHelper.getPref("app.update.autodownload", new PrefsHelper.PrefHandlerBase() {
+//            @Override public void prefValue(String pref, String value) {
+//                UpdateServiceHelper.registerForUpdates(GeckoApp.this, value);
+//            }
+//        });
 
         PrefsHelper.getPref("app.geo.reportdata", new PrefsHelper.PrefHandlerBase() {
             @Override public void prefValue(String pref, int value) {
@@ -1894,6 +1908,7 @@
 
     @Override
     protected void onNewIntent(Intent intent) {
+	    Log.d("Cuong","OnNewIntent ");
         if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoExiting)) {
             // We're exiting and shouldn't try to do anything else. In the case
             // where we are hung while exiting, we should force the process to exit.
@@ -1909,8 +1924,9 @@
         }
 
         final String action = intent.getAction();
-
-        if (ACTION_LOAD.equals(action)) {
+	    Log.d("Cuong","OnNewIntent "+action);
+
+	    if (ACTION_LOAD.equals(action)) {
             String uri = intent.getDataString();
             Tabs.getInstance().loadUrl(uri);
         } else if (Intent.ACTION_VIEW.equals(action)) {
@@ -1938,6 +1954,13 @@
             // Copy extras.
             settingsIntent.putExtras(intent);
             startActivity(settingsIntent);
+        } else if ("com.zoodles.action.VIEW_FLASH".equals(action)) {
+	        Log.d("Cuong","OnNewIntent VIEW_FLASH");
+
+	        String uri = "http://www-tc.pbskids.org/curiousgeorge/games/i_love_shapes/i_love_shapesV5.swf";
+	        Tabs.getInstance().loadUrl(uri,Tabs.LOADURL_NEW_TAB |
+			        Tabs.LOADURL_USER_ENTERED |Tabs.LOADURL_EXTERNAL);
+	        setFullScreen(true);
         }
     }
 
@@ -1974,10 +1997,11 @@
         // Undo whatever we did in onPause.
         super.onResume();
 
-        int newOrientation = getResources().getConfiguration().orientation;
-        if (GeckoScreenOrientation.getInstance().update(newOrientation)) {
-            refreshChrome();
-        }
+//	    //Dont change orientation
+//        int newOrientation = getResources().getConfiguration().orientation;
+//        if (GeckoScreenOrientation.getInstance().update(newOrientation)) {
+//            refreshChrome();
+//        }
 
         // User may have enabled/disabled accessibility.
         GeckoAccessibility.updateAccessibilitySettings(this);
@@ -2168,6 +2192,7 @@
         super.onDestroy();
 
         Tabs.unregisterOnTabsChangedListener(this);
+	    LocaleManager.destroy();
     }
 
     protected void registerEventListener(String event) {
@@ -2202,14 +2227,15 @@
         Log.d(LOGTAG, "onConfigurationChanged: " + newConfig.locale);
         LocaleManager.correctLocale(getResources(), newConfig);
 
+//	    We dont change orientation in FlashKid
         // onConfigurationChanged is not called for 180 degree orientation changes,
         // we will miss such rotations and the screen orientation will not be
         // updated.
-        if (GeckoScreenOrientation.getInstance().update(newConfig.orientation)) {
-            if (mFormAssistPopup != null)
-                mFormAssistPopup.hide();
-            refreshChrome();
-        }
+//        if (GeckoScreenOrientation.getInstance().update(newConfig.orientation)) {
+//            if (mFormAssistPopup != null)
+//                mFormAssistPopup.hide();
+//            refreshChrome();
+//        }
         super.onConfigurationChanged(newConfig);
     }
 
@@ -2333,56 +2359,59 @@
 
     @Override
     public void onBackPressed() {
-        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
-            super.onBackPressed();
-            return;
-        }
-
-        if (autoHideTabs()) {
-            return;
-        }
-
-        if (mDoorHangerPopup != null && mDoorHangerPopup.isShowing()) {
-            mDoorHangerPopup.dismiss();
-            return;
-        }
-
-        if (mFullScreenPluginView != null) {
-            GeckoAppShell.onFullScreenPluginHidden(mFullScreenPluginView);
-            removeFullScreenPluginView(mFullScreenPluginView);
-            return;
-        }
-
-        if (mLayerView != null && mLayerView.isFullScreen()) {
-            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
-            return;
-        }
-
-        Tabs tabs = Tabs.getInstance();
-        Tab tab = tabs.getSelectedTab();
-        if (tab == null) {
-            moveTaskToBack(true);
-            return;
-        }
-
-        if (tab.doBack())
-            return;
-
-        if (tab.isExternal()) {
-            moveTaskToBack(true);
-            tabs.closeTab(tab);
-            return;
-        }
-
-        int parentId = tab.getParentId();
-        Tab parent = tabs.getTab(parentId);
-        if (parent != null) {
-            // The back button should always return to the parent (not a sibling).
-            tabs.closeTab(tab, parent);
-            return;
-        }
-
-        moveTaskToBack(true);
+	    Log.d("Cuong", "Number Of Tabs " + Tabs.getInstance().getDisplayCount());
+	    GeckoAppShell.systemExit();
+
+//        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
+//            super.onBackPressed();
+//            return;
+//        }
+//
+//        if (autoHideTabs()) {
+//            return;
+//        }
+//
+//        if (mDoorHangerPopup != null && mDoorHangerPopup.isShowing()) {
+//            mDoorHangerPopup.dismiss();
+//            return;
+//        }
+//
+//        if (mFullScreenPluginView != null) {
+//            GeckoAppShell.onFullScreenPluginHidden(mFullScreenPluginView);
+//            removeFullScreenPluginView(mFullScreenPluginView);
+//            return;
+//        }
+//
+//        if (mLayerView != null && mLayerView.isFullScreen()) {
+//            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
+//            return;
+//        }
+//
+//        Tabs tabs = Tabs.getInstance();
+//        Tab tab = tabs.getSelectedTab();
+//        if (tab == null) {
+//            moveTaskToBack(true);
+//            return;
+//        }
+//
+//        if (tab.doBack())
+//            return;
+//
+//        if (tab.isExternal()) {
+//            moveTaskToBack(true);
+//            tabs.closeTab(tab);
+//            return;
+//        }
+//
+//        int parentId = tab.getParentId();
+//        Tab parent = tabs.getTab(parentId);
+//        if (parent != null) {
+//            // The back button should always return to the parent (not a sibling).
+//            tabs.closeTab(tab, parent);
+//            return;
+//        }
+//
+//        moveTaskToBack(true);
     }
 
     @Override
@@ -2793,10 +2822,10 @@
     // locale change.
     private static final String SESSION_END_LOCALE_CHANGED = "L";
 
-    /**
-     * Use LocaleManager to change our persisted and current locales,
-     * and poke HealthRecorder to tell it of our changed state.
-     */
+//    /**
+//     * Use LocaleManager to change our persisted and current locales,
+//     * and poke HealthRecorder to tell it of our changed state.
+//     */
     private void setLocale(final String locale) {
         if (locale == null) {
             return;
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/GeckoApp.java.orig
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/GeckoApp.java.orig	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,2876 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.gecko;
+
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.mozilla.gecko.GeckoProfileDirectories.NoMozillaDirectoryException;
+import org.mozilla.gecko.background.announcements.AnnouncementsBroadcastService;
+import org.mozilla.gecko.db.BrowserDB;
+import org.mozilla.gecko.favicons.Favicons;
+import org.mozilla.gecko.gfx.BitmapUtils;
+import org.mozilla.gecko.gfx.Layer;
+import org.mozilla.gecko.gfx.LayerView;
+import org.mozilla.gecko.gfx.PluginLayer;
+import org.mozilla.gecko.health.HealthRecorder;
+import org.mozilla.gecko.health.SessionInformation;
+import org.mozilla.gecko.health.StubbedHealthRecorder;
+import org.mozilla.gecko.menu.GeckoMenu;
+import org.mozilla.gecko.menu.GeckoMenuInflater;
+import org.mozilla.gecko.menu.MenuPanel;
+import org.mozilla.gecko.mozglue.GeckoLoader;
+import org.mozilla.gecko.preferences.GeckoPreferences;
+import org.mozilla.gecko.prompts.PromptService;
+import org.mozilla.gecko.updater.UpdateService;
+import org.mozilla.gecko.updater.UpdateServiceHelper;
+import org.mozilla.gecko.util.ActivityResultHandler;
+import org.mozilla.gecko.util.FileUtils;
+import org.mozilla.gecko.util.GeckoEventListener;
+import org.mozilla.gecko.util.HardwareUtils;
+import org.mozilla.gecko.util.ThreadUtils;
+import org.mozilla.gecko.util.UiAsyncTask;
+import org.mozilla.gecko.webapp.EventListener;
+import org.mozilla.gecko.webapp.UninstallListener;
+import org.mozilla.gecko.widget.ButtonToast;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.location.Location;
+import android.location.LocationListener;
+import android.net.Uri;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiManager;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.PowerManager;
+import android.os.StrictMode;
+import android.preference.PreferenceManager;
+import android.provider.ContactsContract;
+import android.provider.MediaStore.Images.Media;
+import android.telephony.CellLocation;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneStateListener;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.telephony.gsm.GsmCellLocation;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.Base64;
+import android.util.Log;
+import android.util.SparseBooleanArray;
+import android.view.Gravity;
+import android.view.KeyEvent;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.OrientationEventListener;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.TextureView;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.AbsoluteLayout;
+import android.widget.FrameLayout;
+import android.widget.ListView;
+import android.widget.RelativeLayout;
+import android.widget.SimpleAdapter;
+import android.widget.TextView;
+import android.widget.Toast;
+
+public abstract class GeckoApp
+    extends GeckoActivity
+    implements
+    ContextGetter,
+    GeckoAppShell.GeckoInterface,
+    GeckoEventListener,
+    GeckoMenu.Callback,
+    GeckoMenu.MenuPresenter,
+    LocationListener,
+    SensorEventListener,
+    Tabs.OnTabsChangedListener
+{
+    private static final String LOGTAG = "GeckoApp";
+    private static final int ONE_DAY_MS = 1000*60*60*24;
+
+    private static enum StartupAction {
+        NORMAL,     /* normal application start */
+        URL,        /* launched with a passed URL */
+        PREFETCH    /* launched with a passed URL that we prefetch */
+    }
+
+    public static final String ACTION_ALERT_CALLBACK       = "org.mozilla.gecko.ACTION_ALERT_CALLBACK";
+    public static final String ACTION_BOOKMARK             = "org.mozilla.gecko.BOOKMARK";
+    public static final String ACTION_DEBUG                = "org.mozilla.gecko.DEBUG";
+    public static final String ACTION_LAUNCH_SETTINGS      = "org.mozilla.gecko.SETTINGS";
+    public static final String ACTION_LOAD                 = "org.mozilla.gecko.LOAD";
+    public static final String ACTION_INIT_PW              = "org.mozilla.gecko.INIT_PW";
+    public static final String ACTION_WEBAPP_PREFIX        = "org.mozilla.gecko.WEBAPP";
+
+    public static final String EXTRA_STATE_BUNDLE          = "stateBundle";
+
+    public static final String PREFS_ALLOW_STATE_BUNDLE    = "allowStateBundle";
+    public static final String PREFS_CRASHED               = "crashed";
+    public static final String PREFS_NAME                  = "GeckoApp";
+    public static final String PREFS_OOM_EXCEPTION         = "OOMException";
+    public static final String PREFS_VERSION_CODE          = "versionCode";
+    public static final String PREFS_WAS_STOPPED           = "wasStopped";
+    public static final String PREFS_CLEANUP_TEMP_FILES    = "cleanupTempFiles";
+
+    public static final String SAVED_STATE_IN_BACKGROUND   = "inBackground";
+    public static final String SAVED_STATE_PRIVATE_SESSION = "privateSession";
+
+    static private final String LOCATION_URL = "https://location.services.mozilla.com/v1/submit";
+
+    // Delay before running one-time "cleanup" tasks that may be needed
+    // after a version upgrade.
+    private static final int CLEANUP_DEFERRAL_SECONDS = 15;
+
+    protected RelativeLayout mMainLayout;
+    protected RelativeLayout mGeckoLayout;
+    public View getView() { return mGeckoLayout; }
+    private View mCameraView;
+    private OrientationEventListener mCameraOrientationEventListener;
+    public List<GeckoAppShell.AppStateListener> mAppStateListeners;
+    private static GeckoApp sAppContext;
+    protected MenuPanel mMenuPanel;
+    protected Menu mMenu;
+    protected GeckoProfile mProfile;
+    protected boolean mIsRestoringActivity;
+
+    private ContactService mContactService;
+    private PromptService mPromptService;
+    private TextSelection mTextSelection;
+
+    protected DoorHangerPopup mDoorHangerPopup;
+    protected FormAssistPopup mFormAssistPopup;
+    protected ButtonToast mToast;
+
+    protected LayerView mLayerView;
+    private AbsoluteLayout mPluginContainer;
+
+    private FullScreenHolder mFullScreenPluginContainer;
+    private View mFullScreenPluginView;
+
+    private HashMap<String, PowerManager.WakeLock> mWakeLocks = new HashMap<String, PowerManager.WakeLock>();
+
+    protected boolean mShouldRestore;
+    protected boolean mInitialized = false;
+    private Telemetry.Timer mJavaUiStartupTimer;
+    private Telemetry.Timer mGeckoReadyStartupTimer;
+
+    private String mPrivateBrowsingSession;
+
+    private volatile HealthRecorder mHealthRecorder = null;
+
+    private int mSignalStrenth;
+    private PhoneStateListener mPhoneStateListener = null;
+    private boolean mShouldReportGeoData;
+
+    abstract public int getLayout();
+    abstract public boolean hasTabsSideBar();
+    abstract protected String getDefaultProfileName() throws NoMozillaDirectoryException;
+
+    private static final String RESTARTER_ACTION = "org.mozilla.gecko.restart";
+    private static final String RESTARTER_CLASS = "org.mozilla.gecko.Restarter";
+
+    @SuppressWarnings("serial")
+    class SessionRestoreException extends Exception {
+        public SessionRestoreException(Exception e) {
+            super(e);
+        }
+
+        public SessionRestoreException(String message) {
+            super(message);
+        }
+    }
+
+    void toggleChrome(final boolean aShow) { }
+
+    void focusChrome() { }
+
+    @Override
+    public Context getContext() {
+        return sAppContext;
+    }
+
+    @Override
+    public SharedPreferences getSharedPreferences() {
+        return GeckoApp.getAppSharedPreferences();
+    }
+
+    public static SharedPreferences getAppSharedPreferences() {
+        return GeckoApp.sAppContext.getSharedPreferences(GeckoApp.PREFS_NAME, 0);
+    }
+
+    public Activity getActivity() {
+        return this;
+    }
+
+    public LocationListener getLocationListener() {
+        if (mShouldReportGeoData && mPhoneStateListener == null) {
+            mPhoneStateListener = new PhoneStateListener() {
+                public void onSignalStrengthsChanged(SignalStrength signalStrength) {
+                    setCurrentSignalStrenth(signalStrength);
+                }
+            };
+            TelephonyManager tm = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
+            tm.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SIGNAL_STRENGTHS);
+        }
+        return this;
+    }
+
+    public SensorEventListener getSensorEventListener() {
+        return this;
+    }
+
+    public View getCameraView() {
+        return mCameraView;
+    }
+
+    public void addAppStateListener(GeckoAppShell.AppStateListener listener) {
+        mAppStateListeners.add(listener);
+    }
+
+    public void removeAppStateListener(GeckoAppShell.AppStateListener listener) {
+        mAppStateListeners.remove(listener);
+    }
+
+    public FormAssistPopup getFormAssistPopup() {
+        return mFormAssistPopup;
+    }
+
+    @Override
+    public void onTabChanged(Tab tab, Tabs.TabEvents msg, Object data) {
+        // When a tab is closed, it is always unselected first.
+        // When a tab is unselected, another tab is always selected first.
+        switch(msg) {
+            case UNSELECTED:
+                hidePlugins(tab);
+                break;
+
+            case LOCATION_CHANGE:
+                // We only care about location change for the selected tab.
+                if (!Tabs.getInstance().isSelectedTab(tab))
+                    break;
+                // Fall through...
+            case SELECTED:
+                invalidateOptionsMenu();
+                if (mFormAssistPopup != null)
+                    mFormAssistPopup.hide();
+                break;
+
+            case LOADED:
+                // Sync up the layer view and the tab if the tab is
+                // currently displayed.
+                LayerView layerView = mLayerView;
+                if (layerView != null && Tabs.getInstance().isSelectedTab(tab))
+                    layerView.setBackgroundColor(tab.getBackgroundColor());
+                break;
+
+            case DESKTOP_MODE_CHANGE:
+                if (Tabs.getInstance().isSelectedTab(tab))
+                    invalidateOptionsMenu();
+                break;
+        }
+    }
+
+    public void refreshChrome() { }
+
+    @Override
+    public void invalidateOptionsMenu() {
+        if (mMenu == null)
+            return;
+
+        onPrepareOptionsMenu(mMenu);
+
+        if (Build.VERSION.SDK_INT >= 11)
+            super.invalidateOptionsMenu();
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        mMenu = menu;
+
+        MenuInflater inflater = getMenuInflater();
+        inflater.inflate(R.menu.gecko_app_menu, mMenu);
+        return true;
+    }
+
+    @Override
+    public MenuInflater getMenuInflater() {
+        if (Build.VERSION.SDK_INT >= 11)
+            return new GeckoMenuInflater(this);
+        else
+            return super.getMenuInflater();
+    }
+
+    public MenuPanel getMenuPanel() {
+        if (mMenuPanel == null) {
+            onCreatePanelMenu(Window.FEATURE_OPTIONS_PANEL, null);
+            invalidateOptionsMenu();
+        }
+        return mMenuPanel;
+    }
+
+    @Override
+    public boolean onMenuItemSelected(MenuItem item) {
+        return onOptionsItemSelected(item);
+    }
+
+    @Override
+    public void openMenu() {
+        openOptionsMenu();
+    }
+
+    @Override
+    public void showMenu(View menu) {
+        // Hide the menu before we reshow it to avoid platform specific bugs like
+        // bug 794581 and bug 968182.
+        closeMenu();
+
+        mMenuPanel.removeAllViews();
+        mMenuPanel.addView(menu);
+
+        openOptionsMenu();
+    }
+
+    @Override
+    public void closeMenu() {
+        closeOptionsMenu();
+    }
+
+    @Override
+    public View onCreatePanelView(int featureId) {
+        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+            if (mMenuPanel == null) {
+                mMenuPanel = new MenuPanel(this, null);
+            } else {
+                // Prepare the panel everytime before showing the menu.
+                onPreparePanel(featureId, mMenuPanel, mMenu);
+            }
+
+            return mMenuPanel;
+        }
+
+        return super.onCreatePanelView(featureId);
+    }
+
+    @Override
+    public boolean onCreatePanelMenu(int featureId, Menu menu) {
+        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+            if (mMenuPanel == null) {
+                mMenuPanel = (MenuPanel) onCreatePanelView(featureId);
+            }
+
+            GeckoMenu gMenu = new GeckoMenu(this, null);
+            gMenu.setCallback(this);
+            gMenu.setMenuPresenter(this);
+            menu = gMenu;
+            mMenuPanel.addView(gMenu);
+
+            return onCreateOptionsMenu(menu);
+        }
+
+        return super.onCreatePanelMenu(featureId, menu);
+    }
+
+    @Override
+    public boolean onPreparePanel(int featureId, View view, Menu menu) {
+        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL)
+            return onPrepareOptionsMenu(menu);
+
+        return super.onPreparePanel(featureId, view, menu);
+    }
+
+    @Override
+    public boolean onMenuOpened(int featureId, Menu menu) {
+        // exit full-screen mode whenever the menu is opened
+        if (mLayerView != null && mLayerView.isFullScreen()) {
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
+        }
+
+        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+            if (mMenu == null) {
+                // getMenuPanel() will force the creation of the menu as well
+                MenuPanel panel = getMenuPanel();
+                onPreparePanel(featureId, panel, mMenu);
+            }
+
+            // Scroll custom menu to the top
+            if (mMenuPanel != null)
+                mMenuPanel.scrollTo(0, 0);
+
+            return true;
+        }
+
+        return super.onMenuOpened(featureId, menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.getItemId() == R.id.quit) {
+            if (GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.GeckoRunning, GeckoThread.LaunchState.GeckoExiting)) {
+                GeckoAppShell.notifyGeckoOfEvent(GeckoEvent.createBroadcastEvent("Browser:Quit", null));
+            } else {
+                GeckoAppShell.systemExit();
+            }
+            return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public void onOptionsMenuClosed(Menu menu) {
+        if (Build.VERSION.SDK_INT >= 11) {
+            mMenuPanel.removeAllViews();
+            mMenuPanel.addView((GeckoMenu) mMenu);
+        }
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        // Handle hardware menu key presses separately so that we can show a custom menu in some cases.
+        if (keyCode == KeyEvent.KEYCODE_MENU) {
+            openOptionsMenu();
+            return true;
+        }
+
+        return super.onKeyDown(keyCode, event);
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        if (mToast != null) {
+            mToast.onSaveInstanceState(outState);
+        }
+
+        outState.putBoolean(SAVED_STATE_IN_BACKGROUND, isApplicationInBackground());
+        outState.putString(SAVED_STATE_PRIVATE_SESSION, mPrivateBrowsingSession);
+    }
+
+    void handleFaviconRequest(final String url) {
+        (new UiAsyncTask<Void, Void, String>(ThreadUtils.getBackgroundHandler()) {
+            @Override
+            public String doInBackground(Void... params) {
+                return Favicons.getFaviconURLForPageURL(url);
+            }
+
+            @Override
+            public void onPostExecute(String faviconUrl) {
+                JSONObject args = new JSONObject();
+
+                if (faviconUrl != null) {
+                    try {
+                        args.put("url", url);
+                        args.put("faviconUrl", faviconUrl);
+                    } catch (JSONException e) {
+                        Log.w(LOGTAG, "Error building JSON favicon arguments.", e);
+                    }
+                }
+
+                GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Reader:FaviconReturn", args.toString()));
+            }
+        }).execute();
+    }
+
+    void handleClearHistory() {
+        BrowserDB.clearHistory(getContentResolver());
+    }
+
+    public void addTab() { }
+
+    public void addPrivateTab() { }
+
+    public void showNormalTabs() { }
+
+    public void showPrivateTabs() { }
+
+    public void showRemoteTabs() { }
+
+    private void showTabs(TabsPanel.Panel panel) { }
+
+    public void hideTabs() { }
+
+    /**
+     * Close the tab UI indirectly (not as the result of a direct user
+     * action).  This does not force the UI to close; for example in Firefox
+     * tablet mode it will remain open unless the user explicitly closes it.
+     *
+     * @return True if the tab UI was hidden.
+     */
+    public boolean autoHideTabs() { return false; }
+
+    public boolean areTabsShown() { return false; }
+
+    @Override
+    public void handleMessage(String event, JSONObject message) {
+        try {
+            if (event.equals("Toast:Show")) {
+                final String msg = message.getString("message");
+                final JSONObject button = message.optJSONObject("button");
+                if (button != null) {
+                    final String label = button.optString("label");
+                    final String icon = button.optString("icon");
+                    final String id = button.optString("id");
+                    showButtonToast(msg, label, icon, id);
+                } else {
+                    final String duration = message.getString("duration");
+                    showNormalToast(msg, duration);
+                }
+            } else if (event.equals("log")) {
+                // generic log listener
+                final String msg = message.getString("msg");
+                Log.d(LOGTAG, "Log: " + msg);
+            } else if (event.equals("Reader:FaviconRequest")) {
+                final String url = message.getString("url");
+                handleFaviconRequest(url);
+            } else if (event.equals("Gecko:DelayedStartup")) {
+                ThreadUtils.postToBackgroundThread(new UninstallListener.DelayedStartupTask(this));
+            } else if (event.equals("Gecko:Ready")) {
+                mGeckoReadyStartupTimer.stop();
+                geckoConnected();
+
+                // This method is already running on the background thread, so we
+                // know that mHealthRecorder will exist. That doesn't stop us being
+                // paranoid.
+                // This method is cheap, so don't spawn a new runnable.
+                final HealthRecorder rec = mHealthRecorder;
+                if (rec != null) {
+                  rec.recordGeckoStartupTime(mGeckoReadyStartupTimer.getElapsed());
+                }
+            } else if (event.equals("ToggleChrome:Hide")) {
+                toggleChrome(false);
+            } else if (event.equals("ToggleChrome:Show")) {
+                toggleChrome(true);
+            } else if (event.equals("ToggleChrome:Focus")) {
+                focusChrome();
+            } else if (event.equals("DOMFullScreen:Start")) {
+                // Local ref to layerView for thread safety
+                LayerView layerView = mLayerView;
+                if (layerView != null) {
+                    layerView.setFullScreen(true);
+                }
+            } else if (event.equals("DOMFullScreen:Stop")) {
+                // Local ref to layerView for thread safety
+                LayerView layerView = mLayerView;
+                if (layerView != null) {
+                    layerView.setFullScreen(false);
+                }
+            } else if (event.equals("Permissions:Data")) {
+                String host = message.getString("host");
+                JSONArray permissions = message.getJSONArray("permissions");
+                showSiteSettingsDialog(host, permissions);
+            } else if (event.equals("Session:StatePurged")) {
+                onStatePurged();
+            } else if (event.equals("Bookmark:Insert")) {
+                final String url = message.getString("url");
+                final String title = message.getString("title");
+                final Context context = this;
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        Toast.makeText(context, R.string.bookmark_added, Toast.LENGTH_SHORT).show();
+                        ThreadUtils.postToBackgroundThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                BrowserDB.addBookmark(getContentResolver(), title, url);
+                            }
+                        });
+                    }
+                });
+            } else if (event.equals("Accessibility:Event")) {
+                GeckoAccessibility.sendAccessibilityEvent(message);
+            } else if (event.equals("Accessibility:Ready")) {
+                GeckoAccessibility.updateAccessibilitySettings(this);
+            } else if (event.equals("Shortcut:Remove")) {
+                final String url = message.getString("url");
+                final String origin = message.getString("origin");
+                final String title = message.getString("title");
+                final String type = message.getString("shortcutType");
+                GeckoAppShell.removeShortcut(title, url, origin, type);
+            } else if (event.equals("Share:Text")) {
+                String text = message.getString("text");
+                GeckoAppShell.openUriExternal(text, "text/plain", "", "", Intent.ACTION_SEND, "");
+            } else if (event.equals("Share:Image")) {
+                String src = message.getString("url");
+                String type = message.getString("mime");
+                GeckoAppShell.shareImage(src, type);
+            } else if (event.equals("Image:SetAs")) {
+                String src = message.getString("url");
+                setImageAs(src);
+            } else if (event.equals("Sanitize:ClearHistory")) {
+                handleClearHistory();
+            } else if (event.equals("Update:Check")) {
+                startService(new Intent(UpdateServiceHelper.ACTION_CHECK_FOR_UPDATE, null, this, UpdateService.class));
+            } else if (event.equals("Update:Download")) {
+                startService(new Intent(UpdateServiceHelper.ACTION_DOWNLOAD_UPDATE, null, this, UpdateService.class));
+            } else if (event.equals("Update:Install")) {
+                startService(new Intent(UpdateServiceHelper.ACTION_APPLY_UPDATE, null, this, UpdateService.class));
+            } else if (event.equals("PrivateBrowsing:Data")) {
+                // null strings return "null" (http://code.google.com/p/android/issues/detail?id=13830)
+                if (message.isNull("session")) {
+                    mPrivateBrowsingSession = null;
+                } else {
+                    mPrivateBrowsingSession = message.getString("session");
+                }
+            } else if (event.equals("Contact:Add")) {
+                if (!message.isNull("email")) {
+                    Uri contactUri = Uri.parse(message.getString("email"));
+                    Intent i = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT, contactUri);
+                    startActivity(i);
+                } else if (!message.isNull("phone")) {
+                    Uri contactUri = Uri.parse(message.getString("phone"));
+                    Intent i = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT, contactUri);
+                    startActivity(i);
+                } else {
+                    // something went wrong.
+                    Log.e(LOGTAG, "Received Contact:Add message with no email nor phone number");
+                }
+            } else if (event.equals("Intent:GetHandlers")) {
+                Intent intent = GeckoAppShell.getOpenURIIntent(sAppContext, message.optString("url"),
+                    message.optString("mime"), message.optString("action"), message.optString("title"));
+                String[] handlers = GeckoAppShell.getHandlersForIntent(intent);
+                List<String> appList = Arrays.asList(handlers);
+                JSONObject handlersJSON = new JSONObject();
+                handlersJSON.put("apps", new JSONArray(appList));
+                EventDispatcher.sendResponse(message, handlersJSON);
+            } else if (event.equals("Intent:Open")) {
+                GeckoAppShell.openUriExternal(message.optString("url"),
+                    message.optString("mime"), message.optString("packageName"),
+                    message.optString("className"), message.optString("action"), message.optString("title"));
+            } else if (event.equals("Intent:OpenForResult")) {
+                Intent intent = GeckoAppShell.getOpenURIIntent(this,
+                                                               message.optString("url"),
+                                                               message.optString("mime"),
+                                                               message.optString("action"),
+                                                               message.optString("title"));
+                intent.setClassName(message.optString("packageName"), message.optString("className"));
+
+                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+
+                final JSONObject originalMessage = message;
+                ActivityHandlerHelper.startIntentForActivity(this,
+                                                             intent,
+                        new ActivityResultHandler() {
+                            @Override
+                            public void onActivityResult (int resultCode, Intent data) {
+                                JSONObject response = new JSONObject();
+
+                                try {
+                                    if (data != null) {
+                                        response.put("extras", bundleToJSON(data.getExtras()));
+                                    }
+                                    response.put("resultCode", resultCode);
+                                } catch (JSONException e) {
+                                    Log.w(LOGTAG, "Error building JSON response.", e);
+                                }
+
+                                EventDispatcher.sendResponse(originalMessage, response);
+                            }
+                        });
+            } else if (event.equals("Locale:Set")) {
+                setLocale(message.getString("locale"));
+            } else if (event.equals("NativeApp:IsDebuggable")) {
+                JSONObject ret = new JSONObject();
+                ret.put("isDebuggable", getIsDebuggable() ? "true" : "false");
+                EventDispatcher.sendResponse(message, ret);
+            } else if (event.equals("SystemUI:Visibility")) {
+                setSystemUiVisible(message.getBoolean("visible"));
+            }
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Exception handling message \"" + event + "\":", e);
+        }
+    }
+
+    void onStatePurged() { }
+
+    /**
+     * @param aPermissions
+     *        Array of JSON objects to represent site permissions.
+     *        Example: { type: "offline-app", setting: "Store Offline Data", value: "Allow" }
+     */
+    private void showSiteSettingsDialog(String aHost, JSONArray aPermissions) {
+        final AlertDialog.Builder builder = new AlertDialog.Builder(this);
+
+        View customTitleView = getLayoutInflater().inflate(R.layout.site_setting_title, null);
+        ((TextView) customTitleView.findViewById(R.id.title)).setText(R.string.site_settings_title);
+        ((TextView) customTitleView.findViewById(R.id.host)).setText(aHost);
+        builder.setCustomTitle(customTitleView);
+
+        // If there are no permissions to clear, show the user a message about that.
+        // In the future, we want to disable the menu item if there are no permissions to clear.
+        if (aPermissions.length() == 0) {
+            builder.setMessage(R.string.site_settings_no_settings);
+        } else {
+
+            ArrayList <HashMap<String, String>> itemList = new ArrayList <HashMap<String, String>>();
+            for (int i = 0; i < aPermissions.length(); i++) {
+                try {
+                    JSONObject permObj = aPermissions.getJSONObject(i);
+                    HashMap<String, String> map = new HashMap<String, String>();
+                    map.put("setting", permObj.getString("setting"));
+                    map.put("value", permObj.getString("value"));
+                    itemList.add(map);
+                } catch (JSONException e) {
+                    Log.w(LOGTAG, "Exception populating settings items.", e);
+                }
+            }
+
+            // setMultiChoiceItems doesn't support using an adapter, so we're creating a hack with
+            // setSingleChoiceItems and changing the choiceMode below when we create the dialog
+            builder.setSingleChoiceItems(new SimpleAdapter(
+                GeckoApp.this,
+                itemList,
+                R.layout.site_setting_item,
+                new String[] { "setting", "value" },
+                new int[] { R.id.setting, R.id.value }
+                ), -1, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int id) { }
+                });
+
+            builder.setPositiveButton(R.string.site_settings_clear, new DialogInterface.OnClickListener() {
+                @Override
+                public void onClick(DialogInterface dialog, int id) {
+                    ListView listView = ((AlertDialog) dialog).getListView();
+                    SparseBooleanArray checkedItemPositions = listView.getCheckedItemPositions();
+
+                    // An array of the indices of the permissions we want to clear
+                    JSONArray permissionsToClear = new JSONArray();
+                    for (int i = 0; i < checkedItemPositions.size(); i++)
+                        if (checkedItemPositions.get(i))
+                            permissionsToClear.put(i);
+
+                    GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent(
+                        "Permissions:Clear", permissionsToClear.toString()));
+                }
+            });
+        }
+
+        builder.setNegativeButton(R.string.site_settings_cancel, new DialogInterface.OnClickListener(){
+            @Override
+            public void onClick(DialogInterface dialog, int id) {
+                dialog.cancel();
+            }
+        });
+
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Dialog dialog = builder.create();
+                dialog.show();
+
+                ListView listView = ((AlertDialog) dialog).getListView();
+                if (listView != null) {
+                    listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
+                    int listSize = listView.getAdapter().getCount();
+                    for (int i = 0; i < listSize; i++)
+                        listView.setItemChecked(i, true);
+                }
+            }
+        });
+    }
+
+    public void showToast(final int resId, final int duration) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Toast.makeText(GeckoApp.this, resId, duration).show();
+            }
+        });
+    }
+
+    public void showNormalToast(final String message, final String duration) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Toast toast;
+                if (duration.equals("long")) {
+                    toast = Toast.makeText(GeckoApp.this, message, Toast.LENGTH_LONG);
+                } else {
+                    toast = Toast.makeText(GeckoApp.this, message, Toast.LENGTH_SHORT);
+                }
+                toast.show();
+            }
+        });
+    }
+
+    protected ButtonToast getButtonToast() {
+        if (mToast != null) {
+            return mToast;
+        }
+
+        ViewStub toastStub = (ViewStub) findViewById(R.id.toast_stub);
+        mToast = new ButtonToast(toastStub.inflate());
+
+        return mToast;
+    }
+
+    void showButtonToast(final String message, final String buttonText,
+                         final String buttonIcon, final String buttonId) {
+        BitmapUtils.getDrawable(GeckoApp.this, buttonIcon, new BitmapUtils.BitmapLoader() {
+            @Override
+            public void onBitmapFound(final Drawable d) {
+                getButtonToast().show(false, message, buttonText, d, new ButtonToast.ToastListener() {
+                    @Override
+                    public void onButtonClicked() {
+                        GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Toast:Click", buttonId));
+                    }
+
+                    @Override
+                    public void onToastHidden(ButtonToast.ReasonHidden reason) {
+                        if (reason == ButtonToast.ReasonHidden.TIMEOUT) {
+                            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Toast:Hidden", buttonId));
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    private JSONObject bundleToJSON(Bundle bundle) {
+        JSONObject json = new JSONObject();
+        if (bundle == null) {
+            return json;
+        }
+
+        for (String key : bundle.keySet()) {
+            try {
+                json.put(key, bundle.get(key));
+            } catch (JSONException e) {
+                Log.w(LOGTAG, "Error building JSON response.", e);
+            }
+        }
+
+        return json;
+    }
+
+    private void addFullScreenPluginView(View view) {
+        if (mFullScreenPluginView != null) {
+            Log.w(LOGTAG, "Already have a fullscreen plugin view");
+            return;
+        }
+
+        setFullScreen(true);
+
+        view.setWillNotDraw(false);
+        if (view instanceof SurfaceView) {
+            ((SurfaceView) view).setZOrderOnTop(true);
+        }
+
+        mFullScreenPluginContainer = new FullScreenHolder(this);
+
+        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(
+                            ViewGroup.LayoutParams.FILL_PARENT,
+                            ViewGroup.LayoutParams.FILL_PARENT,
+                            Gravity.CENTER);
+        mFullScreenPluginContainer.addView(view, layoutParams);
+
+
+        FrameLayout decor = (FrameLayout)getWindow().getDecorView();
+        decor.addView(mFullScreenPluginContainer, layoutParams);
+
+        mFullScreenPluginView = view;
+    }
+
+    public void addPluginView(final View view, final RectF rect, final boolean isFullScreen) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Tabs tabs = Tabs.getInstance();
+                Tab tab = tabs.getSelectedTab();
+
+                if (isFullScreen) {
+                    addFullScreenPluginView(view);
+                    return;
+                }
+
+                PluginLayer layer = (PluginLayer) tab.getPluginLayer(view);
+                if (layer == null) {
+                    layer = new PluginLayer(view, rect, mLayerView.getRenderer().getMaxTextureSize());
+                    tab.addPluginLayer(view, layer);
+                } else {
+                    layer.reset(rect);
+                    layer.setVisible(true);
+                }
+
+                mLayerView.addLayer(layer);
+            }
+        });
+    }
+
+    private void removeFullScreenPluginView(View view) {
+        if (mFullScreenPluginView == null) {
+            Log.w(LOGTAG, "Don't have a fullscreen plugin view");
+            return;
+        }
+
+        if (mFullScreenPluginView != view) {
+            Log.w(LOGTAG, "Passed view is not the current full screen view");
+            return;
+        }
+
+        mFullScreenPluginContainer.removeView(mFullScreenPluginView);
+
+        // We need do do this on the next iteration in order to avoid
+        // a deadlock, see comment below in FullScreenHolder
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                mLayerView.showSurface();
+            }
+        });
+
+        FrameLayout decor = (FrameLayout)getWindow().getDecorView();
+        decor.removeView(mFullScreenPluginContainer);
+
+        mFullScreenPluginView = null;
+
+        GeckoScreenOrientation.getInstance().unlock();
+        setFullScreen(false);
+    }
+
+    public void removePluginView(final View view, final boolean isFullScreen) {
+        ThreadUtils.postToUiThread(new Runnable() {
+	        @Override
+	        public void run() {
+		        Tabs tabs = Tabs.getInstance();
+		        Tab tab = tabs.getSelectedTab();
+
+		        if (isFullScreen) {
+			        removeFullScreenPluginView(view);
+			        return;
+		        }
+
+		        PluginLayer layer = (PluginLayer) tab.removePluginLayer(view);
+		        if (layer != null) {
+			        layer.destroy();
+		        }
+	        }
+        });
+    }
+
+    // This method starts downloading an image synchronously and displays the Chooser activity to set the image as wallpaper.
+    private void setImageAs(final String aSrc) {
+        boolean isDataURI = aSrc.startsWith("data:");
+        Bitmap image = null;
+        InputStream is = null;
+        ByteArrayOutputStream os = null;
+        try {
+            if (isDataURI) {
+                int dataStart = aSrc.indexOf(",");
+                byte[] buf = Base64.decode(aSrc.substring(dataStart+1), Base64.DEFAULT);
+                image = BitmapUtils.decodeByteArray(buf);
+            } else {
+                int byteRead;
+                byte[] buf = new byte[4192];
+                os = new ByteArrayOutputStream();
+                URL url = new URL(aSrc);
+                is = url.openStream();
+
+                // Cannot read from same stream twice. Also, InputStream from
+                // URL does not support reset. So converting to byte array.
+
+                while((byteRead = is.read(buf)) != -1) {
+                    os.write(buf, 0, byteRead);
+                }
+                byte[] imgBuffer = os.toByteArray();
+                image = BitmapUtils.decodeByteArray(imgBuffer);
+            }
+            if (image != null) {
+                String path = Media.insertImage(getContentResolver(),image, null, null);
+                final Intent intent = new Intent(Intent.ACTION_ATTACH_DATA);
+                intent.addCategory(Intent.CATEGORY_DEFAULT);
+                intent.setData(Uri.parse(path));
+
+                // Removes the image from storage once the chooser activity ends.
+                ActivityHandlerHelper.startIntentForActivity(this,
+                                                            Intent.createChooser(intent, sAppContext.getString(R.string.set_image_chooser_title)),
+                                                            new ActivityResultHandler() {
+                                                                @Override
+                                                                public void onActivityResult (int resultCode, Intent data) {
+                                                                    getContentResolver().delete(intent.getData(), null, null);
+                                                                }
+                                                            });
+            } else {
+                Toast.makeText(sAppContext, R.string.set_image_fail, Toast.LENGTH_SHORT).show();
+            }
+        } catch(OutOfMemoryError ome) {
+            Log.e(LOGTAG, "Out of Memory when converting to byte array", ome);
+        } catch(IOException ioe) {
+            Log.e(LOGTAG, "I/O Exception while setting wallpaper", ioe);
+        } finally {
+            if (is != null) {
+                try {
+                    is.close();
+                } catch(IOException ioe) {
+                    Log.w(LOGTAG, "I/O Exception while closing stream", ioe);
+                }
+            }
+            if (os != null) {
+                try {
+                    os.close();
+                } catch(IOException ioe) {
+                    Log.w(LOGTAG, "I/O Exception while closing stream", ioe);
+                }
+            }
+        }
+    }
+
+    private int getBitmapSampleSize(BitmapFactory.Options options, int idealWidth, int idealHeight) {
+        int width = options.outWidth;
+        int height = options.outHeight;
+        int inSampleSize = 1;
+        if (height > idealHeight || width > idealWidth) {
+            if (width > height) {
+                inSampleSize = Math.round((float)height / (float)idealHeight);
+            } else {
+                inSampleSize = Math.round((float)width / (float)idealWidth);
+            }
+        }
+        return inSampleSize;
+    }
+
+    private void hidePluginLayer(Layer layer) {
+        LayerView layerView = mLayerView;
+        layerView.removeLayer(layer);
+        layerView.requestRender();
+    }
+
+    private void showPluginLayer(Layer layer) {
+        LayerView layerView = mLayerView;
+        layerView.addLayer(layer);
+        layerView.requestRender();
+    }
+
+    public void requestRender() {
+        mLayerView.requestRender();
+    }
+
+    public void hidePlugins(Tab tab) {
+        for (Layer layer : tab.getPluginLayers()) {
+            if (layer instanceof PluginLayer) {
+                ((PluginLayer) layer).setVisible(false);
+            }
+
+            hidePluginLayer(layer);
+        }
+
+        requestRender();
+    }
+
+    public void showPlugins() {
+        Tabs tabs = Tabs.getInstance();
+        Tab tab = tabs.getSelectedTab();
+
+        showPlugins(tab);
+    }
+
+    public void showPlugins(Tab tab) {
+        for (Layer layer : tab.getPluginLayers()) {
+            showPluginLayer(layer);
+
+            if (layer instanceof PluginLayer) {
+                ((PluginLayer) layer).setVisible(true);
+            }
+        }
+
+        requestRender();
+    }
+
+    public void setFullScreen(final boolean fullscreen) {
+        ThreadUtils.postToUiThread(new Runnable() {
+	        @Override
+	        public void run() {
+		        // Hide/show the system notification bar
+		        Window window = getWindow();
+		        window.setFlags(fullscreen ?
+				        WindowManager.LayoutParams.FLAG_FULLSCREEN : 0,
+				        WindowManager.LayoutParams.FLAG_FULLSCREEN);
+
+		        if (Build.VERSION.SDK_INT >= 11)
+			        window.getDecorView().setSystemUiVisibility(fullscreen ? 1 : 0);
+	        }
+        });
+    }
+
+    /**
+     * Check and start the Java profiler if MOZ_PROFILER_STARTUP env var is specified
+     **/
+    protected void earlyStartJavaSampler(Intent intent)
+    {
+        String env = intent.getStringExtra("env0");
+        for (int i = 1; env != null; i++) {
+            if (env.startsWith("MOZ_PROFILER_STARTUP=")) {
+                if (!env.endsWith("=")) {
+                    GeckoJavaSampler.start(10, 1000);
+                    Log.d(LOGTAG, "Profiling Java on startup");
+                }
+                break;
+            }
+            env = intent.getStringExtra("env" + i);
+        }
+    }
+
+    /**
+     * Called when the activity is first created.
+     *
+     * Here we initialize all of our profile settings, Firefox Health Report,
+     * and other one-shot constructions.
+     **/
+    @Override
+    public void onCreate(Bundle savedInstanceState)
+    {
+        GeckoAppShell.registerGlobalExceptionHandler();
+        Log.w(LOGTAG, "Cuong on created");
+        // Enable Android Strict Mode for developers' local builds (the "default" channel).
+        if ("default".equals(AppConstants.MOZ_UPDATE_CHANNEL)) {
+            enableStrictMode();
+        }
+
+        // The clock starts...now. Better hurry!
+        mJavaUiStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_JAVAUI");
+        mGeckoReadyStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_GECKOREADY");
+
+        Intent intent = getIntent();
+        String args = intent.getStringExtra("args");
+        earlyStartJavaSampler(intent);
+
+        if (mProfile == null) {
+            String profileName = null;
+            String profilePath = null;
+            if (args != null) {
+                if (args.contains("-P")) {
+                    Pattern p = Pattern.compile("(?:-P\\s*)(\\w*)(\\s*)");
+                    Matcher m = p.matcher(args);
+                    if (m.find()) {
+                        profileName = m.group(1);
+                    }
+                }
+
+                if (args.contains("-profile")) {
+                    Pattern p = Pattern.compile("(?:-profile\\s*)(\\S*)(\\s*)");
+                    Matcher m = p.matcher(args);
+                    if (m.find()) {
+                        profilePath =  m.group(1);
+                    }
+                    if (profileName == null) {
+                        try {
+                            profileName = getDefaultProfileName();
+                        } catch (NoMozillaDirectoryException e) {
+                            Log.wtf(LOGTAG, "Unable to fetch default profile name!", e);
+                            // There's nothing at all we can do now. If the Mozilla directory
+                            // didn't exist, then we're screwed.
+                            // Crash here so we can fix the bug.
+                            throw new RuntimeException(e);
+                        }
+                        if (profileName == null)
+                            profileName = GeckoProfile.DEFAULT_PROFILE;
+                    }
+                    GeckoProfile.sIsUsingCustomProfile = true;
+                }
+
+                if (profileName != null || profilePath != null) {
+                    mProfile = GeckoProfile.get(this, profileName, profilePath);
+                }
+            }
+        }
+
+        BrowserDB.initialize(getProfile().getName());
+
+        // Workaround for <http://code.google.com/p/android/issues/detail?id=20915>.
+        try {
+            Class.forName("android.os.AsyncTask");
+        } catch (ClassNotFoundException e) {}
+
+        MemoryMonitor.getInstance().init(getApplicationContext());
+
+        sAppContext = this;
+        GeckoAppShell.setContextGetter(this);
+        GeckoAppShell.setGeckoInterface(this);
+        ThreadUtils.setUiThread(Thread.currentThread(), new Handler());
+
+        Tabs.getInstance().attachToContext(this);
+        try {
+            Favicons.attachToContext(this);
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Exception starting favicon cache. Corrupt resources?", e);
+        }
+
+        // Did the OS locale change while we were backgrounded? If so,
+        // we need to die so that Gecko will re-init add-ons that touch
+        // the UI.
+        // This is using a sledgehammer to crack a nut, but it'll do for
+        // now.
+        if (LocaleManager.systemLocaleDidChange()) {
+            Log.i(LOGTAG, "System locale changed. Restarting.");
+            doRestart();
+            GeckoAppShell.systemExit();
+            return;
+        }
+
+        if (GeckoThread.isCreated()) {
+            // This happens when the GeckoApp activity is destroyed by Android
+            // without killing the entire application (see Bug 769269).
+            mIsRestoringActivity = true;
+            Telemetry.HistogramAdd("FENNEC_RESTORING_ACTIVITY", 1);
+        }
+
+        // Fix for Bug 830557 on Tegra boards running Froyo.
+        // This fix must be done before doing layout.
+        // Assume the bug is fixed in Gingerbread and up.
+        if (Build.VERSION.SDK_INT < 9) {
+            try {
+                Class<?> inputBindResultClass =
+                    Class.forName("com.android.internal.view.InputBindResult");
+                java.lang.reflect.Field creatorField =
+                    inputBindResultClass.getField("CREATOR");
+                Log.i(LOGTAG, "froyo startup fix: " + String.valueOf(creatorField.get(null)));
+            } catch (Exception e) {
+                Log.w(LOGTAG, "froyo startup fix failed", e);
+            }
+        }
+
+        Bundle stateBundle = getIntent().getBundleExtra(EXTRA_STATE_BUNDLE);
+        if (stateBundle != null) {
+            // Use the state bundle if it was given as an intent extra. This is
+            // only intended to be used internally via Robocop, so a boolean
+            // is read from a private shared pref to prevent other apps from
+            // injecting states.
+            SharedPreferences prefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
+            if (prefs.getBoolean(PREFS_ALLOW_STATE_BUNDLE, false)) {
+                Log.i(LOGTAG, "Restoring state from intent bundle");
+                prefs.edit().remove(PREFS_ALLOW_STATE_BUNDLE).commit();
+                savedInstanceState = stateBundle;
+            }
+        } else if (savedInstanceState != null) {
+            // Bug 896992 - This intent has already been handled; reset the intent.
+            setIntent(new Intent(Intent.ACTION_MAIN));
+        }
+
+        super.onCreate(savedInstanceState);
+
+        GeckoScreenOrientation.getInstance().update(getResources().getConfiguration().orientation);
+
+        setContentView(getLayout());
+
+        // Set up Gecko layout.
+        mGeckoLayout = (RelativeLayout) findViewById(R.id.gecko_layout);
+        mMainLayout = (RelativeLayout) findViewById(R.id.main_layout);
+
+        // Determine whether we should restore tabs.
+        mShouldRestore = getSessionRestoreState(savedInstanceState);
+        if (mShouldRestore && savedInstanceState != null) {
+            boolean wasInBackground =
+                savedInstanceState.getBoolean(SAVED_STATE_IN_BACKGROUND, false);
+
+            // Don't log OOM-kills if only one activity was destroyed. (For example
+            // from "Don't keep activities" on ICS)
+            if (!wasInBackground && !mIsRestoringActivity) {
+                Telemetry.HistogramAdd("FENNEC_WAS_KILLED", 1);
+            }
+
+            mPrivateBrowsingSession = savedInstanceState.getString(SAVED_STATE_PRIVATE_SESSION);
+        }
+
+        // Perform background initialization.
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                final SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+
+                // Wait until now to set this, because we'd rather throw an exception than 
+                // have a caller of LocaleManager regress startup.
+                LocaleManager.setContextGetter(GeckoApp.this);
+                LocaleManager.initialize();
+
+                SessionInformation previousSession = SessionInformation.fromSharedPrefs(prefs);
+                if (previousSession.wasKilled()) {
+                    Telemetry.HistogramAdd("FENNEC_WAS_KILLED", 1);
+                }
+
+                SharedPreferences.Editor editor = prefs.edit();
+                editor.putBoolean(GeckoApp.PREFS_OOM_EXCEPTION, false);
+
+                // Put a flag to check if we got a normal `onSaveInstanceState`
+                // on exit, or if we were suddenly killed (crash or native OOM).
+                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
+
+                editor.commit();
+
+                // The lifecycle of mHealthRecorder is "shortly after onCreate"
+                // through "onDestroy" -- essentially the same as the lifecycle
+                // of the activity itself.
+                final String profilePath = getProfile().getDir().getAbsolutePath();
+                final EventDispatcher dispatcher = GeckoAppShell.getEventDispatcher();
+                Log.i(LOGTAG, "Creating HealthRecorder.");
+
+                final String osLocale = Locale.getDefault().toString();
+                String appLocale = LocaleManager.getAndApplyPersistedLocale();
+                Log.d(LOGTAG, "OS locale is " + osLocale + ", app locale is " + appLocale);
+
+                if (appLocale == null) {
+                    appLocale = osLocale;
+                }
+
+                mHealthRecorder = GeckoApp.this.createHealthRecorder(GeckoApp.this,
+                                                                     profilePath,
+                                                                     dispatcher,
+                                                                     osLocale,
+                                                                     appLocale,
+                                                                     previousSession);
+
+                final String uiLocale = appLocale;
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        GeckoApp.this.onLocaleReady(uiLocale);
+                    }
+                });
+            }
+        });
+
+        GeckoAppShell.setNotificationClient(makeNotificationClient());
+        NotificationHelper.init(getApplicationContext());
+    }
+
+    /**
+     * At this point, the resource system and the rest of the browser are
+     * aware of the locale.
+     *
+     * Now we can display strings!
+     */
+    @Override
+    public void onLocaleReady(final String locale) {
+        if (!ThreadUtils.isOnUiThread()) {
+            throw new RuntimeException("onLocaleReady must always be called from the UI thread.");
+        }
+
+        // The URL bar hint needs to be populated.
+        TextView urlBar = (TextView) findViewById(R.id.url_bar_title);
+        if (urlBar == null) {
+            return;
+        }
+        final String hint = getResources().getString(R.string.url_bar_default_text);
+        urlBar.setHint(hint);
+
+        // Allow onConfigurationChanged to take care of the rest.
+        onConfigurationChanged(getResources().getConfiguration());
+    }
+
+    protected void initializeChrome() {
+        mDoorHangerPopup = new DoorHangerPopup(this);
+        mPluginContainer = (AbsoluteLayout) findViewById(R.id.plugin_container);
+	    Log.w(LOGTAG, "Cuong mPluginContainer");
+
+	    mFormAssistPopup = (FormAssistPopup) findViewById(R.id.form_assist_popup);
+
+        if (mCameraView == null) {
+            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+                mCameraView = new SurfaceView(this);
+                ((SurfaceView)mCameraView).getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+            } else {
+                mCameraView = new TextureView(this);
+            }
+        }
+
+        if (mLayerView == null) {
+            LayerView layerView = (LayerView) findViewById(R.id.layer_view);
+            layerView.initializeView(GeckoAppShell.getEventDispatcher());
+            mLayerView = layerView;
+            GeckoAppShell.setLayerView(layerView);
+            // bind the GeckoEditable instance to the new LayerView
+            GeckoAppShell.notifyIMEContext(GeckoEditableListener.IME_STATE_DISABLED, "", "", "");
+        }
+    }
+
+    /**
+     * Loads the initial tab at Fennec startup.
+     *
+     * If Fennec was opened with an external URL, that URL will be loaded.
+     * Otherwise, unless there was a session restore, the default URL
+     * (about:home) be loaded.
+     *
+     * @param url External URL to load, or null to load the default URL
+     */
+    protected void loadStartupTab(String url) {
+        if (url == null) {
+            if (!mShouldRestore) {
+                // Show about:home if we aren't restoring previous session and
+                // there's no external URL.
+                Tabs.getInstance().loadUrl(AboutPages.HOME, Tabs.LOADURL_NEW_TAB);
+            }
+        } else {
+            // If given an external URL, load it
+            int flags = Tabs.LOADURL_NEW_TAB | Tabs.LOADURL_USER_ENTERED | Tabs.LOADURL_EXTERNAL;
+            Tabs.getInstance().loadUrl(url, flags);
+        }
+    }
+
+    private void initialize() {
+        mInitialized = true;
+
+        Intent intent = getIntent();
+        String action = intent.getAction();
+
+        String passedUri = null;
+        final String uri = getURIFromIntent(intent);
+        if (!TextUtils.isEmpty(uri)) {
+            passedUri = uri;
+        }
+
+        final boolean isExternalURL = passedUri != null &&
+                                      !AboutPages.isAboutHome(passedUri);
+        StartupAction startupAction;
+        if (isExternalURL) {
+            startupAction = StartupAction.URL;
+        } else {
+            startupAction = StartupAction.NORMAL;
+        }
+
+        // Start migrating as early as possible, can do this in
+        // parallel with Gecko load.
+        checkMigrateProfile();
+
+        Uri data = intent.getData();
+        if (data != null && "http".equals(data.getScheme())) {
+            startupAction = StartupAction.PREFETCH;
+            ThreadUtils.postToBackgroundThread(new PrefetchRunnable(data.toString()));
+        }
+
+        Tabs.registerOnTabsChangedListener(this);
+
+        initializeChrome();
+
+        // If we are doing a restore, read the session data and send it to Gecko
+        if (!mIsRestoringActivity) {
+            String restoreMessage = null;
+            if (mShouldRestore) {
+                try {
+                    // restoreSessionTabs() will create simple tab stubs with the
+                    // URL and title for each page, but we also need to restore
+                    // session history. restoreSessionTabs() will inject the IDs
+                    // of the tab stubs into the JSON data (which holds the session
+                    // history). This JSON data is then sent to Gecko so session
+                    // history can be restored for each tab.
+                    restoreMessage = restoreSessionTabs(isExternalURL);
+                } catch (SessionRestoreException e) {
+                    // If restore failed, do a normal startup
+                    Log.e(LOGTAG, "An error occurred during restore", e);
+                    mShouldRestore = false;
+                }
+            }
+
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Session:Restore", restoreMessage));
+        }
+
+        // External URLs should always be loaded regardless of whether Gecko is
+        // already running.
+        if (isExternalURL) {
+            loadStartupTab(passedUri);
+        } else if (!mIsRestoringActivity) {
+            loadStartupTab(null);
+        }
+
+        // We now have tab stubs from the last session. Any future tabs should
+        // be animated.
+        Tabs.getInstance().notifyListeners(null, Tabs.TabEvents.RESTORED);
+
+        // If we're not restoring, move the session file so it can be read for
+        // the last tabs section.
+        if (!mShouldRestore) {
+            getProfile().moveSessionFile();
+        }
+
+        Telemetry.HistogramAdd("FENNEC_STARTUP_GECKOAPP_ACTION", startupAction.ordinal());
+
+        if (!mIsRestoringActivity) {
+            GeckoThread.setArgs(intent.getStringExtra("args"));
+            GeckoThread.setAction(intent.getAction());
+            GeckoThread.setUri(passedUri);
+        }
+        if (!ACTION_DEBUG.equals(action) &&
+            GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.Launching, GeckoThread.LaunchState.Launched)) {
+            GeckoThread.createAndStart();
+        } else if (ACTION_DEBUG.equals(action) &&
+            GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.Launching, GeckoThread.LaunchState.WaitForDebugger)) {
+            ThreadUtils.getUiHandler().postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    GeckoThread.setLaunchState(GeckoThread.LaunchState.Launching);
+                    GeckoThread.createAndStart();
+                }
+            }, 1000 * 5 /* 5 seconds */);
+        }
+
+        // Check if launched from data reporting notification.
+        if (ACTION_LAUNCH_SETTINGS.equals(action)) {
+            Intent settingsIntent = new Intent(GeckoApp.this, GeckoPreferences.class);
+            // Copy extras.
+            settingsIntent.putExtras(intent);
+            startActivity(settingsIntent);
+        }
+
+        //app state callbacks
+        mAppStateListeners = new LinkedList<GeckoAppShell.AppStateListener>();
+
+        //register for events
+        registerEventListener("log");
+        registerEventListener("Reader:ListCountRequest");
+        registerEventListener("Reader:ListStatusRequest");
+        registerEventListener("Reader:Added");
+        registerEventListener("Reader:Removed");
+        registerEventListener("Reader:Share");
+        registerEventListener("Reader:FaviconRequest");
+        registerEventListener("onCameraCapture");
+        registerEventListener("Gecko:Ready");
+        registerEventListener("Gecko:DelayedStartup");
+        registerEventListener("Toast:Show");
+        registerEventListener("DOMFullScreen:Start");
+        registerEventListener("DOMFullScreen:Stop");
+        registerEventListener("ToggleChrome:Hide");
+        registerEventListener("ToggleChrome:Show");
+        registerEventListener("ToggleChrome:Focus");
+        registerEventListener("Permissions:Data");
+        registerEventListener("Session:StatePurged");
+        registerEventListener("Bookmark:Insert");
+        registerEventListener("Accessibility:Event");
+        registerEventListener("Accessibility:Ready");
+        registerEventListener("Shortcut:Remove");
+        registerEventListener("Share:Text");
+        registerEventListener("Share:Image");
+        registerEventListener("Image:SetAs");
+        registerEventListener("Sanitize:ClearHistory");
+        registerEventListener("Update:Check");
+        registerEventListener("Update:Download");
+        registerEventListener("Update:Install");
+        registerEventListener("PrivateBrowsing:Data");
+        registerEventListener("Contact:Add");
+        registerEventListener("Intent:Open");
+        registerEventListener("Intent:OpenForResult");
+        registerEventListener("Intent:GetHandlers");
+        registerEventListener("Locale:Set");
+        registerEventListener("NativeApp:IsDebuggable");
+        registerEventListener("SystemUI:Visibility");
+
+        EventListener.registerEvents();
+
+        if (SmsManager.getInstance() != null) {
+          SmsManager.getInstance().start();
+        }
+
+        mContactService = new ContactService(GeckoAppShell.getEventDispatcher(), this);
+
+        mPromptService = new PromptService(this);
+
+        mTextSelection = new TextSelection((TextSelectionHandle) findViewById(R.id.start_handle),
+                                           (TextSelectionHandle) findViewById(R.id.middle_handle),
+                                           (TextSelectionHandle) findViewById(R.id.end_handle),
+                                           GeckoAppShell.getEventDispatcher(),
+                                           this);
+
+        PrefsHelper.getPref("app.update.autodownload", new PrefsHelper.PrefHandlerBase() {
+            @Override public void prefValue(String pref, String value) {
+                UpdateServiceHelper.registerForUpdates(GeckoApp.this, value);
+            }
+        });
+
+        PrefsHelper.getPref("app.geo.reportdata", new PrefsHelper.PrefHandlerBase() {
+            @Override public void prefValue(String pref, int value) {
+                if (value == 1)
+                    mShouldReportGeoData = true;
+                else
+                    mShouldReportGeoData = false;
+            }
+        });
+
+        // Trigger the completion of the telemetry timer that wraps activity startup,
+        // then grab the duration to give to FHR.
+        mJavaUiStartupTimer.stop();
+        final long javaDuration = mJavaUiStartupTimer.getElapsed();
+
+        ThreadUtils.getBackgroundHandler().postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                final HealthRecorder rec = mHealthRecorder;
+                if (rec != null) {
+                    rec.recordJavaStartupTime(javaDuration);
+                }
+
+                // Record our launch time for the announcements service
+                // to use in assessing inactivity.
+                final Context context = GeckoApp.this;
+                AnnouncementsBroadcastService.recordLastLaunch(context);
+
+                // Kick off our background services. We do this by invoking the broadcast
+                // receiver, which uses the system alarm infrastructure to perform tasks at
+                // intervals.
+                GeckoPreferences.broadcastAnnouncementsPref(context);
+                GeckoPreferences.broadcastHealthReportUploadPref(context);
+                if (!GeckoThread.checkLaunchState(GeckoThread.LaunchState.Launched)) {
+                    return;
+                }
+            }
+        }, 50);
+
+        if (mIsRestoringActivity) {
+            GeckoThread.setLaunchState(GeckoThread.LaunchState.GeckoRunning);
+            Tab selectedTab = Tabs.getInstance().getSelectedTab();
+            if (selectedTab != null)
+                Tabs.getInstance().notifyListeners(selectedTab, Tabs.TabEvents.SELECTED);
+            geckoConnected();
+            GeckoAppShell.setLayerClient(mLayerView.getLayerClient());
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Viewport:Flush", null));
+        }
+
+        if (ACTION_ALERT_CALLBACK.equals(action)) {
+            processAlertCallback(intent);
+        }
+    }
+
+    private String restoreSessionTabs(final boolean isExternalURL) throws SessionRestoreException {
+        try {
+            String sessionString = getProfile().readSessionFile(false);
+            if (sessionString == null) {
+                throw new SessionRestoreException("Could not read from session file");
+            }
+
+            // If we are doing an OOM restore, parse the session data and
+            // stub the restored tabs immediately. This allows the UI to be
+            // updated before Gecko has restored.
+            if (mShouldRestore) {
+                final JSONArray tabs = new JSONArray();
+                SessionParser parser = new SessionParser() {
+                    @Override
+                    public void onTabRead(SessionTab sessionTab) {
+                        JSONObject tabObject = sessionTab.getTabObject();
+
+                        int flags = Tabs.LOADURL_NEW_TAB;
+                        flags |= ((isExternalURL || !sessionTab.isSelected()) ? Tabs.LOADURL_DELAY_LOAD : 0);
+                        flags |= (tabObject.optBoolean("desktopMode") ? Tabs.LOADURL_DESKTOP : 0);
+                        flags |= (tabObject.optBoolean("isPrivate") ? Tabs.LOADURL_PRIVATE : 0);
+
+                        Tab tab = Tabs.getInstance().loadUrl(sessionTab.getUrl(), flags);
+                        tab.updateTitle(sessionTab.getTitle());
+
+                        try {
+                            tabObject.put("tabId", tab.getId());
+                        } catch (JSONException e) {
+                            Log.e(LOGTAG, "JSON error", e);
+                        }
+                        tabs.put(tabObject);
+                    }
+                };
+
+                if (mPrivateBrowsingSession == null) {
+                    parser.parse(sessionString);
+                } else {
+                    parser.parse(sessionString, mPrivateBrowsingSession);
+                }
+
+                if (tabs.length() > 0) {
+                    sessionString = new JSONObject().put("windows", new JSONArray().put(new JSONObject().put("tabs", tabs))).toString();
+                } else {
+                    throw new SessionRestoreException("No tabs could be read from session file");
+                }
+            }
+
+            JSONObject restoreData = new JSONObject();
+            restoreData.put("sessionString", sessionString);
+            return restoreData.toString();
+
+        } catch (JSONException e) {
+            throw new SessionRestoreException(e);
+        }
+    }
+
+    public GeckoProfile getProfile() {
+        // fall back to default profile if we didn't load a specific one
+        if (mProfile == null) {
+            mProfile = GeckoProfile.get(this);
+        }
+        return mProfile;
+    }
+
+    /**
+     * Determine whether the session should be restored.
+     *
+     * @param savedInstanceState Saved instance state given to the activity
+     * @return                   Whether to restore
+     */
+    protected boolean getSessionRestoreState(Bundle savedInstanceState) {
+        final SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+        boolean shouldRestore = false;
+
+        final int versionCode = getVersionCode();
+        if (prefs.getInt(PREFS_VERSION_CODE, 0) != versionCode) {
+            // If the version has changed, the user has done an upgrade, so restore
+            // previous tabs.
+            ThreadUtils.postToBackgroundThread(new Runnable() {
+                @Override
+                public void run() {
+                    prefs.edit()
+                         .putInt(PREFS_VERSION_CODE, versionCode)
+                         .commit();
+                }
+            });
+
+            shouldRestore = true;
+        } else if (savedInstanceState != null || getSessionRestorePreference().equals("always") || getRestartFromIntent()) {
+            // We're coming back from a background kill by the OS, the user
+            // has chosen to always restore, or we just restarted.
+            shouldRestore = true;
+        }
+
+        return shouldRestore;
+    }
+
+    private String getSessionRestorePreference() {
+        return PreferenceManager.getDefaultSharedPreferences(this)
+                                .getString(GeckoPreferences.PREFS_RESTORE_SESSION, "quit");
+    }
+
+    private boolean getRestartFromIntent() {
+        return getIntent().getBooleanExtra("didRestart", false);
+    }
+
+    /**
+     * Enable Android StrictMode checks (for supported OS versions).
+     * http://developer.android.com/reference/android/os/StrictMode.html
+     */
+    private void enableStrictMode() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
+            return;
+        }
+
+        Log.d(LOGTAG, "Enabling Android StrictMode");
+
+        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
+                                  .detectAll()
+                                  .penaltyLog()
+                                  .build());
+
+        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
+                               .detectAll()
+                               .penaltyLog()
+                               .build());
+    }
+
+    public void enableCameraView() {
+        // Start listening for orientation events
+        mCameraOrientationEventListener = new OrientationEventListener(this) {
+            @Override
+            public void onOrientationChanged(int orientation) {
+                if (mAppStateListeners != null) {
+                    for (GeckoAppShell.AppStateListener listener: mAppStateListeners) {
+                        listener.onOrientationChanged();
+                    }
+                }
+            }
+        };
+        mCameraOrientationEventListener.enable();
+
+        // Try to make it fully transparent.
+        if (mCameraView instanceof SurfaceView) {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+                mCameraView.setAlpha(0.0f);
+            }
+        } else if (mCameraView instanceof TextureView) {
+            mCameraView.setAlpha(0.0f);
+        }
+        RelativeLayout mCameraLayout = (RelativeLayout) findViewById(R.id.camera_layout);
+        // Some phones (eg. nexus S) need at least a 8x16 preview size
+        mCameraLayout.addView(mCameraView,
+                              new AbsoluteLayout.LayoutParams(8, 16, 0, 0));
+    }
+
+    public void disableCameraView() {
+        if (mCameraOrientationEventListener != null) {
+            mCameraOrientationEventListener.disable();
+            mCameraOrientationEventListener = null;
+        }
+        RelativeLayout mCameraLayout = (RelativeLayout) findViewById(R.id.camera_layout);
+        mCameraLayout.removeView(mCameraView);
+    }
+
+    public String getDefaultUAString() {
+        return HardwareUtils.isTablet() ? AppConstants.USER_AGENT_FENNEC_TABLET :
+                                          AppConstants.USER_AGENT_FENNEC_MOBILE;
+    }
+
+    public String getUAStringForHost(String host) {
+        // With our standard UA String, we get a 200 response code and
+        // client-side redirect from t.co. This bot-like UA gives us a
+        // 301 response code
+        if ("t.co".equals(host)) {
+            return AppConstants.USER_AGENT_BOT_LIKE;
+        }
+        return getDefaultUAString();
+    }
+
+    class PrefetchRunnable implements Runnable {
+        private String mPrefetchUrl;
+
+        PrefetchRunnable(String prefetchUrl) {
+            mPrefetchUrl = prefetchUrl;
+        }
+
+        @Override
+        public void run() {
+            HttpURLConnection connection = null;
+            try {
+                URL url = new URL(mPrefetchUrl);
+                // data url should have an http scheme
+                connection = (HttpURLConnection) url.openConnection();
+                connection.setRequestProperty("User-Agent", getUAStringForHost(url.getHost()));
+                connection.setInstanceFollowRedirects(false);
+                connection.setRequestMethod("GET");
+                connection.connect();
+            } catch (Exception e) {
+                Log.e(LOGTAG, "Exception prefetching URL", e);
+            } finally {
+                if (connection != null)
+                    connection.disconnect();
+            }
+        }
+    }
+
+    private void processAlertCallback(Intent intent) {
+        String alertName = "";
+        String alertCookie = "";
+        Uri data = intent.getData();
+        if (data != null) {
+            alertName = data.getQueryParameter("name");
+            if (alertName == null)
+                alertName = "";
+            alertCookie = data.getQueryParameter("cookie");
+            if (alertCookie == null)
+                alertCookie = "";
+        }
+        handleNotification(ACTION_ALERT_CALLBACK, alertName, alertCookie);
+    }
+
+    @Override
+    protected void onNewIntent(Intent intent) {
+        if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoExiting)) {
+            // We're exiting and shouldn't try to do anything else. In the case
+            // where we are hung while exiting, we should force the process to exit.
+            GeckoAppShell.systemExit();
+            return;
+        }
+
+        // if we were previously OOM killed, we can end up here when launching
+        // from external shortcuts, so set this as the intent for initialization
+        if (!mInitialized) {
+            setIntent(intent);
+            return;
+        }
+
+        final String action = intent.getAction();
+
+        if (ACTION_LOAD.equals(action)) {
+            String uri = intent.getDataString();
+            Tabs.getInstance().loadUrl(uri);
+        } else if (Intent.ACTION_VIEW.equals(action)) {
+            String uri = intent.getDataString();
+            Tabs.getInstance().loadUrl(uri, Tabs.LOADURL_NEW_TAB |
+                                            Tabs.LOADURL_USER_ENTERED |
+                                            Tabs.LOADURL_EXTERNAL);
+        } else if (action != null && action.startsWith(ACTION_WEBAPP_PREFIX)) {
+            // A lightweight mechanism for loading a web page as a webapp
+            // without installing the app natively nor registering it in the DOM
+            // application registry.
+            String uri = getURIFromIntent(intent);
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createWebappLoadEvent(uri));
+        } else if (ACTION_BOOKMARK.equals(action)) {
+            String uri = getURIFromIntent(intent);
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBookmarkLoadEvent(uri));
+        } else if (Intent.ACTION_SEARCH.equals(action)) {
+            String uri = getURIFromIntent(intent);
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createURILoadEvent(uri));
+        } else if (ACTION_ALERT_CALLBACK.equals(action)) {
+            processAlertCallback(intent);
+        } else if (ACTION_LAUNCH_SETTINGS.equals(action)) {
+            // Check if launched from data reporting notification.
+            Intent settingsIntent = new Intent(GeckoApp.this, GeckoPreferences.class);
+            // Copy extras.
+            settingsIntent.putExtras(intent);
+            startActivity(settingsIntent);
+        }
+    }
+
+    /*
+     * Handles getting a uri from and intent in a way that is backwards
+     * compatable with our previous implementations
+     */
+    protected String getURIFromIntent(Intent intent) {
+        final String action = intent.getAction();
+        if (ACTION_ALERT_CALLBACK.equals(action))
+            return null;
+
+        String uri = intent.getDataString();
+        if (uri != null)
+            return uri;
+
+        if ((action != null && action.startsWith(ACTION_WEBAPP_PREFIX)) || ACTION_BOOKMARK.equals(action)) {
+            uri = intent.getStringExtra("args");
+            if (uri != null && uri.startsWith("--url=")) {
+                uri.replace("--url=", "");
+            }
+        }
+        return uri;
+    }
+
+    protected int getOrientation() {
+        return GeckoScreenOrientation.getInstance().getAndroidOrientation();
+    }
+
+    @Override
+    public void onResume()
+    {
+        // After an onPause, the activity is back in the foreground.
+        // Undo whatever we did in onPause.
+        super.onResume();
+
+        int newOrientation = getResources().getConfiguration().orientation;
+        if (GeckoScreenOrientation.getInstance().update(newOrientation)) {
+            refreshChrome();
+        }
+
+        // User may have enabled/disabled accessibility.
+        GeckoAccessibility.updateAccessibilitySettings(this);
+
+        if (mAppStateListeners != null) {
+            for (GeckoAppShell.AppStateListener listener: mAppStateListeners) {
+                listener.onResume();
+            }
+        }
+
+        // We use two times: a pseudo-unique wall-clock time to identify the
+        // current session across power cycles, and the elapsed realtime to
+        // track the duration of the session.
+        final long now = System.currentTimeMillis();
+        final long realTime = android.os.SystemClock.elapsedRealtime();
+
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                // Now construct the new session on HealthRecorder's behalf. We do this here
+                // so it can benefit from a single near-startup prefs commit.
+                SessionInformation currentSession = new SessionInformation(now, realTime);
+
+                SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+                SharedPreferences.Editor editor = prefs.edit();
+                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
+                currentSession.recordBegin(editor);
+                editor.commit();
+
+                final HealthRecorder rec = mHealthRecorder;
+                if (rec != null) {
+                    rec.setCurrentSession(currentSession);
+                } else {
+                    Log.w(LOGTAG, "Can't record session: rec is null.");
+                }
+            }
+         });
+    }
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+
+        if (!mInitialized && hasFocus) {
+            initialize();
+            getWindow().setBackgroundDrawable(null);
+        }
+    }
+
+    @Override
+    public void onPause()
+    {
+        final HealthRecorder rec = mHealthRecorder;
+        final Context context = this;
+
+        // In some way it's sad that Android will trigger StrictMode warnings
+        // here as the whole point is to save to disk while the activity is not
+        // interacting with the user.
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+                SharedPreferences.Editor editor = prefs.edit();
+                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, true);
+                if (rec != null) {
+                    rec.recordSessionEnd("P", editor);
+                }
+
+                // If we haven't done it before, cleanup any old files in our old temp dir
+                if (prefs.getBoolean(GeckoApp.PREFS_CLEANUP_TEMP_FILES, true)) {
+                    File tempDir = GeckoLoader.getGREDir(GeckoApp.this);
+                    FileUtils.delTree(tempDir, new FileUtils.NameAndAgeFilter(null, ONE_DAY_MS), false);
+
+                    editor.putBoolean(GeckoApp.PREFS_CLEANUP_TEMP_FILES, false);
+                }
+
+                editor.commit();
+
+                // In theory, the first browser session will not run long enough that we need to
+                // prune during it and we'd rather run it when the browser is inactive so we wait
+                // until here to register the prune service.
+                GeckoPreferences.broadcastHealthReportPrune(context);
+            }
+        });
+
+        if (mAppStateListeners != null) {
+            for(GeckoAppShell.AppStateListener listener: mAppStateListeners) {
+                listener.onPause();
+            }
+        }
+
+        super.onPause();
+    }
+
+    @Override
+    public void onRestart()
+    {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+	        @Override
+	        public void run() {
+		        SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+		        SharedPreferences.Editor editor = prefs.edit();
+		        editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
+		        editor.commit();
+	        }
+        });
+
+        super.onRestart();
+    }
+
+    @Override
+    public void onDestroy()
+    {
+        unregisterEventListener("log");
+        unregisterEventListener("Reader:ListCountRequest");
+        unregisterEventListener("Reader:ListStatusRequest");
+        unregisterEventListener("Reader:Added");
+        unregisterEventListener("Reader:Removed");
+        unregisterEventListener("Reader:Share");
+        unregisterEventListener("Reader:FaviconRequest");
+        unregisterEventListener("onCameraCapture");
+        unregisterEventListener("Gecko:Ready");
+        unregisterEventListener("Gecko:DelayedStartup");
+        unregisterEventListener("Toast:Show");
+        unregisterEventListener("DOMFullScreen:Start");
+        unregisterEventListener("DOMFullScreen:Stop");
+        unregisterEventListener("ToggleChrome:Hide");
+        unregisterEventListener("ToggleChrome:Show");
+        unregisterEventListener("ToggleChrome:Focus");
+        unregisterEventListener("Permissions:Data");
+        unregisterEventListener("Session:StatePurged");
+        unregisterEventListener("Bookmark:Insert");
+        unregisterEventListener("Accessibility:Event");
+        unregisterEventListener("Accessibility:Ready");
+        unregisterEventListener("Shortcut:Remove");
+        unregisterEventListener("Share:Text");
+        unregisterEventListener("Share:Image");
+        unregisterEventListener("Image:SetAs");
+        unregisterEventListener("Sanitize:ClearHistory");
+        unregisterEventListener("Update:Check");
+        unregisterEventListener("Update:Download");
+        unregisterEventListener("Update:Install");
+        unregisterEventListener("PrivateBrowsing:Data");
+        unregisterEventListener("Contact:Add");
+        unregisterEventListener("Intent:Open");
+        unregisterEventListener("Intent:GetHandlers");
+        unregisterEventListener("Locale:Set");
+        unregisterEventListener("NativeApp:IsDebuggable");
+        unregisterEventListener("SystemUI:Visibility");
+
+        EventListener.unregisterEvents();
+
+        deleteTempFiles();
+
+        if (mLayerView != null)
+            mLayerView.destroy();
+        if (mDoorHangerPopup != null)
+            mDoorHangerPopup.destroy();
+        if (mFormAssistPopup != null)
+            mFormAssistPopup.destroy();
+        if (mContactService != null)
+            mContactService.destroy();
+        if (mPromptService != null)
+            mPromptService.destroy();
+        if (mTextSelection != null)
+            mTextSelection.destroy();
+        NotificationHelper.destroy();
+
+        if (SmsManager.getInstance() != null) {
+            SmsManager.getInstance().stop();
+            if (isFinishing())
+                SmsManager.getInstance().shutdown();
+        }
+
+        final HealthRecorder rec = mHealthRecorder;
+        mHealthRecorder = null;
+        if (rec != null && rec.isEnabled()) {
+            // Closing a BrowserHealthRecorder could incur a write.
+            ThreadUtils.postToBackgroundThread(new Runnable() {
+                @Override
+                public void run() {
+                    rec.close();
+                }
+            });
+        }
+
+        Favicons.close();
+
+        super.onDestroy();
+
+        Tabs.unregisterOnTabsChangedListener(this);
+    }
+
+    protected void registerEventListener(String event) {
+        GeckoAppShell.getEventDispatcher().registerEventListener(event, this);
+    }
+
+    protected void unregisterEventListener(String event) {
+        GeckoAppShell.getEventDispatcher().unregisterEventListener(event, this);
+    }
+
+    // Get a temporary directory, may return null
+    public static File getTempDirectory() {
+        File dir = sAppContext.getExternalFilesDir("temp");
+        return dir;
+    }
+
+    // Delete any files in our temporary directory
+    public static void deleteTempFiles() {
+        File dir = getTempDirectory();
+        if (dir == null)
+            return;
+        File[] files = dir.listFiles();
+        if (files == null)
+            return;
+        for (File file : files) {
+            file.delete();
+        }
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        Log.d(LOGTAG, "onConfigurationChanged: " + newConfig.locale);
+        LocaleManager.correctLocale(getResources(), newConfig);
+
+        // onConfigurationChanged is not called for 180 degree orientation changes,
+        // we will miss such rotations and the screen orientation will not be
+        // updated.
+        if (GeckoScreenOrientation.getInstance().update(newConfig.orientation)) {
+            if (mFormAssistPopup != null)
+                mFormAssistPopup.hide();
+            refreshChrome();
+        }
+        super.onConfigurationChanged(newConfig);
+    }
+
+    public String getContentProcessName() {
+        return AppConstants.MOZ_CHILD_PROCESS_NAME;
+    }
+
+    public void addEnvToIntent(Intent intent) {
+        Map<String,String> envMap = System.getenv();
+        Set<Map.Entry<String,String>> envSet = envMap.entrySet();
+        Iterator<Map.Entry<String,String>> envIter = envSet.iterator();
+        int c = 0;
+        while (envIter.hasNext()) {
+            Map.Entry<String,String> entry = envIter.next();
+            intent.putExtra("env" + c, entry.getKey() + "="
+                            + entry.getValue());
+            c++;
+        }
+    }
+
+    public void doRestart() {
+        doRestart(RESTARTER_ACTION, null);
+    }
+
+    public void doRestart(String args) {
+        doRestart(RESTARTER_ACTION, args);
+    }
+
+    public void doRestart(String action, String args) {
+        Log.d(LOGTAG, "doRestart(\"" + action + "\")");
+        try {
+            Intent intent = new Intent(action);
+            intent.setClassName(AppConstants.ANDROID_PACKAGE_NAME, RESTARTER_CLASS);
+            /* TODO: addEnvToIntent(intent); */
+            if (args != null)
+                intent.putExtra("args", args);
+            intent.putExtra("didRestart", true);
+            Log.d(LOGTAG, "Restart intent: " + intent.toString());
+            GeckoAppShell.killAnyZombies();
+            startActivity(intent);
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Error effecting restart.", e);
+        }
+
+        finish();
+        // Give the restart process time to start before we die
+        GeckoAppShell.waitForAnotherGeckoProc();
+    }
+
+    public void handleNotification(String action, String alertName, String alertCookie) {
+        // If Gecko isn't running yet, we ignore the notification. Note that
+        // even if Gecko is running but it was restarted since the notification
+        // was created, the notification won't be handled (bug 849653).
+        if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoRunning)) {
+            GeckoAppShell.handleNotification(action, alertName, alertCookie);
+        }
+    }
+
+    private void checkMigrateProfile() {
+        final File profileDir = getProfile().getDir();
+
+        if (profileDir != null) {
+            final GeckoApp app = GeckoApp.sAppContext;
+
+            ThreadUtils.postToBackgroundThread(new Runnable() {
+                @Override
+                public void run() {
+                    Handler handler = new Handler();
+                    handler.postDelayed(new DeferredCleanupTask(), CLEANUP_DEFERRAL_SECONDS * 1000);
+                }
+            });
+        }
+    }
+
+    private class DeferredCleanupTask implements Runnable {
+        // The cleanup-version setting is recorded to avoid repeating the same
+        // tasks on subsequent startups; CURRENT_CLEANUP_VERSION may be updated
+        // if we need to do additional cleanup for future Gecko versions.
+
+        private static final String CLEANUP_VERSION = "cleanup-version";
+        private static final int CURRENT_CLEANUP_VERSION = 1;
+
+        @Override
+        public void run() {
+            long cleanupVersion = getAppSharedPreferences().getInt(CLEANUP_VERSION, 0);
+
+            if (cleanupVersion < 1) {
+                // Reduce device storage footprint by removing .ttf files from
+                // the res/fonts directory: we no longer need to copy our
+                // bundled fonts out of the APK in order to use them.
+                // See https://bugzilla.mozilla.org/show_bug.cgi?id=878674.
+                File dir = new File("res/fonts");
+                if (dir.exists() && dir.isDirectory()) {
+                    for (File file : dir.listFiles()) {
+                        if (file.isFile() && file.getName().endsWith(".ttf")) {
+                            Log.i(LOGTAG, "deleting " + file.toString());
+                            file.delete();
+                        }
+                    }
+                    if (!dir.delete()) {
+                        Log.w(LOGTAG, "unable to delete res/fonts directory (not empty?)");
+                    } else {
+                        Log.i(LOGTAG, "res/fonts directory deleted");
+                    }
+                }
+            }
+
+            // Additional cleanup needed for future versions would go here
+
+            if (cleanupVersion != CURRENT_CLEANUP_VERSION) {
+                SharedPreferences.Editor editor = getAppSharedPreferences().edit();
+                editor.putInt(CLEANUP_VERSION, CURRENT_CLEANUP_VERSION);
+                editor.commit();
+            }
+        }
+    }
+
+    public PromptService getPromptService() {
+        return mPromptService;
+    }
+
+    @Override
+    public void onBackPressed() {
+        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
+            super.onBackPressed();
+            return;
+        }
+
+        if (autoHideTabs()) {
+            return;
+        }
+
+        if (mDoorHangerPopup != null && mDoorHangerPopup.isShowing()) {
+            mDoorHangerPopup.dismiss();
+            return;
+        }
+
+        if (mFullScreenPluginView != null) {
+            GeckoAppShell.onFullScreenPluginHidden(mFullScreenPluginView);
+            removeFullScreenPluginView(mFullScreenPluginView);
+            return;
+        }
+
+        if (mLayerView != null && mLayerView.isFullScreen()) {
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
+            return;
+        }
+
+        Tabs tabs = Tabs.getInstance();
+        Tab tab = tabs.getSelectedTab();
+        if (tab == null) {
+            moveTaskToBack(true);
+            return;
+        }
+
+        if (tab.doBack())
+            return;
+
+        if (tab.isExternal()) {
+            moveTaskToBack(true);
+            tabs.closeTab(tab);
+            return;
+        }
+
+        int parentId = tab.getParentId();
+        Tab parent = tabs.getTab(parentId);
+        if (parent != null) {
+            // The back button should always return to the parent (not a sibling).
+            tabs.closeTab(tab, parent);
+            return;
+        }
+
+        moveTaskToBack(true);
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (!ActivityHandlerHelper.handleActivityResult(requestCode, resultCode, data)) {
+            super.onActivityResult(requestCode, resultCode, data);
+        }
+    }
+
+    public AbsoluteLayout getPluginContainer() { return mPluginContainer; }
+
+    // Accelerometer.
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        GeckoAppShell.sendEventToGecko(GeckoEvent.createSensorEvent(event));
+    }
+
+    // Geolocation.
+    @Override
+    public void onLocationChanged(Location location) {
+        // No logging here: user-identifying information.
+        GeckoAppShell.sendEventToGecko(GeckoEvent.createLocationEvent(location));
+        if (mShouldReportGeoData)
+            collectAndReportLocInfo(location);
+    }
+
+    public void setCurrentSignalStrenth(SignalStrength ss) {
+        if (ss.isGsm())
+            mSignalStrenth = ss.getGsmSignalStrength();
+    }
+
+    private int getCellInfo(JSONArray cellInfo) {
+        TelephonyManager tm = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
+        if (tm == null)
+            return TelephonyManager.PHONE_TYPE_NONE;
+        List<NeighboringCellInfo> cells = tm.getNeighboringCellInfo();
+        CellLocation cl = tm.getCellLocation();
+        String mcc = "", mnc = "";
+        if (cl instanceof GsmCellLocation) {
+            JSONObject obj = new JSONObject();
+            GsmCellLocation gcl = (GsmCellLocation)cl;
+            try {
+                obj.put("lac", gcl.getLac());
+                obj.put("cid", gcl.getCid());
+
+                int psc = (Build.VERSION.SDK_INT >= 9) ? gcl.getPsc() : -1;
+                obj.put("psc", psc);
+
+                switch(tm.getNetworkType()) {
+                case TelephonyManager.NETWORK_TYPE_GPRS:
+                case TelephonyManager.NETWORK_TYPE_EDGE:
+                    obj.put("radio", "gsm");
+                    break;
+                case TelephonyManager.NETWORK_TYPE_UMTS:
+                case TelephonyManager.NETWORK_TYPE_HSDPA:
+                case TelephonyManager.NETWORK_TYPE_HSUPA:
+                case TelephonyManager.NETWORK_TYPE_HSPA:
+                case TelephonyManager.NETWORK_TYPE_HSPAP:
+                    obj.put("radio", "umts");
+                    break;
+                }
+                String mcc_mnc = tm.getNetworkOperator();
+                if (mcc_mnc.length() > 3) {
+                    mcc = mcc_mnc.substring(0, 3);
+                    mnc = mcc_mnc.substring(3);
+                    obj.put("mcc", mcc);
+                    obj.put("mnc", mnc);
+                }
+                obj.put("asu", mSignalStrenth);
+            } catch(JSONException jsonex) {}
+            cellInfo.put(obj);
+        }
+        if (cells != null) {
+            for (NeighboringCellInfo nci : cells) {
+                try {
+                    JSONObject obj = new JSONObject();
+                    obj.put("lac", nci.getLac());
+                    obj.put("cid", nci.getCid());
+                    obj.put("psc", nci.getPsc());
+                    obj.put("mcc", mcc);
+                    obj.put("mnc", mnc);
+
+                    int dbm;
+                    switch(nci.getNetworkType()) {
+                    case TelephonyManager.NETWORK_TYPE_GPRS:
+                    case TelephonyManager.NETWORK_TYPE_EDGE:
+                        obj.put("radio", "gsm");
+                        break;
+                    case TelephonyManager.NETWORK_TYPE_UMTS:
+                    case TelephonyManager.NETWORK_TYPE_HSDPA:
+                    case TelephonyManager.NETWORK_TYPE_HSUPA:
+                    case TelephonyManager.NETWORK_TYPE_HSPA:
+                    case TelephonyManager.NETWORK_TYPE_HSPAP:
+                        obj.put("radio", "umts");
+                        break;
+                    }
+
+                    obj.put("asu", nci.getRssi());
+                    cellInfo.put(obj);
+                } catch(JSONException jsonex) {}
+            }
+        }
+        return tm.getPhoneType();
+    }
+
+    private static boolean shouldLog(final ScanResult sr) {
+        return sr.SSID == null || !sr.SSID.endsWith("_nomap");
+    }
+
+    private void collectAndReportLocInfo(Location location) {
+        final JSONObject locInfo = new JSONObject();
+        WifiManager wm = (WifiManager)getSystemService(Context.WIFI_SERVICE);
+        wm.startScan();
+        try {
+            JSONArray cellInfo = new JSONArray();
+
+            String radioType = getRadioTypeName(getCellInfo(cellInfo));
+            if (radioType != null) {
+                locInfo.put("radio", radioType);
+            }
+
+            locInfo.put("lon", location.getLongitude());
+            locInfo.put("lat", location.getLatitude());
+
+            // If we have an accuracy, round it up to the next meter.
+            if (location.hasAccuracy()) {
+                locInfo.put("accuracy", (int) Math.ceil(location.getAccuracy()));
+            }
+
+            // If we have an altitude, round it to the nearest meter.
+            if (location.hasAltitude()) {
+                locInfo.put("altitude", Math.round(location.getAltitude()));
+            }
+
+            // Reduce timestamp precision so as to expose less PII.
+            DateFormat df = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+            locInfo.put("time", df.format(new Date(location.getTime())));
+            locInfo.put("cell", cellInfo);
+
+            JSONArray wifiInfo = new JSONArray();
+            List<ScanResult> aps = wm.getScanResults();
+            if (aps != null) {
+                for (ScanResult ap : aps) {
+                    if (!shouldLog(ap))
+                        continue;
+
+                    JSONObject obj = new JSONObject();
+                    obj.put("key", ap.BSSID);
+                    obj.put("frequency", ap.frequency);
+                    obj.put("signal", ap.level);
+                    wifiInfo.put(obj);
+                }
+            }
+            locInfo.put("wifi", wifiInfo);
+        } catch (JSONException jsonex) {
+            Log.w(LOGTAG, "json exception", jsonex);
+            return;
+        }
+
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            public void run() {
+                try {
+                    URL url = new URL(LOCATION_URL);
+                    HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
+                    try {
+                        urlConnection.setDoOutput(true);
+
+                        // Workaround for a bug in Android HttpURLConnection. When the library
+                        // reuses a stale connection, the connection may fail with an EOFException.
+                        if (Build.VERSION.SDK_INT >= 14 && Build.VERSION.SDK_INT <= 18) {
+                            urlConnection.setRequestProperty("Connection", "Close");
+                        }
+
+                        JSONArray batch = new JSONArray();
+                        batch.put(locInfo);
+                        JSONObject wrapper = new JSONObject();
+                        wrapper.put("items", batch);
+                        byte[] bytes = wrapper.toString().getBytes();
+                        urlConnection.setFixedLengthStreamingMode(bytes.length);
+                        OutputStream out = new BufferedOutputStream(urlConnection.getOutputStream());
+                        out.write(bytes);
+                        out.flush();
+                    } catch (JSONException jsonex) {
+                        Log.e(LOGTAG, "error wrapping data as a batch", jsonex);
+                    } catch (IOException ioex) {
+                        Log.e(LOGTAG, "error submitting data", ioex);
+                    } finally {
+                        urlConnection.disconnect();
+                    }
+                } catch (IOException ioex) {
+                    Log.e(LOGTAG, "error submitting data", ioex);
+                }
+            }
+        });
+    }
+
+    private static String getRadioTypeName(int phoneType) {
+        switch (phoneType) {
+            case TelephonyManager.PHONE_TYPE_CDMA:
+                return "cdma";
+
+            case TelephonyManager.PHONE_TYPE_GSM:
+                return "gsm";
+
+            case TelephonyManager.PHONE_TYPE_NONE:
+            case TelephonyManager.PHONE_TYPE_SIP:
+                // These devices have no radio.
+                return null;
+
+            default:
+                Log.e(LOGTAG, "", new IllegalArgumentException("Unexpected PHONE_TYPE: " + phoneType));
+                return null;
+        }
+    }
+
+    @Override
+    public void onProviderDisabled(String provider)
+    {
+    }
+
+    @Override
+    public void onProviderEnabled(String provider)
+    {
+    }
+
+    @Override
+    public void onStatusChanged(String provider, int status, Bundle extras)
+    {
+    }
+
+    // Called when a Gecko Hal WakeLock is changed
+    public void notifyWakeLockChanged(String topic, String state) {
+        PowerManager.WakeLock wl = mWakeLocks.get(topic);
+        if (state.equals("locked-foreground") && wl == null) {
+            PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
+            wl = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, topic);
+            wl.acquire();
+            mWakeLocks.put(topic, wl);
+        } else if (!state.equals("locked-foreground") && wl != null) {
+            wl.release();
+            mWakeLocks.remove(topic);
+        }
+    }
+
+    public void notifyCheckUpdateResult(String result) {
+        GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Update:CheckResult", result));
+    }
+
+    protected void geckoConnected() {
+        mLayerView.geckoConnected();
+        mLayerView.setOverScrollMode(View.OVER_SCROLL_NEVER);
+    }
+
+    public void setAccessibilityEnabled(boolean enabled) {
+    }
+
+    public static class MainLayout extends RelativeLayout {
+        private TouchEventInterceptor mTouchEventInterceptor;
+        private MotionEventInterceptor mMotionEventInterceptor;
+
+        public MainLayout(Context context, AttributeSet attrs) {
+            super(context, attrs);
+        }
+
+        public void setTouchEventInterceptor(TouchEventInterceptor interceptor) {
+            mTouchEventInterceptor = interceptor;
+        }
+
+        public void setMotionEventInterceptor(MotionEventInterceptor interceptor) {
+            mMotionEventInterceptor = interceptor;
+        }
+
+        @Override
+        public boolean onInterceptTouchEvent(MotionEvent event) {
+            if (mTouchEventInterceptor != null && mTouchEventInterceptor.onInterceptTouchEvent(this, event)) {
+                return true;
+            }
+            return super.onInterceptTouchEvent(event);
+        }
+
+        @Override
+        public boolean onTouchEvent(MotionEvent event) {
+            if (mTouchEventInterceptor != null && mTouchEventInterceptor.onTouch(this, event)) {
+                return true;
+            }
+            return super.onTouchEvent(event);
+        }
+
+        @Override
+        public boolean onGenericMotionEvent(MotionEvent event) {
+            if (mMotionEventInterceptor != null && mMotionEventInterceptor.onInterceptMotionEvent(this, event)) {
+                return true;
+            }
+            return super.onGenericMotionEvent(event);
+        }
+
+        @Override
+        public void setDrawingCacheEnabled(boolean enabled) {
+            // Instead of setting drawing cache in the view itself, we simply
+            // enable drawing caching on its children. This is mainly used in
+            // animations (see PropertyAnimator)
+            super.setChildrenDrawnWithCacheEnabled(enabled);
+        }
+    }
+
+    private class FullScreenHolder extends FrameLayout {
+
+        public FullScreenHolder(Context ctx) {
+            super(ctx);
+        }
+
+        @Override
+        public void addView(View view, int index) {
+            /**
+             * This normally gets called when Flash adds a separate SurfaceView
+             * for the video. It is unhappy if we have the LayerView underneath
+             * it for some reason so we need to hide that. Hiding the LayerView causes
+             * its surface to be destroyed, which causes a pause composition
+             * event to be sent to Gecko. We synchronously wait for that to be
+             * processed. Simultaneously, however, Flash is waiting on a mutex so
+             * the post() below is an attempt to avoid a deadlock.
+             */
+            super.addView(view, index);
+
+            ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    mLayerView.hideSurface();
+                }
+            });
+        }
+
+        /**
+         * The methods below are simply copied from what Android WebKit does.
+         * It wasn't ever called in my testing, but might as well
+         * keep it in case it is for some reason. The methods
+         * all return true because we don't want any events
+         * leaking out from the fullscreen view.
+         */
+        @Override
+        public boolean onKeyDown(int keyCode, KeyEvent event) {
+            if (event.isSystem()) {
+                return super.onKeyDown(keyCode, event);
+            }
+            mFullScreenPluginView.onKeyDown(keyCode, event);
+            return true;
+        }
+
+        @Override
+        public boolean onKeyUp(int keyCode, KeyEvent event) {
+            if (event.isSystem()) {
+                return super.onKeyUp(keyCode, event);
+            }
+            mFullScreenPluginView.onKeyUp(keyCode, event);
+            return true;
+        }
+
+        @Override
+        public boolean onTouchEvent(MotionEvent event) {
+            return true;
+        }
+
+        @Override
+        public boolean onTrackballEvent(MotionEvent event) {
+            mFullScreenPluginView.onTrackballEvent(event);
+            return true;
+        }
+    }
+
+    protected NotificationClient makeNotificationClient() {
+        // Don't use a notification service; we may be killed in the background
+        // during downloads.
+        return new AppNotificationClient(getApplicationContext());
+    }
+
+    private int getVersionCode() {
+        int versionCode = 0;
+        try {
+            versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;
+        } catch (NameNotFoundException e) {
+            Log.wtf(LOGTAG, getPackageName() + " not found", e);
+        }
+        return versionCode;
+    }
+
+    protected boolean getIsDebuggable() {
+        // Return false so Fennec doesn't appear to be debuggable.  WebappImpl
+        // then overrides this and returns the value of android:debuggable for
+        // the webapp APK, so webapps get the behavior supported by this method
+        // (i.e. automatic configuration and enabling of the remote debugger).
+        return false;
+
+        // If we ever want to expose this for Fennec, here's how we would do it:
+        // int flags = 0;
+        // try {
+        //     flags = getPackageManager().getPackageInfo(getPackageName(), 0).applicationInfo.flags;
+        // } catch (NameNotFoundException e) {
+        //     Log.wtf(LOGTAG, getPackageName() + " not found", e);
+        // }
+        // return (flags & android.content.pm.ApplicationInfo.FLAG_DEBUGGABLE) != 0;
+    }
+
+    // FHR reason code for a session end prior to a restart for a
+    // locale change.
+    private static final String SESSION_END_LOCALE_CHANGED = "L";
+
+    /**
+     * Use LocaleManager to change our persisted and current locales,
+     * and poke HealthRecorder to tell it of our changed state.
+     */
+    private void setLocale(final String locale) {
+        if (locale == null) {
+            return;
+        }
+        final String resultant = LocaleManager.setSelectedLocale(locale);
+        if (resultant == null) {
+            return;
+        }
+
+        final boolean startNewSession = true;
+        final boolean shouldRestart = false;
+
+        // If the HealthRecorder is not yet initialized (unlikely), the locale change won't
+        // trigger a session transition and subsequent events will be recorded in an environment
+        // with the wrong locale.
+        final HealthRecorder rec = mHealthRecorder;
+        if (rec != null) {
+            rec.onAppLocaleChanged(resultant);
+            rec.onEnvironmentChanged(startNewSession, SESSION_END_LOCALE_CHANGED);
+        }
+
+        if (!shouldRestart) {
+            ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    GeckoApp.this.onLocaleReady(resultant);
+                }
+            });
+            return;
+        }
+
+        // Do this in the background so that the health recorder has its
+        // time to finish.
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                GeckoApp.this.doRestart();
+                GeckoApp.this.finish();
+            }
+        });
+    }
+
+    private void setSystemUiVisible(final boolean visible) {
+        if (Build.VERSION.SDK_INT < 14) {
+            return;
+        }
+
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                if (visible) {
+                    mMainLayout.setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE);
+                } else {
+                    mMainLayout.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE);
+                }
+            }
+        });
+    }
+
+    protected HealthRecorder createHealthRecorder(final Context context,
+                                                  final String profilePath,
+                                                  final EventDispatcher dispatcher,
+                                                  final String osLocale,
+                                                  final String appLocale,
+                                                  final SessionInformation previousSession) {
+        // GeckoApp does not need to record any health information - return a stub.
+        return new StubbedHealthRecorder();
+    }
+}
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/GeckoApp.java~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/GeckoApp.java~	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,2874 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.gecko;
+
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.mozilla.gecko.GeckoProfileDirectories.NoMozillaDirectoryException;
+import org.mozilla.gecko.background.announcements.AnnouncementsBroadcastService;
+import org.mozilla.gecko.db.BrowserDB;
+import org.mozilla.gecko.favicons.Favicons;
+import org.mozilla.gecko.gfx.BitmapUtils;
+import org.mozilla.gecko.gfx.Layer;
+import org.mozilla.gecko.gfx.LayerView;
+import org.mozilla.gecko.gfx.PluginLayer;
+import org.mozilla.gecko.health.HealthRecorder;
+import org.mozilla.gecko.health.SessionInformation;
+import org.mozilla.gecko.health.StubbedHealthRecorder;
+import org.mozilla.gecko.menu.GeckoMenu;
+import org.mozilla.gecko.menu.GeckoMenuInflater;
+import org.mozilla.gecko.menu.MenuPanel;
+import org.mozilla.gecko.mozglue.GeckoLoader;
+import org.mozilla.gecko.preferences.GeckoPreferences;
+import org.mozilla.gecko.prompts.PromptService;
+import org.mozilla.gecko.updater.UpdateService;
+import org.mozilla.gecko.updater.UpdateServiceHelper;
+import org.mozilla.gecko.util.ActivityResultHandler;
+import org.mozilla.gecko.util.FileUtils;
+import org.mozilla.gecko.util.GeckoEventListener;
+import org.mozilla.gecko.util.HardwareUtils;
+import org.mozilla.gecko.util.ThreadUtils;
+import org.mozilla.gecko.util.UiAsyncTask;
+import org.mozilla.gecko.webapp.EventListener;
+import org.mozilla.gecko.webapp.UninstallListener;
+import org.mozilla.gecko.widget.ButtonToast;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.Configuration;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.RectF;
+import android.graphics.drawable.Drawable;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.location.Location;
+import android.location.LocationListener;
+import android.net.Uri;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiManager;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.PowerManager;
+import android.os.StrictMode;
+import android.preference.PreferenceManager;
+import android.provider.ContactsContract;
+import android.provider.MediaStore.Images.Media;
+import android.telephony.CellLocation;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneStateListener;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.telephony.gsm.GsmCellLocation;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.Base64;
+import android.util.Log;
+import android.util.SparseBooleanArray;
+import android.view.Gravity;
+import android.view.KeyEvent;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.MotionEvent;
+import android.view.OrientationEventListener;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.TextureView;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.AbsoluteLayout;
+import android.widget.FrameLayout;
+import android.widget.ListView;
+import android.widget.RelativeLayout;
+import android.widget.SimpleAdapter;
+import android.widget.TextView;
+import android.widget.Toast;
+
+public abstract class GeckoApp
+    extends GeckoActivity
+    implements
+    ContextGetter,
+    GeckoAppShell.GeckoInterface,
+    GeckoEventListener,
+    GeckoMenu.Callback,
+    GeckoMenu.MenuPresenter,
+    LocationListener,
+    SensorEventListener,
+    Tabs.OnTabsChangedListener
+{
+    private static final String LOGTAG = "GeckoApp";
+    private static final int ONE_DAY_MS = 1000*60*60*24;
+
+    private static enum StartupAction {
+        NORMAL,     /* normal application start */
+        URL,        /* launched with a passed URL */
+        PREFETCH    /* launched with a passed URL that we prefetch */
+    }
+
+    public static final String ACTION_ALERT_CALLBACK       = "org.mozilla.gecko.ACTION_ALERT_CALLBACK";
+    public static final String ACTION_BOOKMARK             = "org.mozilla.gecko.BOOKMARK";
+    public static final String ACTION_DEBUG                = "org.mozilla.gecko.DEBUG";
+    public static final String ACTION_LAUNCH_SETTINGS      = "org.mozilla.gecko.SETTINGS";
+    public static final String ACTION_LOAD                 = "org.mozilla.gecko.LOAD";
+    public static final String ACTION_INIT_PW              = "org.mozilla.gecko.INIT_PW";
+    public static final String ACTION_WEBAPP_PREFIX        = "org.mozilla.gecko.WEBAPP";
+
+    public static final String EXTRA_STATE_BUNDLE          = "stateBundle";
+
+    public static final String PREFS_ALLOW_STATE_BUNDLE    = "allowStateBundle";
+    public static final String PREFS_CRASHED               = "crashed";
+    public static final String PREFS_NAME                  = "GeckoApp";
+    public static final String PREFS_OOM_EXCEPTION         = "OOMException";
+    public static final String PREFS_VERSION_CODE          = "versionCode";
+    public static final String PREFS_WAS_STOPPED           = "wasStopped";
+    public static final String PREFS_CLEANUP_TEMP_FILES    = "cleanupTempFiles";
+
+    public static final String SAVED_STATE_IN_BACKGROUND   = "inBackground";
+    public static final String SAVED_STATE_PRIVATE_SESSION = "privateSession";
+
+    static private final String LOCATION_URL = "https://location.services.mozilla.com/v1/submit";
+
+    // Delay before running one-time "cleanup" tasks that may be needed
+    // after a version upgrade.
+    private static final int CLEANUP_DEFERRAL_SECONDS = 15;
+
+    protected RelativeLayout mMainLayout;
+    protected RelativeLayout mGeckoLayout;
+    public View getView() { return mGeckoLayout; }
+    private View mCameraView;
+    private OrientationEventListener mCameraOrientationEventListener;
+    public List<GeckoAppShell.AppStateListener> mAppStateListeners;
+    private static GeckoApp sAppContext;
+    protected MenuPanel mMenuPanel;
+    protected Menu mMenu;
+    protected GeckoProfile mProfile;
+    protected boolean mIsRestoringActivity;
+
+    private ContactService mContactService;
+    private PromptService mPromptService;
+    private TextSelection mTextSelection;
+
+    protected DoorHangerPopup mDoorHangerPopup;
+    protected FormAssistPopup mFormAssistPopup;
+    protected ButtonToast mToast;
+
+    protected LayerView mLayerView;
+    private AbsoluteLayout mPluginContainer;
+
+    private FullScreenHolder mFullScreenPluginContainer;
+    private View mFullScreenPluginView;
+
+    private HashMap<String, PowerManager.WakeLock> mWakeLocks = new HashMap<String, PowerManager.WakeLock>();
+
+    protected boolean mShouldRestore;
+    protected boolean mInitialized = false;
+    private Telemetry.Timer mJavaUiStartupTimer;
+    private Telemetry.Timer mGeckoReadyStartupTimer;
+
+    private String mPrivateBrowsingSession;
+
+    private volatile HealthRecorder mHealthRecorder = null;
+
+    private int mSignalStrenth;
+    private PhoneStateListener mPhoneStateListener = null;
+    private boolean mShouldReportGeoData;
+
+    abstract public int getLayout();
+    abstract public boolean hasTabsSideBar();
+    abstract protected String getDefaultProfileName() throws NoMozillaDirectoryException;
+
+    private static final String RESTARTER_ACTION = "org.mozilla.gecko.restart";
+    private static final String RESTARTER_CLASS = "org.mozilla.gecko.Restarter";
+
+    @SuppressWarnings("serial")
+    class SessionRestoreException extends Exception {
+        public SessionRestoreException(Exception e) {
+            super(e);
+        }
+
+        public SessionRestoreException(String message) {
+            super(message);
+        }
+    }
+
+    void toggleChrome(final boolean aShow) { }
+
+    void focusChrome() { }
+
+    @Override
+    public Context getContext() {
+        return sAppContext;
+    }
+
+    @Override
+    public SharedPreferences getSharedPreferences() {
+        return GeckoApp.getAppSharedPreferences();
+    }
+
+    public static SharedPreferences getAppSharedPreferences() {
+        return GeckoApp.sAppContext.getSharedPreferences(GeckoApp.PREFS_NAME, 0);
+    }
+
+    public Activity getActivity() {
+        return this;
+    }
+
+    public LocationListener getLocationListener() {
+        if (mShouldReportGeoData && mPhoneStateListener == null) {
+            mPhoneStateListener = new PhoneStateListener() {
+                public void onSignalStrengthsChanged(SignalStrength signalStrength) {
+                    setCurrentSignalStrenth(signalStrength);
+                }
+            };
+            TelephonyManager tm = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
+            tm.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SIGNAL_STRENGTHS);
+        }
+        return this;
+    }
+
+    public SensorEventListener getSensorEventListener() {
+        return this;
+    }
+
+    public View getCameraView() {
+        return mCameraView;
+    }
+
+    public void addAppStateListener(GeckoAppShell.AppStateListener listener) {
+        mAppStateListeners.add(listener);
+    }
+
+    public void removeAppStateListener(GeckoAppShell.AppStateListener listener) {
+        mAppStateListeners.remove(listener);
+    }
+
+    public FormAssistPopup getFormAssistPopup() {
+        return mFormAssistPopup;
+    }
+
+    @Override
+    public void onTabChanged(Tab tab, Tabs.TabEvents msg, Object data) {
+        // When a tab is closed, it is always unselected first.
+        // When a tab is unselected, another tab is always selected first.
+        switch(msg) {
+            case UNSELECTED:
+                hidePlugins(tab);
+                break;
+
+            case LOCATION_CHANGE:
+                // We only care about location change for the selected tab.
+                if (!Tabs.getInstance().isSelectedTab(tab))
+                    break;
+                // Fall through...
+            case SELECTED:
+                invalidateOptionsMenu();
+                if (mFormAssistPopup != null)
+                    mFormAssistPopup.hide();
+                break;
+
+            case LOADED:
+                // Sync up the layer view and the tab if the tab is
+                // currently displayed.
+                LayerView layerView = mLayerView;
+                if (layerView != null && Tabs.getInstance().isSelectedTab(tab))
+                    layerView.setBackgroundColor(tab.getBackgroundColor());
+                break;
+
+            case DESKTOP_MODE_CHANGE:
+                if (Tabs.getInstance().isSelectedTab(tab))
+                    invalidateOptionsMenu();
+                break;
+        }
+    }
+
+    public void refreshChrome() { }
+
+    @Override
+    public void invalidateOptionsMenu() {
+        if (mMenu == null)
+            return;
+
+        onPrepareOptionsMenu(mMenu);
+
+        if (Build.VERSION.SDK_INT >= 11)
+            super.invalidateOptionsMenu();
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        mMenu = menu;
+
+        MenuInflater inflater = getMenuInflater();
+        inflater.inflate(R.menu.gecko_app_menu, mMenu);
+        return true;
+    }
+
+    @Override
+    public MenuInflater getMenuInflater() {
+        if (Build.VERSION.SDK_INT >= 11)
+            return new GeckoMenuInflater(this);
+        else
+            return super.getMenuInflater();
+    }
+
+    public MenuPanel getMenuPanel() {
+        if (mMenuPanel == null) {
+            onCreatePanelMenu(Window.FEATURE_OPTIONS_PANEL, null);
+            invalidateOptionsMenu();
+        }
+        return mMenuPanel;
+    }
+
+    @Override
+    public boolean onMenuItemSelected(MenuItem item) {
+        return onOptionsItemSelected(item);
+    }
+
+    @Override
+    public void openMenu() {
+        openOptionsMenu();
+    }
+
+    @Override
+    public void showMenu(View menu) {
+        // Hide the menu before we reshow it to avoid platform specific bugs like
+        // bug 794581 and bug 968182.
+        closeMenu();
+
+        mMenuPanel.removeAllViews();
+        mMenuPanel.addView(menu);
+
+        openOptionsMenu();
+    }
+
+    @Override
+    public void closeMenu() {
+        closeOptionsMenu();
+    }
+
+    @Override
+    public View onCreatePanelView(int featureId) {
+        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+            if (mMenuPanel == null) {
+                mMenuPanel = new MenuPanel(this, null);
+            } else {
+                // Prepare the panel everytime before showing the menu.
+                onPreparePanel(featureId, mMenuPanel, mMenu);
+            }
+
+            return mMenuPanel; 
+        }
+  
+        return super.onCreatePanelView(featureId);
+    }
+
+    @Override
+    public boolean onCreatePanelMenu(int featureId, Menu menu) {
+        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+            if (mMenuPanel == null) {
+                mMenuPanel = (MenuPanel) onCreatePanelView(featureId);
+            }
+
+            GeckoMenu gMenu = new GeckoMenu(this, null);
+            gMenu.setCallback(this);
+            gMenu.setMenuPresenter(this);
+            menu = gMenu;
+            mMenuPanel.addView(gMenu);
+
+            return onCreateOptionsMenu(menu);
+        }
+
+        return super.onCreatePanelMenu(featureId, menu);
+    }
+
+    @Override
+    public boolean onPreparePanel(int featureId, View view, Menu menu) {
+        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL)
+            return onPrepareOptionsMenu(menu);
+
+        return super.onPreparePanel(featureId, view, menu);
+    }
+
+    @Override
+    public boolean onMenuOpened(int featureId, Menu menu) {
+        // exit full-screen mode whenever the menu is opened
+        if (mLayerView != null && mLayerView.isFullScreen()) {
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
+        }
+
+        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+            if (mMenu == null) {
+                // getMenuPanel() will force the creation of the menu as well
+                MenuPanel panel = getMenuPanel();
+                onPreparePanel(featureId, panel, mMenu);
+            }
+
+            // Scroll custom menu to the top
+            if (mMenuPanel != null)
+                mMenuPanel.scrollTo(0, 0);
+
+            return true;
+        }
+
+        return super.onMenuOpened(featureId, menu);
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        if (item.getItemId() == R.id.quit) {
+            if (GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.GeckoRunning, GeckoThread.LaunchState.GeckoExiting)) {
+                GeckoAppShell.notifyGeckoOfEvent(GeckoEvent.createBroadcastEvent("Browser:Quit", null));
+            } else {
+                GeckoAppShell.systemExit();
+            }
+            return true;
+        }
+
+        return super.onOptionsItemSelected(item);
+    }
+
+    @Override
+    public void onOptionsMenuClosed(Menu menu) {
+        if (Build.VERSION.SDK_INT >= 11) {
+            mMenuPanel.removeAllViews();
+            mMenuPanel.addView((GeckoMenu) mMenu);
+        }
+    }
+ 
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        // Handle hardware menu key presses separately so that we can show a custom menu in some cases.
+        if (keyCode == KeyEvent.KEYCODE_MENU) {
+            openOptionsMenu();
+            return true;
+        }
+
+        return super.onKeyDown(keyCode, event);
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        if (mToast != null) {
+            mToast.onSaveInstanceState(outState);
+        }
+
+        outState.putBoolean(SAVED_STATE_IN_BACKGROUND, isApplicationInBackground());
+        outState.putString(SAVED_STATE_PRIVATE_SESSION, mPrivateBrowsingSession);
+    }
+
+    void handleFaviconRequest(final String url) {
+        (new UiAsyncTask<Void, Void, String>(ThreadUtils.getBackgroundHandler()) {
+            @Override
+            public String doInBackground(Void... params) {
+                return Favicons.getFaviconURLForPageURL(url);
+            }
+
+            @Override
+            public void onPostExecute(String faviconUrl) {
+                JSONObject args = new JSONObject();
+
+                if (faviconUrl != null) {
+                    try {
+                        args.put("url", url);
+                        args.put("faviconUrl", faviconUrl);
+                    } catch (JSONException e) {
+                        Log.w(LOGTAG, "Error building JSON favicon arguments.", e);
+                    }
+                }
+
+                GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Reader:FaviconReturn", args.toString()));
+            }
+        }).execute();
+    }
+
+    void handleClearHistory() {
+        BrowserDB.clearHistory(getContentResolver());
+    }
+
+    public void addTab() { }
+
+    public void addPrivateTab() { }
+
+    public void showNormalTabs() { }
+
+    public void showPrivateTabs() { }
+
+    public void showRemoteTabs() { }
+
+    private void showTabs(TabsPanel.Panel panel) { }
+
+    public void hideTabs() { }
+
+    /**
+     * Close the tab UI indirectly (not as the result of a direct user
+     * action).  This does not force the UI to close; for example in Firefox
+     * tablet mode it will remain open unless the user explicitly closes it.
+     *
+     * @return True if the tab UI was hidden.
+     */
+    public boolean autoHideTabs() { return false; }
+
+    public boolean areTabsShown() { return false; }
+
+    @Override
+    public void handleMessage(String event, JSONObject message) {
+        try {
+            if (event.equals("Toast:Show")) {
+                final String msg = message.getString("message");
+                final JSONObject button = message.optJSONObject("button");
+                if (button != null) {
+                    final String label = button.optString("label");
+                    final String icon = button.optString("icon");
+                    final String id = button.optString("id");
+                    showButtonToast(msg, label, icon, id);
+                } else {
+                    final String duration = message.getString("duration");
+                    showNormalToast(msg, duration);
+                }
+            } else if (event.equals("log")) {
+                // generic log listener
+                final String msg = message.getString("msg");
+                Log.d(LOGTAG, "Log: " + msg);
+            } else if (event.equals("Reader:FaviconRequest")) {
+                final String url = message.getString("url");
+                handleFaviconRequest(url);
+            } else if (event.equals("Gecko:DelayedStartup")) {
+                ThreadUtils.postToBackgroundThread(new UninstallListener.DelayedStartupTask(this));
+            } else if (event.equals("Gecko:Ready")) {
+                mGeckoReadyStartupTimer.stop();
+                geckoConnected();
+
+                // This method is already running on the background thread, so we
+                // know that mHealthRecorder will exist. That doesn't stop us being
+                // paranoid.
+                // This method is cheap, so don't spawn a new runnable.
+                final HealthRecorder rec = mHealthRecorder;
+                if (rec != null) {
+                  rec.recordGeckoStartupTime(mGeckoReadyStartupTimer.getElapsed());
+                }
+            } else if (event.equals("ToggleChrome:Hide")) {
+                toggleChrome(false);
+            } else if (event.equals("ToggleChrome:Show")) {
+                toggleChrome(true);
+            } else if (event.equals("ToggleChrome:Focus")) {
+                focusChrome();
+            } else if (event.equals("DOMFullScreen:Start")) {
+                // Local ref to layerView for thread safety
+                LayerView layerView = mLayerView;
+                if (layerView != null) {
+                    layerView.setFullScreen(true);
+                }
+            } else if (event.equals("DOMFullScreen:Stop")) {
+                // Local ref to layerView for thread safety
+                LayerView layerView = mLayerView;
+                if (layerView != null) {
+                    layerView.setFullScreen(false);
+                }
+            } else if (event.equals("Permissions:Data")) {
+                String host = message.getString("host");
+                JSONArray permissions = message.getJSONArray("permissions");
+                showSiteSettingsDialog(host, permissions);
+            } else if (event.equals("Session:StatePurged")) {
+                onStatePurged();
+            } else if (event.equals("Bookmark:Insert")) {
+                final String url = message.getString("url");
+                final String title = message.getString("title");
+                final Context context = this;
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        Toast.makeText(context, R.string.bookmark_added, Toast.LENGTH_SHORT).show();
+                        ThreadUtils.postToBackgroundThread(new Runnable() {
+                            @Override
+                            public void run() {
+                                BrowserDB.addBookmark(getContentResolver(), title, url);
+                            }
+                        });
+                    }
+                });
+            } else if (event.equals("Accessibility:Event")) {
+                GeckoAccessibility.sendAccessibilityEvent(message);
+            } else if (event.equals("Accessibility:Ready")) {
+                GeckoAccessibility.updateAccessibilitySettings(this);
+            } else if (event.equals("Shortcut:Remove")) {
+                final String url = message.getString("url");
+                final String origin = message.getString("origin");
+                final String title = message.getString("title");
+                final String type = message.getString("shortcutType");
+                GeckoAppShell.removeShortcut(title, url, origin, type);
+            } else if (event.equals("Share:Text")) {
+                String text = message.getString("text");
+                GeckoAppShell.openUriExternal(text, "text/plain", "", "", Intent.ACTION_SEND, "");
+            } else if (event.equals("Share:Image")) {
+                String src = message.getString("url");
+                String type = message.getString("mime");
+                GeckoAppShell.shareImage(src, type);
+            } else if (event.equals("Image:SetAs")) {
+                String src = message.getString("url");
+                setImageAs(src);
+            } else if (event.equals("Sanitize:ClearHistory")) {
+                handleClearHistory();
+            } else if (event.equals("Update:Check")) {
+                startService(new Intent(UpdateServiceHelper.ACTION_CHECK_FOR_UPDATE, null, this, UpdateService.class));
+            } else if (event.equals("Update:Download")) {
+                startService(new Intent(UpdateServiceHelper.ACTION_DOWNLOAD_UPDATE, null, this, UpdateService.class));
+            } else if (event.equals("Update:Install")) {
+                startService(new Intent(UpdateServiceHelper.ACTION_APPLY_UPDATE, null, this, UpdateService.class));
+            } else if (event.equals("PrivateBrowsing:Data")) {
+                // null strings return "null" (http://code.google.com/p/android/issues/detail?id=13830)
+                if (message.isNull("session")) {
+                    mPrivateBrowsingSession = null;
+                } else {
+                    mPrivateBrowsingSession = message.getString("session");
+                }
+            } else if (event.equals("Contact:Add")) {                
+                if (!message.isNull("email")) {
+                    Uri contactUri = Uri.parse(message.getString("email"));       
+                    Intent i = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT, contactUri);
+                    startActivity(i);
+                } else if (!message.isNull("phone")) {
+                    Uri contactUri = Uri.parse(message.getString("phone"));       
+                    Intent i = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT, contactUri);
+                    startActivity(i);
+                } else {
+                    // something went wrong.
+                    Log.e(LOGTAG, "Received Contact:Add message with no email nor phone number");
+                }                
+            } else if (event.equals("Intent:GetHandlers")) {
+                Intent intent = GeckoAppShell.getOpenURIIntent(sAppContext, message.optString("url"),
+                    message.optString("mime"), message.optString("action"), message.optString("title"));
+                String[] handlers = GeckoAppShell.getHandlersForIntent(intent);
+                List<String> appList = Arrays.asList(handlers);
+                JSONObject handlersJSON = new JSONObject();
+                handlersJSON.put("apps", new JSONArray(appList));
+                EventDispatcher.sendResponse(message, handlersJSON);
+            } else if (event.equals("Intent:Open")) {
+                GeckoAppShell.openUriExternal(message.optString("url"),
+                    message.optString("mime"), message.optString("packageName"),
+                    message.optString("className"), message.optString("action"), message.optString("title"));
+            } else if (event.equals("Intent:OpenForResult")) {
+                Intent intent = GeckoAppShell.getOpenURIIntent(this,
+                                                               message.optString("url"),
+                                                               message.optString("mime"),
+                                                               message.optString("action"),
+                                                               message.optString("title"));
+                intent.setClassName(message.optString("packageName"), message.optString("className"));
+
+                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+
+                final JSONObject originalMessage = message;
+                ActivityHandlerHelper.startIntentForActivity(this,
+                                                             intent,
+                        new ActivityResultHandler() {
+                            @Override
+                            public void onActivityResult (int resultCode, Intent data) {
+                                JSONObject response = new JSONObject();
+
+                                try {
+                                    if (data != null) {
+                                        response.put("extras", bundleToJSON(data.getExtras()));
+                                    }
+                                    response.put("resultCode", resultCode);
+                                } catch (JSONException e) {
+                                    Log.w(LOGTAG, "Error building JSON response.", e);
+                                }
+
+                                EventDispatcher.sendResponse(originalMessage, response);
+                            }
+                        });
+            } else if (event.equals("Locale:Set")) {
+                setLocale(message.getString("locale"));
+            } else if (event.equals("NativeApp:IsDebuggable")) {
+                JSONObject ret = new JSONObject();
+                ret.put("isDebuggable", getIsDebuggable() ? "true" : "false");
+                EventDispatcher.sendResponse(message, ret);
+            } else if (event.equals("SystemUI:Visibility")) {
+                setSystemUiVisible(message.getBoolean("visible"));
+            }
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Exception handling message \"" + event + "\":", e);
+        }
+    }
+
+    void onStatePurged() { }
+
+    /**
+     * @param aPermissions
+     *        Array of JSON objects to represent site permissions.
+     *        Example: { type: "offline-app", setting: "Store Offline Data", value: "Allow" }
+     */
+    private void showSiteSettingsDialog(String aHost, JSONArray aPermissions) {
+        final AlertDialog.Builder builder = new AlertDialog.Builder(this);
+
+        View customTitleView = getLayoutInflater().inflate(R.layout.site_setting_title, null);
+        ((TextView) customTitleView.findViewById(R.id.title)).setText(R.string.site_settings_title);
+        ((TextView) customTitleView.findViewById(R.id.host)).setText(aHost);
+        builder.setCustomTitle(customTitleView);
+
+        // If there are no permissions to clear, show the user a message about that.
+        // In the future, we want to disable the menu item if there are no permissions to clear.
+        if (aPermissions.length() == 0) {
+            builder.setMessage(R.string.site_settings_no_settings);
+        } else {
+
+            ArrayList <HashMap<String, String>> itemList = new ArrayList <HashMap<String, String>>();
+            for (int i = 0; i < aPermissions.length(); i++) {
+                try {
+                    JSONObject permObj = aPermissions.getJSONObject(i);
+                    HashMap<String, String> map = new HashMap<String, String>();
+                    map.put("setting", permObj.getString("setting"));
+                    map.put("value", permObj.getString("value"));
+                    itemList.add(map);
+                } catch (JSONException e) {
+                    Log.w(LOGTAG, "Exception populating settings items.", e);
+                }
+            }
+
+            // setMultiChoiceItems doesn't support using an adapter, so we're creating a hack with
+            // setSingleChoiceItems and changing the choiceMode below when we create the dialog
+            builder.setSingleChoiceItems(new SimpleAdapter(
+                GeckoApp.this,
+                itemList,
+                R.layout.site_setting_item,
+                new String[] { "setting", "value" },
+                new int[] { R.id.setting, R.id.value }
+                ), -1, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int id) { }
+                });
+
+            builder.setPositiveButton(R.string.site_settings_clear, new DialogInterface.OnClickListener() {
+                @Override
+                public void onClick(DialogInterface dialog, int id) {
+                    ListView listView = ((AlertDialog) dialog).getListView();
+                    SparseBooleanArray checkedItemPositions = listView.getCheckedItemPositions();
+
+                    // An array of the indices of the permissions we want to clear
+                    JSONArray permissionsToClear = new JSONArray();
+                    for (int i = 0; i < checkedItemPositions.size(); i++)
+                        if (checkedItemPositions.get(i))
+                            permissionsToClear.put(i);
+
+                    GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent(
+                        "Permissions:Clear", permissionsToClear.toString()));
+                }
+            });
+        }
+
+        builder.setNegativeButton(R.string.site_settings_cancel, new DialogInterface.OnClickListener(){
+            @Override
+            public void onClick(DialogInterface dialog, int id) {
+                dialog.cancel();
+            }
+        });
+
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Dialog dialog = builder.create();
+                dialog.show();
+
+                ListView listView = ((AlertDialog) dialog).getListView();
+                if (listView != null) {
+                    listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
+                    int listSize = listView.getAdapter().getCount();
+                    for (int i = 0; i < listSize; i++)
+                        listView.setItemChecked(i, true);
+                }
+            }
+        });
+    }
+
+    public void showToast(final int resId, final int duration) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Toast.makeText(GeckoApp.this, resId, duration).show();
+            }
+        });
+    }
+
+    public void showNormalToast(final String message, final String duration) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Toast toast;
+                if (duration.equals("long")) {
+                    toast = Toast.makeText(GeckoApp.this, message, Toast.LENGTH_LONG);
+                } else {
+                    toast = Toast.makeText(GeckoApp.this, message, Toast.LENGTH_SHORT);
+                }
+                toast.show();
+            }
+        });
+    }
+
+    protected ButtonToast getButtonToast() {
+        if (mToast != null) {
+            return mToast;
+        }
+
+        ViewStub toastStub = (ViewStub) findViewById(R.id.toast_stub);
+        mToast = new ButtonToast(toastStub.inflate());
+
+        return mToast;
+    }
+
+    void showButtonToast(final String message, final String buttonText,
+                         final String buttonIcon, final String buttonId) {
+        BitmapUtils.getDrawable(GeckoApp.this, buttonIcon, new BitmapUtils.BitmapLoader() {
+            @Override
+            public void onBitmapFound(final Drawable d) {
+                getButtonToast().show(false, message, buttonText, d, new ButtonToast.ToastListener() {
+                    @Override
+                    public void onButtonClicked() {
+                        GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Toast:Click", buttonId));
+                    }
+
+                    @Override
+                    public void onToastHidden(ButtonToast.ReasonHidden reason) {
+                        if (reason == ButtonToast.ReasonHidden.TIMEOUT) {
+                            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Toast:Hidden", buttonId));
+                        }
+                    }
+                });
+            }
+        });
+    }
+
+    private JSONObject bundleToJSON(Bundle bundle) {
+        JSONObject json = new JSONObject();
+        if (bundle == null) {
+            return json;
+        }
+
+        for (String key : bundle.keySet()) {
+            try {
+                json.put(key, bundle.get(key));
+            } catch (JSONException e) {
+                Log.w(LOGTAG, "Error building JSON response.", e);
+            }
+        }
+
+        return json;
+    }
+
+    private void addFullScreenPluginView(View view) {
+        if (mFullScreenPluginView != null) {
+            Log.w(LOGTAG, "Already have a fullscreen plugin view");
+            return;
+        }
+
+        setFullScreen(true);
+
+        view.setWillNotDraw(false);
+        if (view instanceof SurfaceView) {
+            ((SurfaceView) view).setZOrderOnTop(true);
+        }
+
+        mFullScreenPluginContainer = new FullScreenHolder(this);
+
+        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(
+                            ViewGroup.LayoutParams.FILL_PARENT,
+                            ViewGroup.LayoutParams.FILL_PARENT,
+                            Gravity.CENTER);
+        mFullScreenPluginContainer.addView(view, layoutParams);
+
+
+        FrameLayout decor = (FrameLayout)getWindow().getDecorView();
+        decor.addView(mFullScreenPluginContainer, layoutParams);
+
+        mFullScreenPluginView = view;
+    }
+
+    public void addPluginView(final View view, final RectF rect, final boolean isFullScreen) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Tabs tabs = Tabs.getInstance();
+                Tab tab = tabs.getSelectedTab();
+
+                if (isFullScreen) {
+                    addFullScreenPluginView(view);
+                    return;
+                }
+
+                PluginLayer layer = (PluginLayer) tab.getPluginLayer(view);
+                if (layer == null) {
+                    layer = new PluginLayer(view, rect, mLayerView.getRenderer().getMaxTextureSize());
+                    tab.addPluginLayer(view, layer);
+                } else {
+                    layer.reset(rect);
+                    layer.setVisible(true);
+                }
+
+                mLayerView.addLayer(layer);
+            }
+        });
+    }
+
+    private void removeFullScreenPluginView(View view) {
+        if (mFullScreenPluginView == null) {
+            Log.w(LOGTAG, "Don't have a fullscreen plugin view");
+            return;
+        }
+
+        if (mFullScreenPluginView != view) {
+            Log.w(LOGTAG, "Passed view is not the current full screen view");
+            return;
+        }
+
+        mFullScreenPluginContainer.removeView(mFullScreenPluginView);
+
+        // We need do do this on the next iteration in order to avoid
+        // a deadlock, see comment below in FullScreenHolder
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                mLayerView.showSurface();
+            }
+        });
+
+        FrameLayout decor = (FrameLayout)getWindow().getDecorView();
+        decor.removeView(mFullScreenPluginContainer);
+
+        mFullScreenPluginView = null;
+
+        GeckoScreenOrientation.getInstance().unlock();
+        setFullScreen(false);
+    }
+
+    public void removePluginView(final View view, final boolean isFullScreen) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                Tabs tabs = Tabs.getInstance();
+                Tab tab = tabs.getSelectedTab();
+
+                if (isFullScreen) {
+                    removeFullScreenPluginView(view);
+                    return;
+                }
+
+                PluginLayer layer = (PluginLayer) tab.removePluginLayer(view);
+                if (layer != null) {
+                    layer.destroy();
+                }
+            }
+        });
+    }
+
+    // This method starts downloading an image synchronously and displays the Chooser activity to set the image as wallpaper.
+    private void setImageAs(final String aSrc) {
+        boolean isDataURI = aSrc.startsWith("data:");
+        Bitmap image = null;
+        InputStream is = null;
+        ByteArrayOutputStream os = null;
+        try {
+            if (isDataURI) {
+                int dataStart = aSrc.indexOf(",");
+                byte[] buf = Base64.decode(aSrc.substring(dataStart+1), Base64.DEFAULT);
+                image = BitmapUtils.decodeByteArray(buf);
+            } else {
+                int byteRead;
+                byte[] buf = new byte[4192];
+                os = new ByteArrayOutputStream();
+                URL url = new URL(aSrc);
+                is = url.openStream();
+
+                // Cannot read from same stream twice. Also, InputStream from
+                // URL does not support reset. So converting to byte array.
+
+                while((byteRead = is.read(buf)) != -1) {
+                    os.write(buf, 0, byteRead);
+                }
+                byte[] imgBuffer = os.toByteArray();
+                image = BitmapUtils.decodeByteArray(imgBuffer);
+            }
+            if (image != null) {
+                String path = Media.insertImage(getContentResolver(),image, null, null);
+                final Intent intent = new Intent(Intent.ACTION_ATTACH_DATA);
+                intent.addCategory(Intent.CATEGORY_DEFAULT);
+                intent.setData(Uri.parse(path));
+
+                // Removes the image from storage once the chooser activity ends.
+                ActivityHandlerHelper.startIntentForActivity(this,
+                                                            Intent.createChooser(intent, sAppContext.getString(R.string.set_image_chooser_title)),
+                                                            new ActivityResultHandler() {
+                                                                @Override
+                                                                public void onActivityResult (int resultCode, Intent data) {
+                                                                    getContentResolver().delete(intent.getData(), null, null);
+                                                                }
+                                                            });
+            } else {
+                Toast.makeText(sAppContext, R.string.set_image_fail, Toast.LENGTH_SHORT).show();
+            }
+        } catch(OutOfMemoryError ome) {
+            Log.e(LOGTAG, "Out of Memory when converting to byte array", ome);
+        } catch(IOException ioe) {
+            Log.e(LOGTAG, "I/O Exception while setting wallpaper", ioe);
+        } finally {
+            if (is != null) {
+                try {
+                    is.close();
+                } catch(IOException ioe) {
+                    Log.w(LOGTAG, "I/O Exception while closing stream", ioe);
+                }
+            }
+            if (os != null) {
+                try {
+                    os.close();
+                } catch(IOException ioe) {
+                    Log.w(LOGTAG, "I/O Exception while closing stream", ioe);
+                }
+            }
+        }
+    }
+
+    private int getBitmapSampleSize(BitmapFactory.Options options, int idealWidth, int idealHeight) {
+        int width = options.outWidth;
+        int height = options.outHeight;
+        int inSampleSize = 1;
+        if (height > idealHeight || width > idealWidth) {
+            if (width > height) {
+                inSampleSize = Math.round((float)height / (float)idealHeight);
+            } else {
+                inSampleSize = Math.round((float)width / (float)idealWidth);
+            }
+        }
+        return inSampleSize;
+    }
+
+    private void hidePluginLayer(Layer layer) {
+        LayerView layerView = mLayerView;
+        layerView.removeLayer(layer);
+        layerView.requestRender();
+    }
+
+    private void showPluginLayer(Layer layer) {
+        LayerView layerView = mLayerView;
+        layerView.addLayer(layer);
+        layerView.requestRender();
+    }
+
+    public void requestRender() {
+        mLayerView.requestRender();
+    }
+    
+    public void hidePlugins(Tab tab) {
+        for (Layer layer : tab.getPluginLayers()) {
+            if (layer instanceof PluginLayer) {
+                ((PluginLayer) layer).setVisible(false);
+            }
+
+            hidePluginLayer(layer);
+        }
+
+        requestRender();
+    }
+
+    public void showPlugins() {
+        Tabs tabs = Tabs.getInstance();
+        Tab tab = tabs.getSelectedTab();
+
+        showPlugins(tab);
+    }
+
+    public void showPlugins(Tab tab) {
+        for (Layer layer : tab.getPluginLayers()) {
+            showPluginLayer(layer);
+
+            if (layer instanceof PluginLayer) {
+                ((PluginLayer) layer).setVisible(true);
+            }
+        }
+
+        requestRender();
+    }
+
+    public void setFullScreen(final boolean fullscreen) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                // Hide/show the system notification bar
+                Window window = getWindow();
+                window.setFlags(fullscreen ?
+                                WindowManager.LayoutParams.FLAG_FULLSCREEN : 0,
+                                WindowManager.LayoutParams.FLAG_FULLSCREEN);
+
+                if (Build.VERSION.SDK_INT >= 11)
+                    window.getDecorView().setSystemUiVisibility(fullscreen ? 1 : 0);
+            }
+        });
+    }
+
+    /**
+     * Check and start the Java profiler if MOZ_PROFILER_STARTUP env var is specified
+     **/
+    protected void earlyStartJavaSampler(Intent intent)
+    {
+        String env = intent.getStringExtra("env0");
+        for (int i = 1; env != null; i++) {
+            if (env.startsWith("MOZ_PROFILER_STARTUP=")) {
+                if (!env.endsWith("=")) {
+                    GeckoJavaSampler.start(10, 1000);
+                    Log.d(LOGTAG, "Profiling Java on startup");
+                }
+                break;
+            }
+            env = intent.getStringExtra("env" + i);
+        }
+    }
+
+    /**
+     * Called when the activity is first created.
+     *
+     * Here we initialize all of our profile settings, Firefox Health Report,
+     * and other one-shot constructions.
+     **/
+    @Override
+    public void onCreate(Bundle savedInstanceState)
+    {
+        GeckoAppShell.registerGlobalExceptionHandler();
+        Log.w(LOGTAG, "Cuong on created");
+        // Enable Android Strict Mode for developers' local builds (the "default" channel).
+        if ("default".equals(AppConstants.MOZ_UPDATE_CHANNEL)) {
+            enableStrictMode();
+        }
+
+        // The clock starts...now. Better hurry!
+        mJavaUiStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_JAVAUI");
+        mGeckoReadyStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_GECKOREADY");
+
+        Intent intent = getIntent();
+        String args = intent.getStringExtra("args");
+        earlyStartJavaSampler(intent);
+
+        if (mProfile == null) {
+            String profileName = null;
+            String profilePath = null;
+            if (args != null) {
+                if (args.contains("-P")) {
+                    Pattern p = Pattern.compile("(?:-P\\s*)(\\w*)(\\s*)");
+                    Matcher m = p.matcher(args);
+                    if (m.find()) {
+                        profileName = m.group(1);
+                    }
+                }
+
+                if (args.contains("-profile")) {
+                    Pattern p = Pattern.compile("(?:-profile\\s*)(\\S*)(\\s*)");
+                    Matcher m = p.matcher(args);
+                    if (m.find()) {
+                        profilePath =  m.group(1);
+                    }
+                    if (profileName == null) {
+                        try {
+                            profileName = getDefaultProfileName();
+                        } catch (NoMozillaDirectoryException e) {
+                            Log.wtf(LOGTAG, "Unable to fetch default profile name!", e);
+                            // There's nothing at all we can do now. If the Mozilla directory
+                            // didn't exist, then we're screwed.
+                            // Crash here so we can fix the bug.
+                            throw new RuntimeException(e);
+                        }
+                        if (profileName == null)
+                            profileName = GeckoProfile.DEFAULT_PROFILE;
+                    }
+                    GeckoProfile.sIsUsingCustomProfile = true;
+                }
+
+                if (profileName != null || profilePath != null) {
+                    mProfile = GeckoProfile.get(this, profileName, profilePath);
+                }
+            }
+        }
+
+        BrowserDB.initialize(getProfile().getName());
+
+        // Workaround for <http://code.google.com/p/android/issues/detail?id=20915>.
+        try {
+            Class.forName("android.os.AsyncTask");
+        } catch (ClassNotFoundException e) {}
+
+        MemoryMonitor.getInstance().init(getApplicationContext());
+
+        sAppContext = this;
+        GeckoAppShell.setContextGetter(this);
+        GeckoAppShell.setGeckoInterface(this);
+        ThreadUtils.setUiThread(Thread.currentThread(), new Handler());
+
+        Tabs.getInstance().attachToContext(this);
+        try {
+            Favicons.attachToContext(this);
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Exception starting favicon cache. Corrupt resources?", e);
+        }
+
+        // Did the OS locale change while we were backgrounded? If so,
+        // we need to die so that Gecko will re-init add-ons that touch
+        // the UI.
+        // This is using a sledgehammer to crack a nut, but it'll do for
+        // now.
+        if (LocaleManager.systemLocaleDidChange()) {
+            Log.i(LOGTAG, "System locale changed. Restarting.");
+            doRestart();
+            GeckoAppShell.systemExit();
+            return;
+        }
+
+        if (GeckoThread.isCreated()) {
+            // This happens when the GeckoApp activity is destroyed by Android
+            // without killing the entire application (see Bug 769269).
+            mIsRestoringActivity = true;
+            Telemetry.HistogramAdd("FENNEC_RESTORING_ACTIVITY", 1);
+        }
+
+        // Fix for Bug 830557 on Tegra boards running Froyo.
+        // This fix must be done before doing layout.
+        // Assume the bug is fixed in Gingerbread and up.
+        if (Build.VERSION.SDK_INT < 9) {
+            try {
+                Class<?> inputBindResultClass =
+                    Class.forName("com.android.internal.view.InputBindResult");
+                java.lang.reflect.Field creatorField =
+                    inputBindResultClass.getField("CREATOR");
+                Log.i(LOGTAG, "froyo startup fix: " + String.valueOf(creatorField.get(null)));
+            } catch (Exception e) {
+                Log.w(LOGTAG, "froyo startup fix failed", e);
+            }
+        }
+
+        Bundle stateBundle = getIntent().getBundleExtra(EXTRA_STATE_BUNDLE);
+        if (stateBundle != null) {
+            // Use the state bundle if it was given as an intent extra. This is
+            // only intended to be used internally via Robocop, so a boolean
+            // is read from a private shared pref to prevent other apps from
+            // injecting states.
+            SharedPreferences prefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
+            if (prefs.getBoolean(PREFS_ALLOW_STATE_BUNDLE, false)) {
+                Log.i(LOGTAG, "Restoring state from intent bundle");
+                prefs.edit().remove(PREFS_ALLOW_STATE_BUNDLE).commit();
+                savedInstanceState = stateBundle;
+            }
+        } else if (savedInstanceState != null) {
+            // Bug 896992 - This intent has already been handled; reset the intent.
+            setIntent(new Intent(Intent.ACTION_MAIN));
+        }
+
+        super.onCreate(savedInstanceState);
+
+        GeckoScreenOrientation.getInstance().update(getResources().getConfiguration().orientation);
+
+        setContentView(getLayout());
+
+        // Set up Gecko layout.
+        mGeckoLayout = (RelativeLayout) findViewById(R.id.gecko_layout);
+        mMainLayout = (RelativeLayout) findViewById(R.id.main_layout);
+
+        // Determine whether we should restore tabs.
+        mShouldRestore = getSessionRestoreState(savedInstanceState);
+        if (mShouldRestore && savedInstanceState != null) {
+            boolean wasInBackground =
+                savedInstanceState.getBoolean(SAVED_STATE_IN_BACKGROUND, false);
+
+            // Don't log OOM-kills if only one activity was destroyed. (For example
+            // from "Don't keep activities" on ICS)
+            if (!wasInBackground && !mIsRestoringActivity) {
+                Telemetry.HistogramAdd("FENNEC_WAS_KILLED", 1);
+            }
+
+            mPrivateBrowsingSession = savedInstanceState.getString(SAVED_STATE_PRIVATE_SESSION);
+        }
+
+        // Perform background initialization.
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                final SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+
+                // Wait until now to set this, because we'd rather throw an exception than 
+                // have a caller of LocaleManager regress startup.
+                LocaleManager.setContextGetter(GeckoApp.this);
+                LocaleManager.initialize();
+
+                SessionInformation previousSession = SessionInformation.fromSharedPrefs(prefs);
+                if (previousSession.wasKilled()) {
+                    Telemetry.HistogramAdd("FENNEC_WAS_KILLED", 1);
+                }
+
+                SharedPreferences.Editor editor = prefs.edit();
+                editor.putBoolean(GeckoApp.PREFS_OOM_EXCEPTION, false);
+
+                // Put a flag to check if we got a normal `onSaveInstanceState`
+                // on exit, or if we were suddenly killed (crash or native OOM).
+                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
+
+                editor.commit();
+
+                // The lifecycle of mHealthRecorder is "shortly after onCreate"
+                // through "onDestroy" -- essentially the same as the lifecycle
+                // of the activity itself.
+                final String profilePath = getProfile().getDir().getAbsolutePath();
+                final EventDispatcher dispatcher = GeckoAppShell.getEventDispatcher();
+                Log.i(LOGTAG, "Creating HealthRecorder.");
+
+                final String osLocale = Locale.getDefault().toString();
+                String appLocale = LocaleManager.getAndApplyPersistedLocale();
+                Log.d(LOGTAG, "OS locale is " + osLocale + ", app locale is " + appLocale);
+
+                if (appLocale == null) {
+                    appLocale = osLocale;
+                }
+
+                mHealthRecorder = GeckoApp.this.createHealthRecorder(GeckoApp.this,
+                                                                     profilePath,
+                                                                     dispatcher,
+                                                                     osLocale,
+                                                                     appLocale,
+                                                                     previousSession);
+
+                final String uiLocale = appLocale;
+                ThreadUtils.postToUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        GeckoApp.this.onLocaleReady(uiLocale);
+                    }
+                });
+            }
+        });
+
+        GeckoAppShell.setNotificationClient(makeNotificationClient());
+        NotificationHelper.init(getApplicationContext());
+    }
+
+    /**
+     * At this point, the resource system and the rest of the browser are
+     * aware of the locale.
+     *
+     * Now we can display strings!
+     */
+    @Override
+    public void onLocaleReady(final String locale) {
+        if (!ThreadUtils.isOnUiThread()) {
+            throw new RuntimeException("onLocaleReady must always be called from the UI thread.");
+        }
+
+        // The URL bar hint needs to be populated.
+        TextView urlBar = (TextView) findViewById(R.id.url_bar_title);
+        if (urlBar == null) {
+            return;
+        }
+        final String hint = getResources().getString(R.string.url_bar_default_text);
+        urlBar.setHint(hint);
+
+        // Allow onConfigurationChanged to take care of the rest.
+        onConfigurationChanged(getResources().getConfiguration());
+    }
+
+    protected void initializeChrome() {
+        mDoorHangerPopup = new DoorHangerPopup(this);
+        mPluginContainer = (AbsoluteLayout) findViewById(R.id.plugin_container);
+        mFormAssistPopup = (FormAssistPopup) findViewById(R.id.form_assist_popup);
+
+        if (mCameraView == null) {
+            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+                mCameraView = new SurfaceView(this);
+                ((SurfaceView)mCameraView).getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+            } else {
+                mCameraView = new TextureView(this);
+            }
+        }
+
+        if (mLayerView == null) {
+            LayerView layerView = (LayerView) findViewById(R.id.layer_view);
+            layerView.initializeView(GeckoAppShell.getEventDispatcher());
+            mLayerView = layerView;
+            GeckoAppShell.setLayerView(layerView);
+            // bind the GeckoEditable instance to the new LayerView
+            GeckoAppShell.notifyIMEContext(GeckoEditableListener.IME_STATE_DISABLED, "", "", "");
+        }
+    }
+
+    /**
+     * Loads the initial tab at Fennec startup.
+     *
+     * If Fennec was opened with an external URL, that URL will be loaded.
+     * Otherwise, unless there was a session restore, the default URL
+     * (about:home) be loaded.
+     *
+     * @param url External URL to load, or null to load the default URL
+     */
+    protected void loadStartupTab(String url) {
+        if (url == null) {
+            if (!mShouldRestore) {
+                // Show about:home if we aren't restoring previous session and
+                // there's no external URL.
+                Tabs.getInstance().loadUrl(AboutPages.HOME, Tabs.LOADURL_NEW_TAB);
+            }
+        } else {
+            // If given an external URL, load it
+            int flags = Tabs.LOADURL_NEW_TAB | Tabs.LOADURL_USER_ENTERED | Tabs.LOADURL_EXTERNAL;
+            Tabs.getInstance().loadUrl(url, flags);
+        }
+    }
+
+    private void initialize() {
+        mInitialized = true;
+
+        Intent intent = getIntent();
+        String action = intent.getAction();
+
+        String passedUri = null;
+        final String uri = getURIFromIntent(intent);
+        if (!TextUtils.isEmpty(uri)) {
+            passedUri = uri;
+        }
+
+        final boolean isExternalURL = passedUri != null &&
+                                      !AboutPages.isAboutHome(passedUri);
+        StartupAction startupAction;
+        if (isExternalURL) {
+            startupAction = StartupAction.URL;
+        } else {
+            startupAction = StartupAction.NORMAL;
+        }
+
+        // Start migrating as early as possible, can do this in
+        // parallel with Gecko load.
+        checkMigrateProfile();
+
+        Uri data = intent.getData();
+        if (data != null && "http".equals(data.getScheme())) {
+            startupAction = StartupAction.PREFETCH;
+            ThreadUtils.postToBackgroundThread(new PrefetchRunnable(data.toString()));
+        }
+
+        Tabs.registerOnTabsChangedListener(this);
+
+        initializeChrome();
+
+        // If we are doing a restore, read the session data and send it to Gecko
+        if (!mIsRestoringActivity) {
+            String restoreMessage = null;
+            if (mShouldRestore) {
+                try {
+                    // restoreSessionTabs() will create simple tab stubs with the
+                    // URL and title for each page, but we also need to restore
+                    // session history. restoreSessionTabs() will inject the IDs
+                    // of the tab stubs into the JSON data (which holds the session
+                    // history). This JSON data is then sent to Gecko so session
+                    // history can be restored for each tab.
+                    restoreMessage = restoreSessionTabs(isExternalURL);
+                } catch (SessionRestoreException e) {
+                    // If restore failed, do a normal startup
+                    Log.e(LOGTAG, "An error occurred during restore", e);
+                    mShouldRestore = false;
+                }
+            }
+
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Session:Restore", restoreMessage));
+        }
+
+        // External URLs should always be loaded regardless of whether Gecko is
+        // already running.
+        if (isExternalURL) {
+            loadStartupTab(passedUri);
+        } else if (!mIsRestoringActivity) {
+            loadStartupTab(null);
+        }
+
+        // We now have tab stubs from the last session. Any future tabs should
+        // be animated.
+        Tabs.getInstance().notifyListeners(null, Tabs.TabEvents.RESTORED);
+
+        // If we're not restoring, move the session file so it can be read for
+        // the last tabs section.
+        if (!mShouldRestore) {
+            getProfile().moveSessionFile();
+        }
+
+        Telemetry.HistogramAdd("FENNEC_STARTUP_GECKOAPP_ACTION", startupAction.ordinal());
+
+        if (!mIsRestoringActivity) {
+            GeckoThread.setArgs(intent.getStringExtra("args"));
+            GeckoThread.setAction(intent.getAction());
+            GeckoThread.setUri(passedUri);
+        }
+        if (!ACTION_DEBUG.equals(action) &&
+            GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.Launching, GeckoThread.LaunchState.Launched)) {
+            GeckoThread.createAndStart();
+        } else if (ACTION_DEBUG.equals(action) &&
+            GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.Launching, GeckoThread.LaunchState.WaitForDebugger)) {
+            ThreadUtils.getUiHandler().postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    GeckoThread.setLaunchState(GeckoThread.LaunchState.Launching);
+                    GeckoThread.createAndStart();
+                }
+            }, 1000 * 5 /* 5 seconds */);
+        }
+
+        // Check if launched from data reporting notification.
+        if (ACTION_LAUNCH_SETTINGS.equals(action)) {
+            Intent settingsIntent = new Intent(GeckoApp.this, GeckoPreferences.class);
+            // Copy extras.
+            settingsIntent.putExtras(intent);
+            startActivity(settingsIntent);
+        }
+
+        //app state callbacks
+        mAppStateListeners = new LinkedList<GeckoAppShell.AppStateListener>();
+
+        //register for events
+        registerEventListener("log");
+        registerEventListener("Reader:ListCountRequest");
+        registerEventListener("Reader:ListStatusRequest");
+        registerEventListener("Reader:Added");
+        registerEventListener("Reader:Removed");
+        registerEventListener("Reader:Share");
+        registerEventListener("Reader:FaviconRequest");
+        registerEventListener("onCameraCapture");
+        registerEventListener("Gecko:Ready");
+        registerEventListener("Gecko:DelayedStartup");
+        registerEventListener("Toast:Show");
+        registerEventListener("DOMFullScreen:Start");
+        registerEventListener("DOMFullScreen:Stop");
+        registerEventListener("ToggleChrome:Hide");
+        registerEventListener("ToggleChrome:Show");
+        registerEventListener("ToggleChrome:Focus");
+        registerEventListener("Permissions:Data");
+        registerEventListener("Session:StatePurged");
+        registerEventListener("Bookmark:Insert");
+        registerEventListener("Accessibility:Event");
+        registerEventListener("Accessibility:Ready");
+        registerEventListener("Shortcut:Remove");
+        registerEventListener("Share:Text");
+        registerEventListener("Share:Image");
+        registerEventListener("Image:SetAs");
+        registerEventListener("Sanitize:ClearHistory");
+        registerEventListener("Update:Check");
+        registerEventListener("Update:Download");
+        registerEventListener("Update:Install");
+        registerEventListener("PrivateBrowsing:Data");
+        registerEventListener("Contact:Add");
+        registerEventListener("Intent:Open");
+        registerEventListener("Intent:OpenForResult");
+        registerEventListener("Intent:GetHandlers");
+        registerEventListener("Locale:Set");
+        registerEventListener("NativeApp:IsDebuggable");
+        registerEventListener("SystemUI:Visibility");
+
+        EventListener.registerEvents();
+
+        if (SmsManager.getInstance() != null) {
+          SmsManager.getInstance().start();
+        }
+
+        mContactService = new ContactService(GeckoAppShell.getEventDispatcher(), this);
+
+        mPromptService = new PromptService(this);
+
+        mTextSelection = new TextSelection((TextSelectionHandle) findViewById(R.id.start_handle),
+                                           (TextSelectionHandle) findViewById(R.id.middle_handle),
+                                           (TextSelectionHandle) findViewById(R.id.end_handle),
+                                           GeckoAppShell.getEventDispatcher(),
+                                           this);
+
+        PrefsHelper.getPref("app.update.autodownload", new PrefsHelper.PrefHandlerBase() {
+            @Override public void prefValue(String pref, String value) {
+                UpdateServiceHelper.registerForUpdates(GeckoApp.this, value);
+            }
+        });
+
+        PrefsHelper.getPref("app.geo.reportdata", new PrefsHelper.PrefHandlerBase() {
+            @Override public void prefValue(String pref, int value) {
+                if (value == 1)
+                    mShouldReportGeoData = true;
+                else
+                    mShouldReportGeoData = false;
+            }
+        });
+
+        // Trigger the completion of the telemetry timer that wraps activity startup,
+        // then grab the duration to give to FHR.
+        mJavaUiStartupTimer.stop();
+        final long javaDuration = mJavaUiStartupTimer.getElapsed();
+
+        ThreadUtils.getBackgroundHandler().postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                final HealthRecorder rec = mHealthRecorder;
+                if (rec != null) {
+                    rec.recordJavaStartupTime(javaDuration);
+                }
+
+                // Record our launch time for the announcements service
+                // to use in assessing inactivity.
+                final Context context = GeckoApp.this;
+                AnnouncementsBroadcastService.recordLastLaunch(context);
+
+                // Kick off our background services. We do this by invoking the broadcast
+                // receiver, which uses the system alarm infrastructure to perform tasks at
+                // intervals.
+                GeckoPreferences.broadcastAnnouncementsPref(context);
+                GeckoPreferences.broadcastHealthReportUploadPref(context);
+                if (!GeckoThread.checkLaunchState(GeckoThread.LaunchState.Launched)) {
+                    return;
+                }
+            }
+        }, 50);
+
+        if (mIsRestoringActivity) {
+            GeckoThread.setLaunchState(GeckoThread.LaunchState.GeckoRunning);
+            Tab selectedTab = Tabs.getInstance().getSelectedTab();
+            if (selectedTab != null)
+                Tabs.getInstance().notifyListeners(selectedTab, Tabs.TabEvents.SELECTED);
+            geckoConnected();
+            GeckoAppShell.setLayerClient(mLayerView.getLayerClient());
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Viewport:Flush", null));
+        }
+
+        if (ACTION_ALERT_CALLBACK.equals(action)) {
+            processAlertCallback(intent);
+        }
+    }
+
+    private String restoreSessionTabs(final boolean isExternalURL) throws SessionRestoreException {
+        try {
+            String sessionString = getProfile().readSessionFile(false);
+            if (sessionString == null) {
+                throw new SessionRestoreException("Could not read from session file");
+            }
+
+            // If we are doing an OOM restore, parse the session data and
+            // stub the restored tabs immediately. This allows the UI to be
+            // updated before Gecko has restored.
+            if (mShouldRestore) {
+                final JSONArray tabs = new JSONArray();
+                SessionParser parser = new SessionParser() {
+                    @Override
+                    public void onTabRead(SessionTab sessionTab) {
+                        JSONObject tabObject = sessionTab.getTabObject();
+
+                        int flags = Tabs.LOADURL_NEW_TAB;
+                        flags |= ((isExternalURL || !sessionTab.isSelected()) ? Tabs.LOADURL_DELAY_LOAD : 0);
+                        flags |= (tabObject.optBoolean("desktopMode") ? Tabs.LOADURL_DESKTOP : 0);
+                        flags |= (tabObject.optBoolean("isPrivate") ? Tabs.LOADURL_PRIVATE : 0);
+
+                        Tab tab = Tabs.getInstance().loadUrl(sessionTab.getUrl(), flags);
+                        tab.updateTitle(sessionTab.getTitle());
+
+                        try {
+                            tabObject.put("tabId", tab.getId());
+                        } catch (JSONException e) {
+                            Log.e(LOGTAG, "JSON error", e);
+                        }
+                        tabs.put(tabObject);
+                    }
+                };
+
+                if (mPrivateBrowsingSession == null) {
+                    parser.parse(sessionString);
+                } else {
+                    parser.parse(sessionString, mPrivateBrowsingSession);
+                }
+
+                if (tabs.length() > 0) {
+                    sessionString = new JSONObject().put("windows", new JSONArray().put(new JSONObject().put("tabs", tabs))).toString();
+                } else {
+                    throw new SessionRestoreException("No tabs could be read from session file");
+                }
+            }
+
+            JSONObject restoreData = new JSONObject();
+            restoreData.put("sessionString", sessionString);
+            return restoreData.toString();
+
+        } catch (JSONException e) {
+            throw new SessionRestoreException(e);
+        }
+    }
+
+    public GeckoProfile getProfile() {
+        // fall back to default profile if we didn't load a specific one
+        if (mProfile == null) {
+            mProfile = GeckoProfile.get(this);
+        }
+        return mProfile;
+    }
+
+    /**
+     * Determine whether the session should be restored.
+     *
+     * @param savedInstanceState Saved instance state given to the activity
+     * @return                   Whether to restore
+     */
+    protected boolean getSessionRestoreState(Bundle savedInstanceState) {
+        final SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+        boolean shouldRestore = false;
+
+        final int versionCode = getVersionCode();
+        if (prefs.getInt(PREFS_VERSION_CODE, 0) != versionCode) {
+            // If the version has changed, the user has done an upgrade, so restore
+            // previous tabs.
+            ThreadUtils.postToBackgroundThread(new Runnable() {
+                @Override
+                public void run() {
+                    prefs.edit()
+                         .putInt(PREFS_VERSION_CODE, versionCode)
+                         .commit();
+                }
+            });
+
+            shouldRestore = true;
+        } else if (savedInstanceState != null || getSessionRestorePreference().equals("always") || getRestartFromIntent()) {
+            // We're coming back from a background kill by the OS, the user
+            // has chosen to always restore, or we just restarted.
+            shouldRestore = true;
+        }
+
+        return shouldRestore;
+    }
+
+    private String getSessionRestorePreference() {
+        return PreferenceManager.getDefaultSharedPreferences(this)
+                                .getString(GeckoPreferences.PREFS_RESTORE_SESSION, "quit");
+    }
+
+    private boolean getRestartFromIntent() {
+        return getIntent().getBooleanExtra("didRestart", false);
+    }
+
+    /**
+     * Enable Android StrictMode checks (for supported OS versions).
+     * http://developer.android.com/reference/android/os/StrictMode.html
+     */
+    private void enableStrictMode() {
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
+            return;
+        }
+
+        Log.d(LOGTAG, "Enabling Android StrictMode");
+
+        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
+                                  .detectAll()
+                                  .penaltyLog()
+                                  .build());
+
+        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
+                               .detectAll()
+                               .penaltyLog()
+                               .build());
+    }
+
+    public void enableCameraView() {
+        // Start listening for orientation events
+        mCameraOrientationEventListener = new OrientationEventListener(this) {
+            @Override
+            public void onOrientationChanged(int orientation) {
+                if (mAppStateListeners != null) {
+                    for (GeckoAppShell.AppStateListener listener: mAppStateListeners) {
+                        listener.onOrientationChanged();
+                    }
+                }
+            }
+        };
+        mCameraOrientationEventListener.enable();
+
+        // Try to make it fully transparent.
+        if (mCameraView instanceof SurfaceView) {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+                mCameraView.setAlpha(0.0f);
+            }
+        } else if (mCameraView instanceof TextureView) {
+            mCameraView.setAlpha(0.0f);
+        }
+        RelativeLayout mCameraLayout = (RelativeLayout) findViewById(R.id.camera_layout);
+        // Some phones (eg. nexus S) need at least a 8x16 preview size
+        mCameraLayout.addView(mCameraView,
+                              new AbsoluteLayout.LayoutParams(8, 16, 0, 0));
+    }
+
+    public void disableCameraView() {
+        if (mCameraOrientationEventListener != null) {
+            mCameraOrientationEventListener.disable();
+            mCameraOrientationEventListener = null;
+        }
+        RelativeLayout mCameraLayout = (RelativeLayout) findViewById(R.id.camera_layout);
+        mCameraLayout.removeView(mCameraView);
+    }
+
+    public String getDefaultUAString() {
+        return HardwareUtils.isTablet() ? AppConstants.USER_AGENT_FENNEC_TABLET :
+                                          AppConstants.USER_AGENT_FENNEC_MOBILE;
+    }
+
+    public String getUAStringForHost(String host) {
+        // With our standard UA String, we get a 200 response code and
+        // client-side redirect from t.co. This bot-like UA gives us a
+        // 301 response code
+        if ("t.co".equals(host)) {
+            return AppConstants.USER_AGENT_BOT_LIKE;
+        }
+        return getDefaultUAString();
+    }
+
+    class PrefetchRunnable implements Runnable {
+        private String mPrefetchUrl;
+
+        PrefetchRunnable(String prefetchUrl) {
+            mPrefetchUrl = prefetchUrl;
+        }
+
+        @Override
+        public void run() {
+            HttpURLConnection connection = null;
+            try {
+                URL url = new URL(mPrefetchUrl);
+                // data url should have an http scheme
+                connection = (HttpURLConnection) url.openConnection();
+                connection.setRequestProperty("User-Agent", getUAStringForHost(url.getHost()));
+                connection.setInstanceFollowRedirects(false);
+                connection.setRequestMethod("GET");
+                connection.connect();
+            } catch (Exception e) {
+                Log.e(LOGTAG, "Exception prefetching URL", e);
+            } finally {
+                if (connection != null)
+                    connection.disconnect();
+            }
+        }
+    }
+
+    private void processAlertCallback(Intent intent) {
+        String alertName = "";
+        String alertCookie = "";
+        Uri data = intent.getData();
+        if (data != null) {
+            alertName = data.getQueryParameter("name");
+            if (alertName == null)
+                alertName = "";
+            alertCookie = data.getQueryParameter("cookie");
+            if (alertCookie == null)
+                alertCookie = "";
+        }
+        handleNotification(ACTION_ALERT_CALLBACK, alertName, alertCookie);
+    }
+
+    @Override
+    protected void onNewIntent(Intent intent) {
+        if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoExiting)) {
+            // We're exiting and shouldn't try to do anything else. In the case
+            // where we are hung while exiting, we should force the process to exit.
+            GeckoAppShell.systemExit();
+            return;
+        }
+
+        // if we were previously OOM killed, we can end up here when launching
+        // from external shortcuts, so set this as the intent for initialization
+        if (!mInitialized) {
+            setIntent(intent);
+            return;
+        }
+
+        final String action = intent.getAction();
+
+        if (ACTION_LOAD.equals(action)) {
+            String uri = intent.getDataString();
+            Tabs.getInstance().loadUrl(uri);
+        } else if (Intent.ACTION_VIEW.equals(action)) {
+            String uri = intent.getDataString();
+            Tabs.getInstance().loadUrl(uri, Tabs.LOADURL_NEW_TAB |
+                                            Tabs.LOADURL_USER_ENTERED |
+                                            Tabs.LOADURL_EXTERNAL);
+        } else if (action != null && action.startsWith(ACTION_WEBAPP_PREFIX)) {
+            // A lightweight mechanism for loading a web page as a webapp
+            // without installing the app natively nor registering it in the DOM
+            // application registry.
+            String uri = getURIFromIntent(intent);
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createWebappLoadEvent(uri));
+        } else if (ACTION_BOOKMARK.equals(action)) {
+            String uri = getURIFromIntent(intent);
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBookmarkLoadEvent(uri));
+        } else if (Intent.ACTION_SEARCH.equals(action)) {
+            String uri = getURIFromIntent(intent);
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createURILoadEvent(uri));
+        } else if (ACTION_ALERT_CALLBACK.equals(action)) {
+            processAlertCallback(intent);
+        } else if (ACTION_LAUNCH_SETTINGS.equals(action)) {
+            // Check if launched from data reporting notification.
+            Intent settingsIntent = new Intent(GeckoApp.this, GeckoPreferences.class);
+            // Copy extras.
+            settingsIntent.putExtras(intent);
+            startActivity(settingsIntent);
+        }
+    }
+
+    /*
+     * Handles getting a uri from and intent in a way that is backwards
+     * compatable with our previous implementations
+     */
+    protected String getURIFromIntent(Intent intent) {
+        final String action = intent.getAction();
+        if (ACTION_ALERT_CALLBACK.equals(action))
+            return null;
+
+        String uri = intent.getDataString();
+        if (uri != null)
+            return uri;
+
+        if ((action != null && action.startsWith(ACTION_WEBAPP_PREFIX)) || ACTION_BOOKMARK.equals(action)) {
+            uri = intent.getStringExtra("args");
+            if (uri != null && uri.startsWith("--url=")) {
+                uri.replace("--url=", "");
+            }
+        }
+        return uri;
+    }
+
+    protected int getOrientation() {
+        return GeckoScreenOrientation.getInstance().getAndroidOrientation();
+    }
+
+    @Override
+    public void onResume()
+    {
+        // After an onPause, the activity is back in the foreground.
+        // Undo whatever we did in onPause.
+        super.onResume();
+
+        int newOrientation = getResources().getConfiguration().orientation;
+        if (GeckoScreenOrientation.getInstance().update(newOrientation)) {
+            refreshChrome();
+        }
+
+        // User may have enabled/disabled accessibility.
+        GeckoAccessibility.updateAccessibilitySettings(this);
+
+        if (mAppStateListeners != null) {
+            for (GeckoAppShell.AppStateListener listener: mAppStateListeners) {
+                listener.onResume();
+            }
+        }
+
+        // We use two times: a pseudo-unique wall-clock time to identify the
+        // current session across power cycles, and the elapsed realtime to
+        // track the duration of the session.
+        final long now = System.currentTimeMillis();
+        final long realTime = android.os.SystemClock.elapsedRealtime();
+
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                // Now construct the new session on HealthRecorder's behalf. We do this here
+                // so it can benefit from a single near-startup prefs commit.
+                SessionInformation currentSession = new SessionInformation(now, realTime);
+
+                SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+                SharedPreferences.Editor editor = prefs.edit();
+                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
+                currentSession.recordBegin(editor);
+                editor.commit();
+
+                final HealthRecorder rec = mHealthRecorder;
+                if (rec != null) {
+                    rec.setCurrentSession(currentSession);
+                } else {
+                    Log.w(LOGTAG, "Can't record session: rec is null.");
+                }
+            }
+         });
+    }
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+
+        if (!mInitialized && hasFocus) {
+            initialize();
+            getWindow().setBackgroundDrawable(null);
+        }
+    }
+
+    @Override
+    public void onPause()
+    {
+        final HealthRecorder rec = mHealthRecorder;
+        final Context context = this;
+
+        // In some way it's sad that Android will trigger StrictMode warnings
+        // here as the whole point is to save to disk while the activity is not
+        // interacting with the user.
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+                SharedPreferences.Editor editor = prefs.edit();
+                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, true);
+                if (rec != null) {
+                    rec.recordSessionEnd("P", editor);
+                }
+
+                // If we haven't done it before, cleanup any old files in our old temp dir
+                if (prefs.getBoolean(GeckoApp.PREFS_CLEANUP_TEMP_FILES, true)) {
+                    File tempDir = GeckoLoader.getGREDir(GeckoApp.this);
+                    FileUtils.delTree(tempDir, new FileUtils.NameAndAgeFilter(null, ONE_DAY_MS), false);
+
+                    editor.putBoolean(GeckoApp.PREFS_CLEANUP_TEMP_FILES, false);
+                }
+
+                editor.commit();
+
+                // In theory, the first browser session will not run long enough that we need to
+                // prune during it and we'd rather run it when the browser is inactive so we wait
+                // until here to register the prune service.
+                GeckoPreferences.broadcastHealthReportPrune(context);
+            }
+        });
+
+        if (mAppStateListeners != null) {
+            for(GeckoAppShell.AppStateListener listener: mAppStateListeners) {
+                listener.onPause();
+            }
+        }
+
+        super.onPause();
+    }
+
+    @Override
+    public void onRestart()
+    {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+                SharedPreferences.Editor editor = prefs.edit();
+                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
+                editor.commit();
+            }
+        });
+
+        super.onRestart();
+    }
+
+    @Override
+    public void onDestroy()
+    {
+        unregisterEventListener("log");
+        unregisterEventListener("Reader:ListCountRequest");
+        unregisterEventListener("Reader:ListStatusRequest");
+        unregisterEventListener("Reader:Added");
+        unregisterEventListener("Reader:Removed");
+        unregisterEventListener("Reader:Share");
+        unregisterEventListener("Reader:FaviconRequest");
+        unregisterEventListener("onCameraCapture");
+        unregisterEventListener("Gecko:Ready");
+        unregisterEventListener("Gecko:DelayedStartup");
+        unregisterEventListener("Toast:Show");
+        unregisterEventListener("DOMFullScreen:Start");
+        unregisterEventListener("DOMFullScreen:Stop");
+        unregisterEventListener("ToggleChrome:Hide");
+        unregisterEventListener("ToggleChrome:Show");
+        unregisterEventListener("ToggleChrome:Focus");
+        unregisterEventListener("Permissions:Data");
+        unregisterEventListener("Session:StatePurged");
+        unregisterEventListener("Bookmark:Insert");
+        unregisterEventListener("Accessibility:Event");
+        unregisterEventListener("Accessibility:Ready");
+        unregisterEventListener("Shortcut:Remove");
+        unregisterEventListener("Share:Text");
+        unregisterEventListener("Share:Image");
+        unregisterEventListener("Image:SetAs");
+        unregisterEventListener("Sanitize:ClearHistory");
+        unregisterEventListener("Update:Check");
+        unregisterEventListener("Update:Download");
+        unregisterEventListener("Update:Install");
+        unregisterEventListener("PrivateBrowsing:Data");
+        unregisterEventListener("Contact:Add");
+        unregisterEventListener("Intent:Open");
+        unregisterEventListener("Intent:GetHandlers");
+        unregisterEventListener("Locale:Set");
+        unregisterEventListener("NativeApp:IsDebuggable");
+        unregisterEventListener("SystemUI:Visibility");
+
+        EventListener.unregisterEvents();
+
+        deleteTempFiles();
+
+        if (mLayerView != null)
+            mLayerView.destroy();
+        if (mDoorHangerPopup != null)
+            mDoorHangerPopup.destroy();
+        if (mFormAssistPopup != null)
+            mFormAssistPopup.destroy();
+        if (mContactService != null)
+            mContactService.destroy();
+        if (mPromptService != null)
+            mPromptService.destroy();
+        if (mTextSelection != null)
+            mTextSelection.destroy();
+        NotificationHelper.destroy();
+
+        if (SmsManager.getInstance() != null) {
+            SmsManager.getInstance().stop();
+            if (isFinishing())
+                SmsManager.getInstance().shutdown();
+        }
+
+        final HealthRecorder rec = mHealthRecorder;
+        mHealthRecorder = null;
+        if (rec != null && rec.isEnabled()) {
+            // Closing a BrowserHealthRecorder could incur a write.
+            ThreadUtils.postToBackgroundThread(new Runnable() {
+                @Override
+                public void run() {
+                    rec.close();
+                }
+            });
+        }
+
+        Favicons.close();
+
+        super.onDestroy();
+
+        Tabs.unregisterOnTabsChangedListener(this);
+    }
+
+    protected void registerEventListener(String event) {
+        GeckoAppShell.getEventDispatcher().registerEventListener(event, this);
+    }
+
+    protected void unregisterEventListener(String event) {
+        GeckoAppShell.getEventDispatcher().unregisterEventListener(event, this);
+    }
+
+    // Get a temporary directory, may return null
+    public static File getTempDirectory() {
+        File dir = sAppContext.getExternalFilesDir("temp");
+        return dir;
+    }
+
+    // Delete any files in our temporary directory
+    public static void deleteTempFiles() {
+        File dir = getTempDirectory();
+        if (dir == null)
+            return;
+        File[] files = dir.listFiles();
+        if (files == null)
+            return;
+        for (File file : files) {
+            file.delete();
+        }
+    }
+
+    @Override
+    public void onConfigurationChanged(Configuration newConfig) {
+        Log.d(LOGTAG, "onConfigurationChanged: " + newConfig.locale);
+        LocaleManager.correctLocale(getResources(), newConfig);
+
+        // onConfigurationChanged is not called for 180 degree orientation changes,
+        // we will miss such rotations and the screen orientation will not be
+        // updated.
+        if (GeckoScreenOrientation.getInstance().update(newConfig.orientation)) {
+            if (mFormAssistPopup != null)
+                mFormAssistPopup.hide();
+            refreshChrome();
+        }
+        super.onConfigurationChanged(newConfig);
+    }
+
+    public String getContentProcessName() {
+        return AppConstants.MOZ_CHILD_PROCESS_NAME;
+    }
+
+    public void addEnvToIntent(Intent intent) {
+        Map<String,String> envMap = System.getenv();
+        Set<Map.Entry<String,String>> envSet = envMap.entrySet();
+        Iterator<Map.Entry<String,String>> envIter = envSet.iterator();
+        int c = 0;
+        while (envIter.hasNext()) {
+            Map.Entry<String,String> entry = envIter.next();
+            intent.putExtra("env" + c, entry.getKey() + "="
+                            + entry.getValue());
+            c++;
+        }
+    }
+
+    public void doRestart() {
+        doRestart(RESTARTER_ACTION, null);
+    }
+
+    public void doRestart(String args) {
+        doRestart(RESTARTER_ACTION, args);
+    }
+
+    public void doRestart(String action, String args) {
+        Log.d(LOGTAG, "doRestart(\"" + action + "\")");
+        try {
+            Intent intent = new Intent(action);
+            intent.setClassName(AppConstants.ANDROID_PACKAGE_NAME, RESTARTER_CLASS);
+            /* TODO: addEnvToIntent(intent); */
+            if (args != null)
+                intent.putExtra("args", args);
+            intent.putExtra("didRestart", true);
+            Log.d(LOGTAG, "Restart intent: " + intent.toString());
+            GeckoAppShell.killAnyZombies();
+            startActivity(intent);
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Error effecting restart.", e);
+        }
+
+        finish();
+        // Give the restart process time to start before we die
+        GeckoAppShell.waitForAnotherGeckoProc();
+    }
+
+    public void handleNotification(String action, String alertName, String alertCookie) {
+        // If Gecko isn't running yet, we ignore the notification. Note that
+        // even if Gecko is running but it was restarted since the notification
+        // was created, the notification won't be handled (bug 849653).
+        if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoRunning)) {
+            GeckoAppShell.handleNotification(action, alertName, alertCookie);
+        }
+    }
+
+    private void checkMigrateProfile() {
+        final File profileDir = getProfile().getDir();
+
+        if (profileDir != null) {
+            final GeckoApp app = GeckoApp.sAppContext;
+
+            ThreadUtils.postToBackgroundThread(new Runnable() {
+                @Override
+                public void run() {
+                    Handler handler = new Handler();
+                    handler.postDelayed(new DeferredCleanupTask(), CLEANUP_DEFERRAL_SECONDS * 1000);
+                }
+            });
+        }
+    }
+
+    private class DeferredCleanupTask implements Runnable {
+        // The cleanup-version setting is recorded to avoid repeating the same
+        // tasks on subsequent startups; CURRENT_CLEANUP_VERSION may be updated
+        // if we need to do additional cleanup for future Gecko versions.
+
+        private static final String CLEANUP_VERSION = "cleanup-version";
+        private static final int CURRENT_CLEANUP_VERSION = 1;
+
+        @Override
+        public void run() {
+            long cleanupVersion = getAppSharedPreferences().getInt(CLEANUP_VERSION, 0);
+
+            if (cleanupVersion < 1) {
+                // Reduce device storage footprint by removing .ttf files from
+                // the res/fonts directory: we no longer need to copy our
+                // bundled fonts out of the APK in order to use them.
+                // See https://bugzilla.mozilla.org/show_bug.cgi?id=878674.
+                File dir = new File("res/fonts");
+                if (dir.exists() && dir.isDirectory()) {
+                    for (File file : dir.listFiles()) {
+                        if (file.isFile() && file.getName().endsWith(".ttf")) {
+                            Log.i(LOGTAG, "deleting " + file.toString());
+                            file.delete();
+                        }
+                    }
+                    if (!dir.delete()) {
+                        Log.w(LOGTAG, "unable to delete res/fonts directory (not empty?)");
+                    } else {
+                        Log.i(LOGTAG, "res/fonts directory deleted");
+                    }
+                }
+            }
+
+            // Additional cleanup needed for future versions would go here
+
+            if (cleanupVersion != CURRENT_CLEANUP_VERSION) {
+                SharedPreferences.Editor editor = getAppSharedPreferences().edit();
+                editor.putInt(CLEANUP_VERSION, CURRENT_CLEANUP_VERSION);
+                editor.commit();
+            }
+        }
+    }
+
+    public PromptService getPromptService() {
+        return mPromptService;
+    }
+
+    @Override
+    public void onBackPressed() {
+        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
+            super.onBackPressed();
+            return;
+        }
+
+        if (autoHideTabs()) {
+            return;
+        }
+
+        if (mDoorHangerPopup != null && mDoorHangerPopup.isShowing()) {
+            mDoorHangerPopup.dismiss();
+            return;
+        }
+
+        if (mFullScreenPluginView != null) {
+            GeckoAppShell.onFullScreenPluginHidden(mFullScreenPluginView);
+            removeFullScreenPluginView(mFullScreenPluginView);
+            return;
+        }
+
+        if (mLayerView != null && mLayerView.isFullScreen()) {
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
+            return;
+        }
+
+        Tabs tabs = Tabs.getInstance();
+        Tab tab = tabs.getSelectedTab();
+        if (tab == null) {
+            moveTaskToBack(true);
+            return;
+        }
+
+        if (tab.doBack())
+            return;
+
+        if (tab.isExternal()) {
+            moveTaskToBack(true);
+            tabs.closeTab(tab);
+            return;
+        }
+
+        int parentId = tab.getParentId();
+        Tab parent = tabs.getTab(parentId);
+        if (parent != null) {
+            // The back button should always return to the parent (not a sibling).
+            tabs.closeTab(tab, parent);
+            return;
+        }
+
+        moveTaskToBack(true);
+    }
+
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (!ActivityHandlerHelper.handleActivityResult(requestCode, resultCode, data)) {
+            super.onActivityResult(requestCode, resultCode, data);
+        }
+    }
+
+    public AbsoluteLayout getPluginContainer() { return mPluginContainer; }
+
+    // Accelerometer.
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) {
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        GeckoAppShell.sendEventToGecko(GeckoEvent.createSensorEvent(event));
+    }
+
+    // Geolocation.
+    @Override
+    public void onLocationChanged(Location location) {
+        // No logging here: user-identifying information.
+        GeckoAppShell.sendEventToGecko(GeckoEvent.createLocationEvent(location));
+        if (mShouldReportGeoData)
+            collectAndReportLocInfo(location);
+    }
+
+    public void setCurrentSignalStrenth(SignalStrength ss) {
+        if (ss.isGsm())
+            mSignalStrenth = ss.getGsmSignalStrength();
+    }
+
+    private int getCellInfo(JSONArray cellInfo) {
+        TelephonyManager tm = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
+        if (tm == null)
+            return TelephonyManager.PHONE_TYPE_NONE;
+        List<NeighboringCellInfo> cells = tm.getNeighboringCellInfo();
+        CellLocation cl = tm.getCellLocation();
+        String mcc = "", mnc = "";
+        if (cl instanceof GsmCellLocation) {
+            JSONObject obj = new JSONObject();
+            GsmCellLocation gcl = (GsmCellLocation)cl;
+            try {
+                obj.put("lac", gcl.getLac());
+                obj.put("cid", gcl.getCid());
+
+                int psc = (Build.VERSION.SDK_INT >= 9) ? gcl.getPsc() : -1;
+                obj.put("psc", psc);
+
+                switch(tm.getNetworkType()) {
+                case TelephonyManager.NETWORK_TYPE_GPRS:
+                case TelephonyManager.NETWORK_TYPE_EDGE:
+                    obj.put("radio", "gsm");
+                    break;
+                case TelephonyManager.NETWORK_TYPE_UMTS:
+                case TelephonyManager.NETWORK_TYPE_HSDPA:
+                case TelephonyManager.NETWORK_TYPE_HSUPA:
+                case TelephonyManager.NETWORK_TYPE_HSPA:
+                case TelephonyManager.NETWORK_TYPE_HSPAP:
+                    obj.put("radio", "umts");
+                    break;
+                }
+                String mcc_mnc = tm.getNetworkOperator();
+                if (mcc_mnc.length() > 3) {
+                    mcc = mcc_mnc.substring(0, 3);
+                    mnc = mcc_mnc.substring(3);
+                    obj.put("mcc", mcc);
+                    obj.put("mnc", mnc);
+                }
+                obj.put("asu", mSignalStrenth);
+            } catch(JSONException jsonex) {}
+            cellInfo.put(obj);
+        }
+        if (cells != null) {
+            for (NeighboringCellInfo nci : cells) {
+                try {
+                    JSONObject obj = new JSONObject();
+                    obj.put("lac", nci.getLac());
+                    obj.put("cid", nci.getCid());
+                    obj.put("psc", nci.getPsc());
+                    obj.put("mcc", mcc);
+                    obj.put("mnc", mnc);
+
+                    int dbm;
+                    switch(nci.getNetworkType()) {
+                    case TelephonyManager.NETWORK_TYPE_GPRS:
+                    case TelephonyManager.NETWORK_TYPE_EDGE:
+                        obj.put("radio", "gsm");
+                        break;
+                    case TelephonyManager.NETWORK_TYPE_UMTS:
+                    case TelephonyManager.NETWORK_TYPE_HSDPA:
+                    case TelephonyManager.NETWORK_TYPE_HSUPA:
+                    case TelephonyManager.NETWORK_TYPE_HSPA:
+                    case TelephonyManager.NETWORK_TYPE_HSPAP:
+                        obj.put("radio", "umts");
+                        break;
+                    }
+
+                    obj.put("asu", nci.getRssi());
+                    cellInfo.put(obj);
+                } catch(JSONException jsonex) {}
+            }
+        }
+        return tm.getPhoneType();
+    }
+
+    private static boolean shouldLog(final ScanResult sr) {
+        return sr.SSID == null || !sr.SSID.endsWith("_nomap");
+    }
+
+    private void collectAndReportLocInfo(Location location) {
+        final JSONObject locInfo = new JSONObject();
+        WifiManager wm = (WifiManager)getSystemService(Context.WIFI_SERVICE);
+        wm.startScan();
+        try {
+            JSONArray cellInfo = new JSONArray();
+
+            String radioType = getRadioTypeName(getCellInfo(cellInfo));
+            if (radioType != null) {
+                locInfo.put("radio", radioType);
+            }
+
+            locInfo.put("lon", location.getLongitude());
+            locInfo.put("lat", location.getLatitude());
+
+            // If we have an accuracy, round it up to the next meter.
+            if (location.hasAccuracy()) {
+                locInfo.put("accuracy", (int) Math.ceil(location.getAccuracy()));
+            }
+
+            // If we have an altitude, round it to the nearest meter.
+            if (location.hasAltitude()) {
+                locInfo.put("altitude", Math.round(location.getAltitude()));
+            }
+
+            // Reduce timestamp precision so as to expose less PII.
+            DateFormat df = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+            locInfo.put("time", df.format(new Date(location.getTime())));
+            locInfo.put("cell", cellInfo);
+
+            JSONArray wifiInfo = new JSONArray();
+            List<ScanResult> aps = wm.getScanResults();
+            if (aps != null) {
+                for (ScanResult ap : aps) {
+                    if (!shouldLog(ap))
+                        continue;
+
+                    JSONObject obj = new JSONObject();
+                    obj.put("key", ap.BSSID);
+                    obj.put("frequency", ap.frequency);
+                    obj.put("signal", ap.level);
+                    wifiInfo.put(obj);
+                }
+            }
+            locInfo.put("wifi", wifiInfo);
+        } catch (JSONException jsonex) {
+            Log.w(LOGTAG, "json exception", jsonex);
+            return;
+        }
+
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            public void run() {
+                try {
+                    URL url = new URL(LOCATION_URL);
+                    HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
+                    try {
+                        urlConnection.setDoOutput(true);
+
+                        // Workaround for a bug in Android HttpURLConnection. When the library
+                        // reuses a stale connection, the connection may fail with an EOFException.
+                        if (Build.VERSION.SDK_INT >= 14 && Build.VERSION.SDK_INT <= 18) {
+                            urlConnection.setRequestProperty("Connection", "Close");
+                        }
+
+                        JSONArray batch = new JSONArray();
+                        batch.put(locInfo);
+                        JSONObject wrapper = new JSONObject();
+                        wrapper.put("items", batch);
+                        byte[] bytes = wrapper.toString().getBytes();
+                        urlConnection.setFixedLengthStreamingMode(bytes.length);
+                        OutputStream out = new BufferedOutputStream(urlConnection.getOutputStream());
+                        out.write(bytes);
+                        out.flush();
+                    } catch (JSONException jsonex) {
+                        Log.e(LOGTAG, "error wrapping data as a batch", jsonex);
+                    } catch (IOException ioex) {
+                        Log.e(LOGTAG, "error submitting data", ioex);
+                    } finally {
+                        urlConnection.disconnect();
+                    }
+                } catch (IOException ioex) {
+                    Log.e(LOGTAG, "error submitting data", ioex);
+                }
+            }
+        });
+    }
+
+    private static String getRadioTypeName(int phoneType) {
+        switch (phoneType) {
+            case TelephonyManager.PHONE_TYPE_CDMA:
+                return "cdma";
+
+            case TelephonyManager.PHONE_TYPE_GSM:
+                return "gsm";
+
+            case TelephonyManager.PHONE_TYPE_NONE:
+            case TelephonyManager.PHONE_TYPE_SIP:
+                // These devices have no radio.
+                return null;
+
+            default:
+                Log.e(LOGTAG, "", new IllegalArgumentException("Unexpected PHONE_TYPE: " + phoneType));
+                return null;
+        }
+    }
+
+    @Override
+    public void onProviderDisabled(String provider)
+    {
+    }
+
+    @Override
+    public void onProviderEnabled(String provider)
+    {
+    }
+
+    @Override
+    public void onStatusChanged(String provider, int status, Bundle extras)
+    {
+    }
+
+    // Called when a Gecko Hal WakeLock is changed
+    public void notifyWakeLockChanged(String topic, String state) {
+        PowerManager.WakeLock wl = mWakeLocks.get(topic);
+        if (state.equals("locked-foreground") && wl == null) {
+            PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
+            wl = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, topic);
+            wl.acquire();
+            mWakeLocks.put(topic, wl);
+        } else if (!state.equals("locked-foreground") && wl != null) {
+            wl.release();
+            mWakeLocks.remove(topic);
+        }
+    }
+
+    public void notifyCheckUpdateResult(String result) {
+        GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Update:CheckResult", result));
+    }
+
+    protected void geckoConnected() {
+        mLayerView.geckoConnected();
+        mLayerView.setOverScrollMode(View.OVER_SCROLL_NEVER);
+    }
+
+    public void setAccessibilityEnabled(boolean enabled) {
+    }
+
+    public static class MainLayout extends RelativeLayout {
+        private TouchEventInterceptor mTouchEventInterceptor;
+        private MotionEventInterceptor mMotionEventInterceptor;
+
+        public MainLayout(Context context, AttributeSet attrs) {
+            super(context, attrs);
+        }
+
+        public void setTouchEventInterceptor(TouchEventInterceptor interceptor) {
+            mTouchEventInterceptor = interceptor;
+        }
+
+        public void setMotionEventInterceptor(MotionEventInterceptor interceptor) {
+            mMotionEventInterceptor = interceptor;
+        }
+
+        @Override
+        public boolean onInterceptTouchEvent(MotionEvent event) {
+            if (mTouchEventInterceptor != null && mTouchEventInterceptor.onInterceptTouchEvent(this, event)) {
+                return true;
+            }
+            return super.onInterceptTouchEvent(event);
+        }
+
+        @Override
+        public boolean onTouchEvent(MotionEvent event) {
+            if (mTouchEventInterceptor != null && mTouchEventInterceptor.onTouch(this, event)) {
+                return true;
+            }
+            return super.onTouchEvent(event);
+        }
+
+        @Override
+        public boolean onGenericMotionEvent(MotionEvent event) {
+            if (mMotionEventInterceptor != null && mMotionEventInterceptor.onInterceptMotionEvent(this, event)) {
+                return true;
+            }
+            return super.onGenericMotionEvent(event);
+        }
+
+        @Override
+        public void setDrawingCacheEnabled(boolean enabled) {
+            // Instead of setting drawing cache in the view itself, we simply
+            // enable drawing caching on its children. This is mainly used in
+            // animations (see PropertyAnimator)
+            super.setChildrenDrawnWithCacheEnabled(enabled);
+        }
+    }
+
+    private class FullScreenHolder extends FrameLayout {
+
+        public FullScreenHolder(Context ctx) {
+            super(ctx);
+        }
+
+        @Override
+        public void addView(View view, int index) {
+            /**
+             * This normally gets called when Flash adds a separate SurfaceView
+             * for the video. It is unhappy if we have the LayerView underneath
+             * it for some reason so we need to hide that. Hiding the LayerView causes
+             * its surface to be destroyed, which causes a pause composition
+             * event to be sent to Gecko. We synchronously wait for that to be
+             * processed. Simultaneously, however, Flash is waiting on a mutex so
+             * the post() below is an attempt to avoid a deadlock.
+             */
+            super.addView(view, index);
+
+            ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    mLayerView.hideSurface();
+                }
+            });
+        }
+
+        /**
+         * The methods below are simply copied from what Android WebKit does.
+         * It wasn't ever called in my testing, but might as well
+         * keep it in case it is for some reason. The methods
+         * all return true because we don't want any events
+         * leaking out from the fullscreen view.
+         */
+        @Override
+        public boolean onKeyDown(int keyCode, KeyEvent event) {
+            if (event.isSystem()) {
+                return super.onKeyDown(keyCode, event);
+            }
+            mFullScreenPluginView.onKeyDown(keyCode, event);
+            return true;
+        }
+
+        @Override
+        public boolean onKeyUp(int keyCode, KeyEvent event) {
+            if (event.isSystem()) {
+                return super.onKeyUp(keyCode, event);
+            }
+            mFullScreenPluginView.onKeyUp(keyCode, event);
+            return true;
+        }
+
+        @Override
+        public boolean onTouchEvent(MotionEvent event) {
+            return true;
+        }
+
+        @Override
+        public boolean onTrackballEvent(MotionEvent event) {
+            mFullScreenPluginView.onTrackballEvent(event);
+            return true;
+        }
+    }
+
+    protected NotificationClient makeNotificationClient() {
+        // Don't use a notification service; we may be killed in the background
+        // during downloads.
+        return new AppNotificationClient(getApplicationContext());
+    }
+
+    private int getVersionCode() {
+        int versionCode = 0;
+        try {
+            versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;
+        } catch (NameNotFoundException e) {
+            Log.wtf(LOGTAG, getPackageName() + " not found", e);
+        }
+        return versionCode;
+    }
+
+    protected boolean getIsDebuggable() {
+        // Return false so Fennec doesn't appear to be debuggable.  WebappImpl
+        // then overrides this and returns the value of android:debuggable for
+        // the webapp APK, so webapps get the behavior supported by this method
+        // (i.e. automatic configuration and enabling of the remote debugger).
+        return false;
+
+        // If we ever want to expose this for Fennec, here's how we would do it:
+        // int flags = 0;
+        // try {
+        //     flags = getPackageManager().getPackageInfo(getPackageName(), 0).applicationInfo.flags;
+        // } catch (NameNotFoundException e) {
+        //     Log.wtf(LOGTAG, getPackageName() + " not found", e);
+        // }
+        // return (flags & android.content.pm.ApplicationInfo.FLAG_DEBUGGABLE) != 0;
+    }
+
+    // FHR reason code for a session end prior to a restart for a
+    // locale change.
+    private static final String SESSION_END_LOCALE_CHANGED = "L";
+
+    /**
+     * Use LocaleManager to change our persisted and current locales,
+     * and poke HealthRecorder to tell it of our changed state.
+     */
+    private void setLocale(final String locale) {
+        if (locale == null) {
+            return;
+        }
+        final String resultant = LocaleManager.setSelectedLocale(locale);
+        if (resultant == null) {
+            return;
+        }
+
+        final boolean startNewSession = true;
+        final boolean shouldRestart = false;
+
+        // If the HealthRecorder is not yet initialized (unlikely), the locale change won't
+        // trigger a session transition and subsequent events will be recorded in an environment
+        // with the wrong locale.
+        final HealthRecorder rec = mHealthRecorder;
+        if (rec != null) {
+            rec.onAppLocaleChanged(resultant);
+            rec.onEnvironmentChanged(startNewSession, SESSION_END_LOCALE_CHANGED);
+        }
+
+        if (!shouldRestart) {
+            ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    GeckoApp.this.onLocaleReady(resultant);
+                }
+            });
+            return;
+        }
+
+        // Do this in the background so that the health recorder has its
+        // time to finish.
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                GeckoApp.this.doRestart();
+                GeckoApp.this.finish();
+            }
+        });
+    }
+
+    private void setSystemUiVisible(final boolean visible) {
+        if (Build.VERSION.SDK_INT < 14) {
+            return;
+        }
+
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                if (visible) {
+                    mMainLayout.setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE);
+                } else {
+                    mMainLayout.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE);
+                }
+            }
+        });
+    }
+
+    protected HealthRecorder createHealthRecorder(final Context context,
+                                                  final String profilePath,
+                                                  final EventDispatcher dispatcher,
+                                                  final String osLocale,
+                                                  final String appLocale,
+                                                  final SessionInformation previousSession) {
+        // GeckoApp does not need to record any health information - return a stub.
+        return new StubbedHealthRecorder();
+    }
+}
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/GeckoAppShell.java
--- a/mobile/android/base/GeckoAppShell.java	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/GeckoAppShell.java	Mon Mar 31 16:57:28 2014 +0700
@@ -2534,27 +2534,29 @@
 
     @WrapElementForJNI(stubName = "GetScreenOrientationWrapper")
     public static short getScreenOrientation() {
+	    Log.d("Cuong","GeckoScreenOrientation.getInstance() "+GeckoScreenOrientation.getInstance());
+	    Log.d("Cuong","GeckoScreenOrientation.getInstance() "+GeckoScreenOrientation.getInstance().getScreenOrientation());
         return GeckoScreenOrientation.getInstance().getScreenOrientation().value;
     }
 
     @WrapElementForJNI
     public static void enableScreenOrientationNotifications() {
-        GeckoScreenOrientation.getInstance().enableNotifications();
+//        GeckoScreenOrientation.getInstance().enableNotifications();
     }
 
     @WrapElementForJNI
     public static void disableScreenOrientationNotifications() {
-        GeckoScreenOrientation.getInstance().disableNotifications();
+//        GeckoScreenOrientation.getInstance().disableNotifications();
     }
 
     @WrapElementForJNI
     public static void lockScreenOrientation(int aOrientation) {
-        GeckoScreenOrientation.getInstance().lock(aOrientation);
+//        GeckoScreenOrientation.getInstance().lock(aOrientation);
     }
 
     @WrapElementForJNI
     public static void unlockScreenOrientation() {
-        GeckoScreenOrientation.getInstance().unlock();
+//        GeckoScreenOrientation.getInstance().unlock();
     }
 
     @WrapElementForJNI
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/GeckoAppShell.java.orig
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/GeckoAppShell.java.orig	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,2693 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.gecko;
+
+import java.io.BufferedReader;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.net.Proxy;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.StringTokenizer;
+import java.util.TreeMap;
+
+import org.mozilla.gecko.favicons.OnFaviconLoadedListener;
+import org.mozilla.gecko.favicons.decoders.FaviconDecoder;
+import org.mozilla.gecko.gfx.BitmapUtils;
+import org.mozilla.gecko.gfx.GeckoLayerClient;
+import org.mozilla.gecko.gfx.LayerView;
+import org.mozilla.gecko.gfx.PanZoomController;
+import org.mozilla.gecko.mozglue.GeckoLoader;
+import org.mozilla.gecko.mozglue.JNITarget;
+import org.mozilla.gecko.mozglue.RobocopTarget;
+import org.mozilla.gecko.mozglue.generatorannotations.OptionalGeneratedParameter;
+import org.mozilla.gecko.mozglue.generatorannotations.WrapElementForJNI;
+import org.mozilla.gecko.prompts.PromptService;
+import org.mozilla.gecko.util.GeckoEventListener;
+import org.mozilla.gecko.util.HardwareUtils;
+import org.mozilla.gecko.util.ProxySelector;
+import org.mozilla.gecko.util.ThreadUtils;
+import org.mozilla.gecko.webapp.Allocator;
+
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.PendingIntent;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+import android.content.pm.ServiceInfo;
+import android.content.pm.Signature;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ImageFormat;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.SurfaceTexture;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.hardware.Sensor;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.location.Criteria;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.media.MediaScannerConnection;
+import android.media.MediaScannerConnection.MediaScannerConnectionClient;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.MessageQueue;
+import android.os.SystemClock;
+import android.os.Vibrator;
+import android.provider.Settings;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Base64;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.ContextThemeWrapper;
+import android.view.HapticFeedbackConstants;
+import android.view.Surface;
+import android.view.SurfaceView;
+import android.view.TextureView;
+import android.view.View;
+import android.view.inputmethod.InputMethodManager;
+import android.webkit.MimeTypeMap;
+import android.widget.AbsoluteLayout;
+import android.widget.Toast;
+
+public class GeckoAppShell
+{
+    private static final String LOGTAG = "GeckoAppShell";
+
+    // static members only
+    private GeckoAppShell() { }
+
+    static private LinkedList<GeckoEvent> gPendingEvents =
+        new LinkedList<GeckoEvent>();
+
+    static private boolean gRestartScheduled = false;
+
+    static private GeckoEditableListener mEditableListener = null;
+
+    static private final HashMap<String, String>
+        mAlertCookies = new HashMap<String, String>();
+
+    // See also HardwareUtils.LOW_MEMORY_THRESHOLD_MB.
+    static private final int HIGH_MEMORY_DEVICE_THRESHOLD_MB = 768;
+
+    /* Keep in sync with constants found here:
+      http://mxr.mozilla.org/mozilla-central/source/uriloader/base/nsIWebProgressListener.idl
+    */
+    static public final int WPL_STATE_START = 0x00000001;
+    static public final int WPL_STATE_STOP = 0x00000010;
+    static public final int WPL_STATE_IS_DOCUMENT = 0x00020000;
+    static public final int WPL_STATE_IS_NETWORK = 0x00040000;
+
+    /* Keep in sync with constants found here:
+      http://mxr.mozilla.org/mozilla-central/source/netwerk/base/public/nsINetworkLinkService.idl
+    */
+    static public final int LINK_TYPE_UNKNOWN = 0;
+    static public final int LINK_TYPE_ETHERNET = 1;
+    static public final int LINK_TYPE_USB = 2;
+    static public final int LINK_TYPE_WIFI = 3;
+    static public final int LINK_TYPE_WIMAX = 4;
+    static public final int LINK_TYPE_2G = 5;
+    static public final int LINK_TYPE_3G = 6;
+    static public final int LINK_TYPE_4G = 7;
+
+    public static final String SHORTCUT_TYPE_WEBAPP = "webapp";
+    public static final String SHORTCUT_TYPE_BOOKMARK = "bookmark";
+
+    static private final boolean LOGGING = false;
+
+    static private int sDensityDpi = 0;
+    static private int sScreenDepth = 0;
+
+    private static final EventDispatcher sEventDispatcher = new EventDispatcher();
+
+    /* Default colors. */
+    private static final float[] DEFAULT_LAUNCHER_ICON_HSV = { 32.0f, 1.0f, 1.0f };
+
+    /* Is the value in sVibrationEndTime valid? */
+    private static boolean sVibrationMaybePlaying = false;
+
+    /* Time (in System.nanoTime() units) when the currently-playing vibration
+     * is scheduled to end.  This value is valid only when
+     * sVibrationMaybePlaying is true. */
+    private static long sVibrationEndTime = 0;
+
+    /* Default value of how fast we should hint the Android sensors. */
+    private static int sDefaultSensorHint = 100;
+
+    private static Sensor gAccelerometerSensor = null;
+    private static Sensor gLinearAccelerometerSensor = null;
+    private static Sensor gGyroscopeSensor = null;
+    private static Sensor gOrientationSensor = null;
+    private static Sensor gProximitySensor = null;
+    private static Sensor gLightSensor = null;
+
+    private static volatile boolean mLocationHighAccuracy;
+
+    static NotificationClient sNotificationClient;
+
+    /* The Android-side API: API methods that Android calls */
+
+    // Initialization methods
+    public static native void nativeInit();
+
+    // helper methods
+    //    public static native void setSurfaceView(GeckoSurfaceView sv);
+    public static native void setLayerClient(GeckoLayerClient client);
+    public static native void onResume();
+    public static void callObserver(String observerKey, String topic, String data) {
+        sendEventToGecko(GeckoEvent.createCallObserverEvent(observerKey, topic, data));
+    }
+    public static void removeObserver(String observerKey) {
+        sendEventToGecko(GeckoEvent.createRemoveObserverEvent(observerKey));
+    }
+    public static native Message getNextMessageFromQueue(MessageQueue queue);
+    public static native void onSurfaceTextureFrameAvailable(Object surfaceTexture, int id);
+    public static native void dispatchMemoryPressure();
+
+    public static void registerGlobalExceptionHandler() {
+        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+            @Override
+            public void uncaughtException(Thread thread, Throwable e) {
+                handleUncaughtException(thread, e);
+            }
+        });
+    }
+
+    private static String getStackTraceString(Throwable e) {
+        StringWriter sw = new StringWriter();
+        PrintWriter pw = new PrintWriter(sw);
+        e.printStackTrace(pw);
+        pw.flush();
+        return sw.toString();
+    }
+
+    private static native void reportJavaCrash(String stackTrace);
+
+    public static void notifyUriVisited(String uri) {
+        sendEventToGecko(GeckoEvent.createVisitedEvent(uri));
+    }
+
+    public static native void processNextNativeEvent(boolean mayWait);
+
+    public static native void notifyBatteryChange(double aLevel, boolean aCharging, double aRemainingTime);
+
+    public static native void scheduleComposite();
+
+    // Resuming the compositor is a synchronous request, so be
+    // careful of possible deadlock. Resuming the compositor will also cause
+    // a composition, so there is no need to schedule a composition after
+    // resuming.
+    public static native void scheduleResumeComposition(int width, int height);
+
+    public static native float computeRenderIntegrity();
+
+    public static native SurfaceBits getSurfaceBits(Surface surface);
+
+    public static native void onFullScreenPluginHidden(View view);
+
+    public static class CreateShortcutFaviconLoadedListener implements OnFaviconLoadedListener {
+        private final String title;
+        private final String url;
+
+        public CreateShortcutFaviconLoadedListener(final String url, final String title) {
+            this.url = url;
+            this.title = title;
+        }
+
+        @Override
+        public void onFaviconLoaded(String pageUrl, String faviconURL, Bitmap favicon) {
+            GeckoAppShell.createShortcut(title, url, url, favicon, "");
+        }
+    }
+
+    private static final class GeckoMediaScannerClient implements MediaScannerConnectionClient {
+        private final String mFile;
+        private final String mMimeType;
+        private MediaScannerConnection mScanner;
+
+        public static void startScan(Context context, String file, String mimeType) {
+            new GeckoMediaScannerClient(context, file, mimeType);
+        }
+
+        private GeckoMediaScannerClient(Context context, String file, String mimeType) {
+            mFile = file;
+            mMimeType = mimeType;
+            mScanner = new MediaScannerConnection(context, this);
+            mScanner.connect();
+        }
+
+        @Override
+        public void onMediaScannerConnected() {
+            mScanner.scanFile(mFile, mMimeType);
+        }
+
+        @Override
+        public void onScanCompleted(String path, Uri uri) {
+            if(path.equals(mFile)) {
+                mScanner.disconnect();
+                mScanner = null;
+            }
+        }
+    }
+
+    private static LayerView sLayerView;
+
+    public static void setLayerView(LayerView lv) {
+        sLayerView = lv;
+    }
+
+    @RobocopTarget
+    public static LayerView getLayerView() {
+        return sLayerView;
+    }
+
+    public static void runGecko(String apkPath, String args, String url, String type) {
+        // Preparation for pumpMessageLoop()
+        MessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler() {
+            @Override public boolean queueIdle() {
+                final Handler geckoHandler = ThreadUtils.sGeckoHandler;
+                Message idleMsg = Message.obtain(geckoHandler);
+                // Use |Message.obj == GeckoHandler| to identify our "queue is empty" message
+                idleMsg.obj = geckoHandler;
+                geckoHandler.sendMessageAtFrontOfQueue(idleMsg);
+                // Keep this IdleHandler
+                return true;
+            }
+        };
+        Looper.myQueue().addIdleHandler(idleHandler);
+
+        // run gecko -- it will spawn its own thread
+        GeckoAppShell.nativeInit();
+
+        if (sLayerView != null)
+            GeckoAppShell.setLayerClient(sLayerView.getLayerClient());
+
+        // First argument is the .apk path
+        String combinedArgs = apkPath + " -greomni " + apkPath;
+        if (args != null)
+            combinedArgs += " " + args;
+        if (url != null)
+            combinedArgs += " -url " + url;
+        if (type != null)
+            combinedArgs += " " + type;
+
+        DisplayMetrics metrics = getContext().getResources().getDisplayMetrics();
+        combinedArgs += " -width " + metrics.widthPixels + " -height " + metrics.heightPixels;
+
+        ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    geckoLoaded();
+                }
+            });
+
+        // and go
+        Log.d(LOGTAG, "GeckoLoader.nativeRun " + combinedArgs);
+        GeckoLoader.nativeRun(combinedArgs);
+
+        // Remove pumpMessageLoop() idle handler
+        Looper.myQueue().removeIdleHandler(idleHandler);
+    }
+
+    // Called on the UI thread after Gecko loads.
+    private static void geckoLoaded() {
+        GeckoEditable editable = new GeckoEditable();
+        // install the gecko => editable listener
+        mEditableListener = editable;
+    }
+
+    static void sendPendingEventsToGecko() {
+        try {
+            while (!gPendingEvents.isEmpty()) {
+                GeckoEvent e = gPendingEvents.removeFirst();
+                notifyGeckoOfEvent(e);
+            }
+        } catch (NoSuchElementException e) {}
+    }
+
+    @RobocopTarget
+    public static void sendEventToGecko(GeckoEvent e) {
+        if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoRunning)) {
+            notifyGeckoOfEvent(e);
+            // Gecko will copy the event data into a normal C++ object. We can recycle the evet now.
+            e.recycle();
+        } else {
+            gPendingEvents.addLast(e);
+        }
+    }
+
+    // Tell the Gecko event loop that an event is available.
+    public static native void notifyGeckoOfEvent(GeckoEvent event);
+
+    /*
+     *  The Gecko-side API: API methods that Gecko calls
+     */
+
+    @WrapElementForJNI(allowMultithread = true, generateStatic = true, noThrow = true)
+    public static void handleUncaughtException(Thread thread, Throwable e) {
+        if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoExited)) {
+            // We've called System.exit. All exceptions after this point are Android
+            // berating us for being nasty to it.
+            return;
+        }
+
+        if (thread == null) {
+            thread = Thread.currentThread();
+        }
+        // If the uncaught exception was rethrown, walk the exception `cause` chain to find
+        // the original exception so Socorro can correctly collate related crash reports.
+        Throwable cause;
+        while ((cause = e.getCause()) != null) {
+            e = cause;
+        }
+
+        try {
+            Log.e(LOGTAG, ">>> REPORTING UNCAUGHT EXCEPTION FROM THREAD "
+                          + thread.getId() + " (\"" + thread.getName() + "\")", e);
+
+            Thread mainThread = ThreadUtils.getUiThread();
+            if (mainThread != null && thread != mainThread) {
+                Log.e(LOGTAG, "Main thread stack:");
+                for (StackTraceElement ste : mainThread.getStackTrace()) {
+                    Log.e(LOGTAG, ste.toString());
+                }
+            }
+
+            if (e instanceof OutOfMemoryError) {
+                SharedPreferences prefs = getSharedPreferences();
+                SharedPreferences.Editor editor = prefs.edit();
+                editor.putBoolean(GeckoApp.PREFS_OOM_EXCEPTION, true);
+                editor.commit();
+            }
+        } finally {
+            reportJavaCrash(getStackTraceString(e));
+        }
+    }
+
+    @WrapElementForJNI(generateStatic = true)
+    public static void notifyIME(int type) {
+        if (mEditableListener != null) {
+            mEditableListener.notifyIME(type);
+        }
+    }
+
+    @WrapElementForJNI(generateStatic = true)
+    public static void notifyIMEContext(int state, String typeHint,
+                                        String modeHint, String actionHint) {
+        if (mEditableListener != null) {
+            mEditableListener.notifyIMEContext(state, typeHint,
+                                               modeHint, actionHint);
+        }
+    }
+
+    @WrapElementForJNI(generateStatic = true)
+    public static void notifyIMEChange(String text, int start, int end, int newEnd) {
+        if (newEnd < 0) { // Selection change
+            mEditableListener.onSelectionChange(start, end);
+        } else { // Text change
+            mEditableListener.onTextChange(text, start, end, newEnd);
+        }
+    }
+
+    private static final Object sEventAckLock = new Object();
+    private static boolean sWaitingForEventAck;
+
+    // Block the current thread until the Gecko event loop is caught up
+    public static void sendEventToGeckoSync(GeckoEvent e) {
+        e.setAckNeeded(true);
+
+        long time = SystemClock.uptimeMillis();
+        boolean isUiThread = ThreadUtils.isOnUiThread();
+
+        synchronized (sEventAckLock) {
+            if (sWaitingForEventAck) {
+                // should never happen since we always leave it as false when we exit this function.
+                Log.e(LOGTAG, "geckoEventSync() may have been called twice concurrently!", new Exception());
+                // fall through for graceful handling
+            }
+
+            sendEventToGecko(e);
+            sWaitingForEventAck = true;
+            while (true) {
+                try {
+                    sEventAckLock.wait(1000);
+                } catch (InterruptedException ie) {
+                }
+                if (!sWaitingForEventAck) {
+                    // response received
+                    break;
+                }
+                long waited = SystemClock.uptimeMillis() - time;
+                Log.d(LOGTAG, "Gecko event sync taking too long: " + waited + "ms");
+            }
+        }
+    }
+
+    // Signal the Java thread that it's time to wake up
+    @WrapElementForJNI
+    public static void acknowledgeEvent() {
+        synchronized (sEventAckLock) {
+            sWaitingForEventAck = false;
+            sEventAckLock.notifyAll();
+        }
+    }
+
+    private static float getLocationAccuracy(Location location) {
+        float radius = location.getAccuracy();
+        return (location.hasAccuracy() && radius > 0) ? radius : 1001;
+    }
+
+    private static Location getLastKnownLocation(LocationManager lm) {
+        Location lastKnownLocation = null;
+        List<String> providers = lm.getAllProviders();
+
+        for (String provider : providers) {
+            Location location = lm.getLastKnownLocation(provider);
+            if (location == null) {
+                continue;
+            }
+
+            if (lastKnownLocation == null) {
+                lastKnownLocation = location;
+                continue;
+            }
+
+            long timeDiff = location.getTime() - lastKnownLocation.getTime();
+            if (timeDiff > 0 ||
+                (timeDiff == 0 &&
+                 getLocationAccuracy(location) < getLocationAccuracy(lastKnownLocation))) {
+                lastKnownLocation = location;
+            }
+        }
+
+        return lastKnownLocation;
+    }
+
+    @WrapElementForJNI
+    public static void enableLocation(final boolean enable) {
+        ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    LocationManager lm = getLocationManager(getContext());
+                    if (lm == null) {
+                        return;
+                    }
+
+                    if (enable) {
+                        Location lastKnownLocation = getLastKnownLocation(lm);
+                        if (lastKnownLocation != null) {
+                            getGeckoInterface().getLocationListener().onLocationChanged(lastKnownLocation);
+                        }
+
+                        Criteria criteria = new Criteria();
+                        criteria.setSpeedRequired(false);
+                        criteria.setBearingRequired(false);
+                        criteria.setAltitudeRequired(false);
+                        if (mLocationHighAccuracy) {
+                            criteria.setAccuracy(Criteria.ACCURACY_FINE);
+                            criteria.setCostAllowed(true);
+                            criteria.setPowerRequirement(Criteria.POWER_HIGH);
+                        } else {
+                            criteria.setAccuracy(Criteria.ACCURACY_COARSE);
+                            criteria.setCostAllowed(false);
+                            criteria.setPowerRequirement(Criteria.POWER_LOW);
+                        }
+
+                        String provider = lm.getBestProvider(criteria, true);
+                        if (provider == null)
+                            return;
+
+                        Looper l = Looper.getMainLooper();
+                        lm.requestLocationUpdates(provider, 100, (float).5, getGeckoInterface().getLocationListener(), l);
+                    } else {
+                        lm.removeUpdates(getGeckoInterface().getLocationListener());
+                    }
+                }
+            });
+    }
+
+    private static LocationManager getLocationManager(Context context) {
+        try {
+            return (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
+        } catch (NoSuchFieldError e) {
+            // Some Tegras throw exceptions about missing the CONTROL_LOCATION_UPDATES permission,
+            // which allows enabling/disabling location update notifications from the cell radio.
+            // CONTROL_LOCATION_UPDATES is not for use by normal applications, but we might be
+            // hitting this problem if the Tegras are confused about missing cell radios.
+            Log.e(LOGTAG, "LOCATION_SERVICE not found?!", e);
+            return null;
+        }
+    }
+
+    @WrapElementForJNI
+    public static void enableLocationHighAccuracy(final boolean enable) {
+        mLocationHighAccuracy = enable;
+    }
+
+    @WrapElementForJNI
+    public static void enableSensor(int aSensortype) {
+        GeckoInterface gi = getGeckoInterface();
+        if (gi == null)
+            return;
+        SensorManager sm = (SensorManager)
+            getContext().getSystemService(Context.SENSOR_SERVICE);
+
+        switch(aSensortype) {
+        case GeckoHalDefines.SENSOR_ORIENTATION:
+            if(gOrientationSensor == null)
+                gOrientationSensor = sm.getDefaultSensor(Sensor.TYPE_ORIENTATION);
+            if (gOrientationSensor != null) 
+                sm.registerListener(gi.getSensorEventListener(), gOrientationSensor, sDefaultSensorHint);
+            break;
+
+        case GeckoHalDefines.SENSOR_ACCELERATION:
+            if(gAccelerometerSensor == null)
+                gAccelerometerSensor = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
+            if (gAccelerometerSensor != null)
+                sm.registerListener(gi.getSensorEventListener(), gAccelerometerSensor, sDefaultSensorHint);
+            break;
+
+        case GeckoHalDefines.SENSOR_PROXIMITY:
+            if(gProximitySensor == null  )
+                gProximitySensor = sm.getDefaultSensor(Sensor.TYPE_PROXIMITY);
+            if (gProximitySensor != null)
+                sm.registerListener(gi.getSensorEventListener(), gProximitySensor, SensorManager.SENSOR_DELAY_NORMAL);
+            break;
+
+        case GeckoHalDefines.SENSOR_LIGHT:
+            if(gLightSensor == null)
+                gLightSensor = sm.getDefaultSensor(Sensor.TYPE_LIGHT);
+            if (gLightSensor != null)
+                sm.registerListener(gi.getSensorEventListener(), gLightSensor, SensorManager.SENSOR_DELAY_NORMAL);
+            break;
+
+        case GeckoHalDefines.SENSOR_LINEAR_ACCELERATION:
+            if(gLinearAccelerometerSensor == null)
+                gLinearAccelerometerSensor = sm.getDefaultSensor(10 /* API Level 9 - TYPE_LINEAR_ACCELERATION */);
+            if (gLinearAccelerometerSensor != null)
+                sm.registerListener(gi.getSensorEventListener(), gLinearAccelerometerSensor, sDefaultSensorHint);
+            break;
+
+        case GeckoHalDefines.SENSOR_GYROSCOPE:
+            if(gGyroscopeSensor == null)
+                gGyroscopeSensor = sm.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
+            if (gGyroscopeSensor != null)
+                sm.registerListener(gi.getSensorEventListener(), gGyroscopeSensor, sDefaultSensorHint);
+            break;
+        default:
+            Log.w(LOGTAG, "Error! Can't enable unknown SENSOR type " + aSensortype);
+        }
+    }
+
+    @WrapElementForJNI
+    public static void disableSensor(int aSensortype) {
+        GeckoInterface gi = getGeckoInterface();
+        if (gi == null)
+            return;
+
+        SensorManager sm = (SensorManager)
+            getContext().getSystemService(Context.SENSOR_SERVICE);
+
+        switch (aSensortype) {
+        case GeckoHalDefines.SENSOR_ORIENTATION:
+            if (gOrientationSensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gOrientationSensor);
+            break;
+
+        case GeckoHalDefines.SENSOR_ACCELERATION:
+            if (gAccelerometerSensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gAccelerometerSensor);
+            break;
+
+        case GeckoHalDefines.SENSOR_PROXIMITY:
+            if (gProximitySensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gProximitySensor);
+            break;
+
+        case GeckoHalDefines.SENSOR_LIGHT:
+            if (gLightSensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gLightSensor);
+            break;
+
+        case GeckoHalDefines.SENSOR_LINEAR_ACCELERATION:
+            if (gLinearAccelerometerSensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gLinearAccelerometerSensor);
+            break;
+
+        case GeckoHalDefines.SENSOR_GYROSCOPE:
+            if (gGyroscopeSensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gGyroscopeSensor);
+            break;
+        default:
+            Log.w(LOGTAG, "Error! Can't disable unknown SENSOR type " + aSensortype);
+        }
+    }
+
+    @WrapElementForJNI
+    public static void moveTaskToBack() {
+        if (getGeckoInterface() != null)
+            getGeckoInterface().getActivity().moveTaskToBack(true);
+    }
+
+    public static void returnIMEQueryResult(String result, int selectionStart, int selectionLength) {
+        // This method may be called from JNI to report Gecko's current selection indexes, but
+        // Native Fennec doesn't care because the Java code already knows the selection indexes.
+    }
+
+    @WrapElementForJNI(stubName = "NotifyXreExit")
+    static void onXreExit() {
+        // The launch state can only be Launched or GeckoRunning at this point
+        GeckoThread.setLaunchState(GeckoThread.LaunchState.GeckoExiting);
+        if (getGeckoInterface() != null) {
+            if (gRestartScheduled) {
+                getGeckoInterface().doRestart();
+            } else {
+                getGeckoInterface().getActivity().finish();
+            }
+        }
+
+        systemExit();
+    }
+
+    static void systemExit() {
+        Log.d(LOGTAG, "Killing via System.exit()");
+        GeckoThread.setLaunchState(GeckoThread.LaunchState.GeckoExited);
+        System.exit(0);
+    }
+
+    @WrapElementForJNI
+    static void scheduleRestart() {
+        gRestartScheduled = true;
+    }
+
+    public static Intent getWebappIntent(String aURI, String aOrigin, String aTitle, Bitmap aIcon) {
+        Intent intent;
+
+        if (AppConstants.MOZ_ANDROID_SYNTHAPKS) {
+            Allocator slots = Allocator.getInstance(getContext());
+            int index = slots.getIndexForOrigin(aOrigin);
+
+            if (index == -1) {
+                return null;
+            }
+            String packageName = slots.getAppForIndex(index);
+            intent = getContext().getPackageManager().getLaunchIntentForPackage(packageName);
+            if (aURI != null) {
+                intent.setData(Uri.parse(aURI));
+            }
+        } else {
+            int index;
+            if (aIcon != null && !TextUtils.isEmpty(aTitle))
+                index = WebappAllocator.getInstance(getContext()).findAndAllocateIndex(aOrigin, aTitle, aIcon);
+            else
+                index = WebappAllocator.getInstance(getContext()).getIndexForApp(aOrigin);
+
+            if (index == -1)
+                return null;
+
+            intent = getWebappIntent(index, aURI);
+        }
+
+        return intent;
+    }
+
+    // The old implementation of getWebappIntent.  Not used by MOZ_ANDROID_SYNTHAPKS.
+    public static Intent getWebappIntent(int aIndex, String aURI) {
+        Intent intent = new Intent();
+        intent.setAction(GeckoApp.ACTION_WEBAPP_PREFIX + aIndex);
+        intent.setData(Uri.parse(aURI));
+        intent.setClassName(AppConstants.ANDROID_PACKAGE_NAME,
+                            AppConstants.ANDROID_PACKAGE_NAME + ".WebApps$WebApp" + aIndex);
+        return intent;
+    }
+
+    // "Installs" an application by creating a shortcut
+    // This is the entry point from AndroidBridge.h
+    @WrapElementForJNI
+    static void createShortcut(String aTitle, String aURI, String aIconData, String aType) {
+        if ("webapp".equals(aType)) {
+            Log.w(LOGTAG, "createShortcut with no unique URI should not be used for aType = webapp!");
+        }
+
+        createShortcut(aTitle, aURI, aURI, aIconData, aType);
+    }
+
+    // For non-webapps.
+    public static void createShortcut(String aTitle, String aURI, Bitmap aBitmap, String aType) {
+        createShortcut(aTitle, aURI, aURI, aBitmap, aType);
+    }
+
+    // Internal, for webapps.
+    static void createShortcut(final String aTitle, final String aURI, final String aUniqueURI, final String aIconData, final String aType) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                // TODO: use the cache. Bug 961600.
+                Bitmap icon = FaviconDecoder.getMostSuitableBitmapFromDataURI(aIconData, getPreferredIconSize());
+                GeckoAppShell.doCreateShortcut(aTitle, aURI, aURI, icon, aType);
+            }
+        });
+    }
+
+    public static void createShortcut(final String aTitle, final String aURI, final String aUniqueURI,
+                                      final Bitmap aIcon, final String aType) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                GeckoAppShell.doCreateShortcut(aTitle, aURI, aUniqueURI, aIcon, aType);
+            }
+        });
+    }
+
+    /**
+     * Call this method only on the background thread.
+     */
+    private static void doCreateShortcut(final String aTitle, final String aURI, final String aUniqueURI,
+                                         final Bitmap aIcon, final String aType) {
+        // The intent to be launched by the shortcut.
+        Intent shortcutIntent;
+        if (aType.equalsIgnoreCase(SHORTCUT_TYPE_WEBAPP)) {
+            shortcutIntent = getWebappIntent(aURI, aUniqueURI, aTitle, aIcon);
+        } else {
+            shortcutIntent = new Intent();
+            shortcutIntent.setAction(GeckoApp.ACTION_BOOKMARK);
+            shortcutIntent.setData(Uri.parse(aURI));
+            shortcutIntent.setClassName(AppConstants.ANDROID_PACKAGE_NAME,
+                                        AppConstants.BROWSER_INTENT_CLASS);
+        }
+
+        Intent intent = new Intent();
+        intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
+        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON, getLauncherIcon(aIcon, aType));
+
+        if (aTitle != null) {
+            intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, aTitle);
+        } else {
+            intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, aURI);
+        }
+
+        // Do not allow duplicate items.
+        intent.putExtra("duplicate", false);
+
+        intent.setAction("com.android.launcher.action.INSTALL_SHORTCUT");
+        getContext().sendBroadcast(intent);
+    }
+
+    public static void removeShortcut(final String aTitle, final String aURI, final String aType) {
+        removeShortcut(aTitle, aURI, null, aType);
+    }
+
+    public static void removeShortcut(final String aTitle, final String aURI, final String aUniqueURI, final String aType) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                // the intent to be launched by the shortcut
+                Intent shortcutIntent;
+                if (aType.equalsIgnoreCase(SHORTCUT_TYPE_WEBAPP)) {
+                    shortcutIntent = getWebappIntent(aURI, aUniqueURI, "", null);
+                    if (shortcutIntent == null)
+                        return;
+                } else {
+                    shortcutIntent = new Intent();
+                    shortcutIntent.setAction(GeckoApp.ACTION_BOOKMARK);
+                    shortcutIntent.setClassName(AppConstants.ANDROID_PACKAGE_NAME,
+                                                AppConstants.BROWSER_INTENT_CLASS);
+                    shortcutIntent.setData(Uri.parse(aURI));
+                }
+        
+                Intent intent = new Intent();
+                intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
+                if (aTitle != null)
+                    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, aTitle);
+                else
+                    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, aURI);
+
+                intent.setAction("com.android.launcher.action.UNINSTALL_SHORTCUT");
+                getContext().sendBroadcast(intent);
+            }
+        });
+    }
+
+    @JNITarget
+    static public int getPreferredIconSize() {
+        if (android.os.Build.VERSION.SDK_INT >= 11) {
+            ActivityManager am = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+            return am.getLauncherLargeIconSize();
+        } else {
+            switch (getDpi()) {
+                case DisplayMetrics.DENSITY_MEDIUM:
+                    return 48;
+                case DisplayMetrics.DENSITY_XHIGH:
+                    return 96;
+                case DisplayMetrics.DENSITY_HIGH:
+                default:
+                    return 72;
+            }
+        }
+    }
+
+    static private Bitmap getLauncherIcon(Bitmap aSource, String aType) {
+        final int kOffset = 6;
+        final int kRadius = 5;
+        int size = getPreferredIconSize();
+        int insetSize = aSource != null ? size * 2 / 3 : size;
+
+        Bitmap bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);
+        Canvas canvas = new Canvas(bitmap);
+
+
+        // draw a base color
+        Paint paint = new Paint();
+        if (aSource == null) {
+            // If we aren't drawing a favicon, just use an orange color.
+            paint.setColor(Color.HSVToColor(DEFAULT_LAUNCHER_ICON_HSV));
+            canvas.drawRoundRect(new RectF(kOffset, kOffset, size - kOffset, size - kOffset), kRadius, kRadius, paint);
+        } else if (aType.equalsIgnoreCase(SHORTCUT_TYPE_WEBAPP) || aSource.getWidth() >= insetSize || aSource.getHeight() >= insetSize) {
+            // otherwise, if this is a webapp or if the icons is lare enough, just draw it
+            Rect iconBounds = new Rect(0, 0, size, size);
+            canvas.drawBitmap(aSource, null, iconBounds, null);
+            return bitmap;
+        } else {
+            // otherwise use the dominant color from the icon + a layer of transparent white to lighten it somewhat
+            int color = BitmapUtils.getDominantColor(aSource);
+            paint.setColor(color);
+            canvas.drawRoundRect(new RectF(kOffset, kOffset, size - kOffset, size - kOffset), kRadius, kRadius, paint);
+            paint.setColor(Color.argb(100, 255, 255, 255));
+            canvas.drawRoundRect(new RectF(kOffset, kOffset, size - kOffset, size - kOffset), kRadius, kRadius, paint);
+        }
+
+        // draw the overlay
+        Bitmap overlay = BitmapUtils.decodeResource(getContext(), R.drawable.home_bg);
+        canvas.drawBitmap(overlay, null, new Rect(0, 0, size, size), null);
+
+        // draw the favicon
+        if (aSource == null)
+            aSource = BitmapUtils.decodeResource(getContext(), R.drawable.home_star);
+
+        // by default, we scale the icon to this size
+        int sWidth = insetSize / 2;
+        int sHeight = sWidth;
+
+        int halfSize = size / 2;
+        canvas.drawBitmap(aSource,
+                          null,
+                          new Rect(halfSize - sWidth,
+                                   halfSize - sHeight,
+                                   halfSize + sWidth,
+                                   halfSize + sHeight),
+                          null);
+
+        return bitmap;
+    }
+
+    @WrapElementForJNI(stubName = "GetHandlersForMimeTypeWrapper")
+    static String[] getHandlersForMimeType(String aMimeType, String aAction) {
+        Intent intent = getIntentForActionString(aAction);
+        if (aMimeType != null && aMimeType.length() > 0)
+            intent.setType(aMimeType);
+        return getHandlersForIntent(intent);
+    }
+
+    @WrapElementForJNI(stubName = "GetHandlersForURLWrapper")
+    static String[] getHandlersForURL(String aURL, String aAction) {
+        // aURL may contain the whole URL or just the protocol
+        Uri uri = aURL.indexOf(':') >= 0 ? Uri.parse(aURL) : new Uri.Builder().scheme(aURL).build();
+
+        Intent intent = getOpenURIIntent(getContext(), uri.toString(), "",
+            TextUtils.isEmpty(aAction) ? Intent.ACTION_VIEW : aAction, "");
+
+        return getHandlersForIntent(intent);
+    }
+
+    static boolean hasHandlersForIntent(Intent intent) {
+        PackageManager pm = getContext().getPackageManager();
+        List<ResolveInfo> list = pm.queryIntentActivities(intent, 0);
+        return !list.isEmpty();
+    }
+
+    static String[] getHandlersForIntent(Intent intent) {
+        PackageManager pm = getContext().getPackageManager();
+        List<ResolveInfo> list = pm.queryIntentActivities(intent, 0);
+        int numAttr = 4;
+        String[] ret = new String[list.size() * numAttr];
+        for (int i = 0; i < list.size(); i++) {
+            ResolveInfo resolveInfo = list.get(i);
+            ret[i * numAttr] = resolveInfo.loadLabel(pm).toString();
+            if (resolveInfo.isDefault)
+                ret[i * numAttr + 1] = "default";
+            else
+                ret[i * numAttr + 1] = "";
+            ret[i * numAttr + 2] = resolveInfo.activityInfo.applicationInfo.packageName;
+            ret[i * numAttr + 3] = resolveInfo.activityInfo.name;
+        }
+        return ret;
+    }
+
+    static Intent getIntentForActionString(String aAction) {
+        // Default to the view action if no other action as been specified.
+        if (TextUtils.isEmpty(aAction)) {
+            return new Intent(Intent.ACTION_VIEW);
+        }
+        return new Intent(aAction);
+    }
+
+    @WrapElementForJNI(stubName = "GetExtensionFromMimeTypeWrapper")
+    static String getExtensionFromMimeType(String aMimeType) {
+        return MimeTypeMap.getSingleton().getExtensionFromMimeType(aMimeType);
+    }
+
+    @WrapElementForJNI(stubName = "GetMimeTypeFromExtensionsWrapper")
+    static String getMimeTypeFromExtensions(String aFileExt) {
+        StringTokenizer st = new StringTokenizer(aFileExt, ".,; ");
+        String type = null;
+        String subType = null;
+        while (st.hasMoreElements()) {
+            String ext = st.nextToken();
+            String mt = getMimeTypeFromExtension(ext);
+            if (mt == null)
+                continue;
+            int slash = mt.indexOf('/');
+            String tmpType = mt.substring(0, slash);
+            if (!tmpType.equalsIgnoreCase(type))
+                type = type == null ? tmpType : "*";
+            String tmpSubType = mt.substring(slash + 1);
+            if (!tmpSubType.equalsIgnoreCase(subType))
+                subType = subType == null ? tmpSubType : "*";
+        }
+        if (type == null)
+            type = "*";
+        if (subType == null)
+            subType = "*";
+        return type + "/" + subType;
+    }
+
+    static void safeStreamClose(Closeable stream) {
+        try {
+            if (stream != null)
+                stream.close();
+        } catch (IOException e) {}
+    }
+
+    static void shareImage(String aSrc, String aType) {
+
+        Intent intent = new Intent(Intent.ACTION_SEND);
+        boolean isDataURI = aSrc.startsWith("data:");
+        OutputStream os = null;
+        File dir = GeckoApp.getTempDirectory();
+
+        if (dir == null) {
+            showImageShareFailureToast();
+            return;
+        }
+
+        GeckoApp.deleteTempFiles();
+
+        try {
+            // Create a temporary file for the image
+            File imageFile = File.createTempFile("image",
+                                                 "." + aType.replace("image/",""),
+                                                 dir);
+            os = new FileOutputStream(imageFile);
+
+            if (isDataURI) {
+                // We are dealing with a Data URI
+                int dataStart = aSrc.indexOf(',');
+                byte[] buf = Base64.decode(aSrc.substring(dataStart+1), Base64.DEFAULT);
+                os.write(buf);
+            } else {
+                // We are dealing with a URL
+                InputStream is = null;
+                try {
+                    URL url = new URL(aSrc);
+                    is = url.openStream();
+                    byte[] buf = new byte[2048];
+                    int length;
+
+                    while ((length = is.read(buf)) != -1) {
+                        os.write(buf, 0, length);
+                    }
+                } finally {
+                    safeStreamClose(is);
+                }
+            }
+            intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(imageFile));
+
+            // If we were able to determine the image type, send that in the intent. Otherwise,
+            // use a generic type.
+            if (aType.startsWith("image/")) {
+                intent.setType(aType);
+            } else {
+                intent.setType("image/*");
+            }
+        } catch (IOException e) {
+            if (!isDataURI) {
+               // If we failed, at least send through the URL link
+               intent.putExtra(Intent.EXTRA_TEXT, aSrc);
+               intent.setType("text/plain");
+            } else {
+               showImageShareFailureToast();
+               return;
+            }
+        } finally {
+            safeStreamClose(os);
+        }
+        getContext().startActivity(Intent.createChooser(intent,
+                getContext().getResources().getString(R.string.share_title)));
+    }
+
+    // Don't fail silently, tell the user that we weren't able to share the image
+    private static final void showImageShareFailureToast() {
+        Toast toast = Toast.makeText(getContext(),
+                                     getContext().getResources().getString(R.string.share_image_failed),
+                                     Toast.LENGTH_SHORT);
+        toast.show();
+    }
+
+    static boolean isUriSafeForScheme(Uri aUri) {
+        // Bug 794034 - We don't want to pass MWI or USSD codes to the
+        // dialer, and ensure the Uri class doesn't parse a URI
+        // containing a fragment ('#')
+        final String scheme = aUri.getScheme();
+        if ("tel".equals(scheme) || "sms".equals(scheme)) {
+            final String number = aUri.getSchemeSpecificPart();
+            if (number.contains("#") || number.contains("*") || aUri.getFragment() != null) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Given the inputs to <code>getOpenURIIntent</code>, plus an optional
+     * package name and class name, create and fire an intent to open the
+     * provided URI. If a class name is specified but a package name is not,
+     * we will default to using the current fennec package.
+     *
+     * @param targetURI the string spec of the URI to open.
+     * @param mimeType an optional MIME type string.
+     * @param packageName an optional app package name.
+     * @param className an optional intent class name.
+     * @param action an Android action specifier, such as
+     *               <code>Intent.ACTION_SEND</code>.
+     * @param title the title to use in <code>ACTION_SEND</code> intents.
+     * @return true if the activity started successfully; false otherwise.
+     */
+    @WrapElementForJNI
+    public static boolean openUriExternal(String targetURI,
+                                          String mimeType,
+              @OptionalGeneratedParameter String packageName,
+              @OptionalGeneratedParameter String className,
+              @OptionalGeneratedParameter String action,
+              @OptionalGeneratedParameter String title) {
+        final Context context = getContext();
+        final Intent intent = getOpenURIIntent(context, targetURI,
+                                               mimeType, action, title);
+
+        if (intent == null) {
+            return false;
+        }
+
+        if (!TextUtils.isEmpty(className)) {
+            if (!TextUtils.isEmpty(packageName)) {
+                intent.setClassName(packageName, className);
+            } else {
+                // Default to using the fennec app context.
+                intent.setClassName(context, className);
+            }
+        }
+
+        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        try {
+            context.startActivity(intent);
+            return true;
+        } catch (ActivityNotFoundException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Return a <code>Uri</code> instance which is equivalent to <code>u</code>,
+     * but with a guaranteed-lowercase scheme as if the API level 16 method
+     * <code>u.normalizeScheme</code> had been called.
+     *
+     * @param u the <code>Uri</code> to normalize.
+     * @return a <code>Uri</code>, which might be <code>u</code>.
+     */
+    static Uri normalizeUriScheme(final Uri u) {
+        final String scheme = u.getScheme();
+        final String lower  = scheme.toLowerCase(Locale.US);
+        if (lower.equals(scheme)) {
+            return u;
+        }
+
+        // Otherwise, return a new URI with a normalized scheme.
+        return u.buildUpon().scheme(lower).build();
+    }
+
+    /**
+     * Given a URI, a MIME type, and a title,
+     * produce a share intent which can be used to query all activities
+     * than can open the specified URI.
+     *
+     * @param context a <code>Context</code> instance.
+     * @param targetURI the string spec of the URI to open.
+     * @param mimeType an optional MIME type string.
+     * @param title the title to use in <code>ACTION_SEND</code> intents.
+     * @return an <code>Intent</code>, or <code>null</code> if none could be
+     *         produced.
+     */
+    public static Intent getShareIntent(final Context context,
+                                        final String targetURI,
+                                        final String mimeType,
+                                        final String title) {
+        Intent shareIntent = getIntentForActionString(Intent.ACTION_SEND);
+        shareIntent.putExtra(Intent.EXTRA_TEXT, targetURI);
+        shareIntent.putExtra(Intent.EXTRA_SUBJECT, title);
+
+        // Note that EXTRA_TITLE is intended to be used for share dialog
+        // titles. Common usage (e.g., Pocket) suggests that it's sometimes
+        // interpreted as an alternate to EXTRA_SUBJECT, so we include it.
+        shareIntent.putExtra(Intent.EXTRA_TITLE, title);
+
+        if (mimeType != null && mimeType.length() > 0) {
+            shareIntent.setType(mimeType);
+        }
+
+        return shareIntent;
+    }
+
+    /**
+     * Given a URI, a MIME type, an Android intent "action", and a title,
+     * produce an intent which can be used to start an activity to open
+     * the specified URI.
+     *
+     * @param context a <code>Context</code> instance.
+     * @param targetURI the string spec of the URI to open.
+     * @param mimeType an optional MIME type string.
+     * @param action an Android action specifier, such as
+     *               <code>Intent.ACTION_SEND</code>.
+     * @param title the title to use in <code>ACTION_SEND</code> intents.
+     * @return an <code>Intent</code>, or <code>null</code> if none could be
+     *         produced.
+     */
+    static Intent getOpenURIIntent(final Context context,
+                                   final String targetURI,
+                                   final String mimeType,
+                                   final String action,
+                                   final String title) {
+
+        if (action.equalsIgnoreCase(Intent.ACTION_SEND)) {
+            Intent shareIntent = getShareIntent(context, targetURI, mimeType, title);
+            return Intent.createChooser(shareIntent,
+                                        context.getResources().getString(R.string.share_title)); 
+        }
+
+        final Uri uri = normalizeUriScheme(targetURI.indexOf(':') >= 0 ? Uri.parse(targetURI) : new Uri.Builder().scheme(targetURI).build());
+        if (mimeType.length() > 0) {
+            Intent intent = getIntentForActionString(action);
+            intent.setDataAndType(uri, mimeType);
+            return intent;
+        }
+
+        if (!isUriSafeForScheme(uri)) {
+            return null;
+        }
+
+        final String scheme = uri.getScheme();
+
+        final Intent intent;
+
+        // Compute our most likely intent, then check to see if there are any
+        // custom handlers that would apply.
+        // Start with the original URI. If we end up modifying it, we'll
+        // overwrite it.
+        final Intent likelyIntent = getIntentForActionString(action);
+        likelyIntent.setData(uri);
+
+        if ("vnd.youtube".equals(scheme) && !hasHandlersForIntent(likelyIntent)) {
+            // Special-case YouTube to use our own player if no system handler
+            // exists.
+            intent = new Intent(VideoPlayer.VIDEO_ACTION);
+            intent.setClassName(AppConstants.ANDROID_PACKAGE_NAME,
+                                "org.mozilla.gecko.VideoPlayer");
+            intent.setData(uri);
+        } else {
+            intent = likelyIntent;
+        }
+
+        // Have a special handling for SMS, as the message body
+        // is not extracted from the URI automatically.
+        if (!"sms".equals(scheme)) {
+            return intent;
+        }
+
+        final String query = uri.getEncodedQuery();
+        if (TextUtils.isEmpty(query)) {
+            return intent;
+        }
+
+        final String[] fields = query.split("&");
+        boolean foundBody = false;
+        String resultQuery = "";
+        for (String field : fields) {
+            if (foundBody || !field.startsWith("body=")) {
+                resultQuery = resultQuery.concat(resultQuery.length() > 0 ? "&" + field : field);
+                continue;
+            }
+
+            // Found the first body param. Put it into the intent.
+            final String body = Uri.decode(field.substring(5));
+            intent.putExtra("sms_body", body);
+            foundBody = true;
+        }
+
+        if (!foundBody) {
+            // No need to rewrite the URI, then.
+            return intent;
+        }
+
+        // Form a new URI without the body field in the query part, and
+        // push that into the new Intent.
+        final String newQuery = resultQuery.length() > 0 ? "?" + resultQuery : "";
+        final Uri pruned = uri.buildUpon().encodedQuery(newQuery).build();
+        intent.setData(pruned);
+
+        return intent;
+    }
+
+    public static void setNotificationClient(NotificationClient client) {
+        if (sNotificationClient == null) {
+            sNotificationClient = client;
+        } else {
+            Log.d(LOGTAG, "Notification client already set");
+        }
+    }
+
+    @WrapElementForJNI(stubName = "ShowAlertNotificationWrapper")
+    public static void showAlertNotification(String aImageUrl, String aAlertTitle, String aAlertText,
+                                             String aAlertCookie, String aAlertName) {
+        // The intent to launch when the user clicks the expanded notification
+        String app = getContext().getClass().getName();
+        Intent notificationIntent = new Intent(GeckoApp.ACTION_ALERT_CALLBACK);
+        notificationIntent.setClassName(AppConstants.ANDROID_PACKAGE_NAME, app);
+        notificationIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+        int notificationID = aAlertName.hashCode();
+
+        // Put the strings into the intent as an URI "alert:?name=<alertName>&app=<appName>&cookie=<cookie>"
+        Uri.Builder b = new Uri.Builder();
+        Uri dataUri = b.scheme("alert").path(Integer.toString(notificationID))
+                                       .appendQueryParameter("name", aAlertName)
+                                       .appendQueryParameter("cookie", aAlertCookie)
+                                       .build();
+        notificationIntent.setData(dataUri);
+        PendingIntent contentIntent = PendingIntent.getActivity(
+                getContext(), 0, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+
+        mAlertCookies.put(aAlertName, aAlertCookie);
+        callObserver(aAlertName, "alertshow", aAlertCookie);
+
+        sNotificationClient.add(notificationID, aImageUrl, aAlertTitle, aAlertText, contentIntent);
+    }
+
+    @WrapElementForJNI
+    public static void alertsProgressListener_OnProgress(String aAlertName, long aProgress, long aProgressMax, String aAlertText) {
+        int notificationID = aAlertName.hashCode();
+        sNotificationClient.update(notificationID, aProgress, aProgressMax, aAlertText);
+    }
+
+    @WrapElementForJNI
+    public static void closeNotification(String aAlertName) {
+        String alertCookie = mAlertCookies.get(aAlertName);
+        if (alertCookie != null) {
+            callObserver(aAlertName, "alertfinished", alertCookie);
+            mAlertCookies.remove(aAlertName);
+        }
+
+        removeObserver(aAlertName);
+
+        int notificationID = aAlertName.hashCode();
+        sNotificationClient.remove(notificationID);
+    }
+
+    public static void handleNotification(String aAction, String aAlertName, String aAlertCookie) {
+        int notificationID = aAlertName.hashCode();
+
+        if (GeckoApp.ACTION_ALERT_CALLBACK.equals(aAction)) {
+            callObserver(aAlertName, "alertclickcallback", aAlertCookie);
+
+            if (sNotificationClient.isOngoing(notificationID)) {
+                // When clicked, keep the notification if it displays progress
+                return;
+            }
+        }
+        closeNotification(aAlertName);
+    }
+
+    @WrapElementForJNI(stubName = "GetDpiWrapper")
+    public static int getDpi() {
+        if (sDensityDpi == 0) {
+            sDensityDpi = getContext().getResources().getDisplayMetrics().densityDpi;
+        }
+
+        return sDensityDpi;
+    }
+
+    @WrapElementForJNI
+    public static float getDensity() {
+        return getContext().getResources().getDisplayMetrics().density;
+    }
+
+    private static boolean isHighMemoryDevice() {
+        return HardwareUtils.getMemSize() > HIGH_MEMORY_DEVICE_THRESHOLD_MB;
+    }
+
+    /**
+     * Returns the colour depth of the default screen. This will either be
+     * 24 or 16.
+     */
+    @WrapElementForJNI(stubName = "GetScreenDepthWrapper")
+    public static synchronized int getScreenDepth() {
+        if (sScreenDepth == 0) {
+            sScreenDepth = 16;
+            PixelFormat info = new PixelFormat();
+            PixelFormat.getPixelFormatInfo(getGeckoInterface().getActivity().getWindowManager().getDefaultDisplay().getPixelFormat(), info);
+            if (info.bitsPerPixel >= 24 && isHighMemoryDevice()) {
+                sScreenDepth = 24;
+            }
+        }
+
+        return sScreenDepth;
+    }
+
+    public static synchronized void setScreenDepthOverride(int aScreenDepth) {
+        if (sScreenDepth != 0) {
+            Log.e(LOGTAG, "Tried to override screen depth after it's already been set");
+            return;
+        }
+
+        sScreenDepth = aScreenDepth;
+    }
+
+    @WrapElementForJNI
+    public static void setFullScreen(boolean fullscreen) {
+        if (getGeckoInterface() != null)
+            getGeckoInterface().setFullScreen(fullscreen);
+    }
+
+    @WrapElementForJNI
+    public static void performHapticFeedback(boolean aIsLongPress) {
+        // Don't perform haptic feedback if a vibration is currently playing,
+        // because the haptic feedback will nuke the vibration.
+        if (!sVibrationMaybePlaying || System.nanoTime() >= sVibrationEndTime) {
+            LayerView layerView = getLayerView();
+            layerView.performHapticFeedback(aIsLongPress ?
+                                            HapticFeedbackConstants.LONG_PRESS :
+                                            HapticFeedbackConstants.VIRTUAL_KEY);
+        }
+    }
+
+    private static Vibrator vibrator() {
+        LayerView layerView = getLayerView();
+        return (Vibrator) layerView.getContext().getSystemService(Context.VIBRATOR_SERVICE);
+    }
+
+    @WrapElementForJNI(stubName = "Vibrate1")
+    public static void vibrate(long milliseconds) {
+        sVibrationEndTime = System.nanoTime() + milliseconds * 1000000;
+        sVibrationMaybePlaying = true;
+        vibrator().vibrate(milliseconds);
+    }
+
+    @WrapElementForJNI(stubName = "VibrateA")
+    public static void vibrate(long[] pattern, int repeat) {
+        // If pattern.length is even, the last element in the pattern is a
+        // meaningless delay, so don't include it in vibrationDuration.
+        long vibrationDuration = 0;
+        int iterLen = pattern.length - (pattern.length % 2 == 0 ? 1 : 0);
+        for (int i = 0; i < iterLen; i++) {
+          vibrationDuration += pattern[i];
+        }
+
+        sVibrationEndTime = System.nanoTime() + vibrationDuration * 1000000;
+        sVibrationMaybePlaying = true;
+        vibrator().vibrate(pattern, repeat);
+    }
+
+    @WrapElementForJNI
+    public static void cancelVibrate() {
+        sVibrationMaybePlaying = false;
+        sVibrationEndTime = 0;
+        vibrator().cancel();
+    }
+
+    @WrapElementForJNI
+    public static void showInputMethodPicker() {
+        InputMethodManager imm = (InputMethodManager)
+            getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+        imm.showInputMethodPicker();
+    }
+
+    @WrapElementForJNI
+    public static void setKeepScreenOn(final boolean on) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                // TODO
+            }
+        });
+    }
+
+    @WrapElementForJNI
+    public static void notifyDefaultPrevented(final boolean defaultPrevented) {
+	    Log.d("GeckoBrowser","GeckoAppShell notifyDefaultPrevented => see more ");
+
+
+	    ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                LayerView view = getLayerView();
+	            Log.d("GeckoBrowser","GeckoAppShell notifyDefaultPrevented "+defaultPrevented+":"+view.getPanZoomController());
+	            PanZoomController controller = (view == null ? null : view.getPanZoomController());
+                if (controller != null) {
+                    controller.notifyDefaultActionPrevented(defaultPrevented);
+                }
+            }
+        });
+    }
+
+    @WrapElementForJNI
+    public static boolean isNetworkLinkUp() {
+        ConnectivityManager cm = (ConnectivityManager)
+           getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
+        try {
+            NetworkInfo info = cm.getActiveNetworkInfo();
+            if (info == null || !info.isConnected())
+                return false;
+        } catch (SecurityException se) {
+            return false;
+        }
+        return true;
+    }
+
+    @WrapElementForJNI
+    public static boolean isNetworkLinkKnown() {
+        ConnectivityManager cm = (ConnectivityManager)
+            getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
+        try {
+            if (cm.getActiveNetworkInfo() == null)
+                return false;
+        } catch (SecurityException se) {
+            return false;
+        }
+        return true;
+    }
+
+    @WrapElementForJNI
+    public static int networkLinkType() {
+        ConnectivityManager cm = (ConnectivityManager)
+            getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo info = cm.getActiveNetworkInfo();
+        if (info == null) {
+            return LINK_TYPE_UNKNOWN;
+        }
+
+        switch (info.getType()) {
+            case ConnectivityManager.TYPE_ETHERNET:
+                return LINK_TYPE_ETHERNET;
+            case ConnectivityManager.TYPE_WIFI:
+                return LINK_TYPE_WIFI;
+            case ConnectivityManager.TYPE_WIMAX:
+                return LINK_TYPE_WIMAX;
+            case ConnectivityManager.TYPE_MOBILE:
+                break; // We will handle sub-types after the switch.
+            default:
+                Log.w(LOGTAG, "Ignoring the current network type.");
+                return LINK_TYPE_UNKNOWN;
+        }
+
+        TelephonyManager tm = (TelephonyManager)
+            getContext().getSystemService(Context.TELEPHONY_SERVICE);
+        if (tm == null) {
+            Log.e(LOGTAG, "Telephony service does not exist");
+            return LINK_TYPE_UNKNOWN;
+        }
+
+        switch (tm.getNetworkType()) {
+            case TelephonyManager.NETWORK_TYPE_IDEN:
+            case TelephonyManager.NETWORK_TYPE_CDMA:
+            case TelephonyManager.NETWORK_TYPE_GPRS:
+                return LINK_TYPE_2G;
+            case TelephonyManager.NETWORK_TYPE_1xRTT:
+            case TelephonyManager.NETWORK_TYPE_EDGE:
+                return LINK_TYPE_2G; // 2.5G
+            case TelephonyManager.NETWORK_TYPE_UMTS:
+            case TelephonyManager.NETWORK_TYPE_EVDO_0:
+                return LINK_TYPE_3G;
+            case TelephonyManager.NETWORK_TYPE_HSPA:
+            case TelephonyManager.NETWORK_TYPE_HSDPA:
+            case TelephonyManager.NETWORK_TYPE_HSUPA:
+            case TelephonyManager.NETWORK_TYPE_EVDO_A:
+            case TelephonyManager.NETWORK_TYPE_EVDO_B:
+            case TelephonyManager.NETWORK_TYPE_EHRPD:
+                return LINK_TYPE_3G; // 3.5G
+            case TelephonyManager.NETWORK_TYPE_HSPAP:
+                return LINK_TYPE_3G; // 3.75G
+            case TelephonyManager.NETWORK_TYPE_LTE:
+                return LINK_TYPE_4G; // 3.9G
+            case TelephonyManager.NETWORK_TYPE_UNKNOWN:
+            default:
+                Log.w(LOGTAG, "Connected to an unknown mobile network!");
+                return LINK_TYPE_UNKNOWN;
+        }
+    }
+
+    @WrapElementForJNI(stubName = "GetSystemColoursWrapper")
+    public static int[] getSystemColors() {
+        // attrsAppearance[] must correspond to AndroidSystemColors structure in android/AndroidBridge.h
+        final int[] attrsAppearance = {
+            android.R.attr.textColor,
+            android.R.attr.textColorPrimary,
+            android.R.attr.textColorPrimaryInverse,
+            android.R.attr.textColorSecondary,
+            android.R.attr.textColorSecondaryInverse,
+            android.R.attr.textColorTertiary,
+            android.R.attr.textColorTertiaryInverse,
+            android.R.attr.textColorHighlight,
+            android.R.attr.colorForeground,
+            android.R.attr.colorBackground,
+            android.R.attr.panelColorForeground,
+            android.R.attr.panelColorBackground
+        };
+
+        int[] result = new int[attrsAppearance.length];
+
+        final ContextThemeWrapper contextThemeWrapper =
+            new ContextThemeWrapper(getContext(), android.R.style.TextAppearance);
+
+        final TypedArray appearance = contextThemeWrapper.getTheme().obtainStyledAttributes(attrsAppearance);
+
+        if (appearance != null) {
+            for (int i = 0; i < appearance.getIndexCount(); i++) {
+                int idx = appearance.getIndex(i);
+                int color = appearance.getColor(idx, 0);
+                result[idx] = color;
+            }
+            appearance.recycle();
+        }
+
+        return result;
+    }
+
+    @WrapElementForJNI
+    public static void killAnyZombies() {
+        GeckoProcessesVisitor visitor = new GeckoProcessesVisitor() {
+            @Override
+            public boolean callback(int pid) {
+                if (pid != android.os.Process.myPid())
+                    android.os.Process.killProcess(pid);
+                return true;
+            }
+        };
+            
+        EnumerateGeckoProcesses(visitor);
+    }
+
+    public static boolean checkForGeckoProcs() {
+
+        class GeckoPidCallback implements GeckoProcessesVisitor {
+            public boolean otherPidExist = false;
+            @Override
+            public boolean callback(int pid) {
+                if (pid != android.os.Process.myPid()) {
+                    otherPidExist = true;
+                    return false;
+                }
+                return true;
+            }            
+        }
+        GeckoPidCallback visitor = new GeckoPidCallback();            
+        EnumerateGeckoProcesses(visitor);
+        return visitor.otherPidExist;
+    }
+
+    interface GeckoProcessesVisitor{
+        boolean callback(int pid);
+    }
+
+    private static void EnumerateGeckoProcesses(GeckoProcessesVisitor visiter) {
+        int pidColumn = -1;
+        int userColumn = -1;
+
+        try {
+            // run ps and parse its output
+            java.lang.Process ps = Runtime.getRuntime().exec("ps");
+            BufferedReader in = new BufferedReader(new InputStreamReader(ps.getInputStream()),
+                                                   2048);
+
+            String headerOutput = in.readLine();
+
+            // figure out the column offsets.  We only care about the pid and user fields
+            StringTokenizer st = new StringTokenizer(headerOutput);
+            
+            int tokenSoFar = 0;
+            while (st.hasMoreTokens()) {
+                String next = st.nextToken();
+                if (next.equalsIgnoreCase("PID"))
+                    pidColumn = tokenSoFar;
+                else if (next.equalsIgnoreCase("USER"))
+                    userColumn = tokenSoFar;
+                tokenSoFar++;
+            }
+
+            // alright, the rest are process entries.
+            String psOutput = null;
+            while ((psOutput = in.readLine()) != null) {
+                String[] split = psOutput.split("\\s+");
+                if (split.length <= pidColumn || split.length <= userColumn)
+                    continue;
+                int uid = android.os.Process.getUidForName(split[userColumn]);
+                if (uid == android.os.Process.myUid() &&
+                    !split[split.length - 1].equalsIgnoreCase("ps")) {
+                    int pid = Integer.parseInt(split[pidColumn]);
+                    boolean keepGoing = visiter.callback(pid);
+                    if (keepGoing == false)
+                        break;
+                }
+            }
+            in.close();
+        }
+        catch (Exception e) {
+            Log.w(LOGTAG, "Failed to enumerate Gecko processes.",  e);
+        }
+    }
+
+    public static void waitForAnotherGeckoProc(){
+        int countdown = 40;
+        while (!checkForGeckoProcs() &&  --countdown > 0) {
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException ie) {}
+        }
+    }
+    public static String getAppNameByPID(int pid) {
+        BufferedReader cmdlineReader = null;
+        String path = "/proc/" + pid + "/cmdline";
+        try {
+            File cmdlineFile = new File(path);
+            if (!cmdlineFile.exists())
+                return "";
+            cmdlineReader = new BufferedReader(new FileReader(cmdlineFile));
+            return cmdlineReader.readLine().trim();
+        } catch (Exception ex) {
+            return "";
+        } finally {
+            if (null != cmdlineReader) {
+                try {
+                    cmdlineReader.close();
+                } catch (Exception e) {}
+            }
+        }
+    }
+
+    public static void listOfOpenFiles() {
+        int pidColumn = -1;
+        int nameColumn = -1;
+
+        try {
+            String filter = GeckoProfile.get(getContext()).getDir().toString();
+            Log.i(LOGTAG, "[OPENFILE] Filter: " + filter);
+
+            // run lsof and parse its output
+            java.lang.Process lsof = Runtime.getRuntime().exec("lsof");
+            BufferedReader in = new BufferedReader(new InputStreamReader(lsof.getInputStream()), 2048);
+
+            String headerOutput = in.readLine();
+            StringTokenizer st = new StringTokenizer(headerOutput);
+            int token = 0;
+            while (st.hasMoreTokens()) {
+                String next = st.nextToken();
+                if (next.equalsIgnoreCase("PID"))
+                    pidColumn = token;
+                else if (next.equalsIgnoreCase("NAME"))
+                    nameColumn = token;
+                token++;
+            }
+
+            // alright, the rest are open file entries.
+            Map<Integer, String> pidNameMap = new TreeMap<Integer, String>();
+            String output = null;
+            while ((output = in.readLine()) != null) {
+                String[] split = output.split("\\s+");
+                if (split.length <= pidColumn || split.length <= nameColumn)
+                    continue;
+                Integer pid = new Integer(split[pidColumn]);
+                String name = pidNameMap.get(pid);
+                if (name == null) {
+                    name = getAppNameByPID(pid.intValue());
+                    pidNameMap.put(pid, name);
+                }
+                String file = split[nameColumn];
+                if (!TextUtils.isEmpty(name) && !TextUtils.isEmpty(file) && file.startsWith(filter))
+                    Log.i(LOGTAG, "[OPENFILE] " + name + "(" + split[pidColumn] + ") : " + file);
+            }
+            in.close();
+        } catch (Exception e) { }
+    }
+
+    @WrapElementForJNI
+    public static void scanMedia(String aFile, String aMimeType) {
+        // If the platform didn't give us a mimetype, try to guess one from the filename
+        if (TextUtils.isEmpty(aMimeType)) {
+            int extPosition = aFile.lastIndexOf(".");
+            if (extPosition > 0 && extPosition < aFile.length() - 1) {
+                aMimeType = getMimeTypeFromExtension(aFile.substring(extPosition+1));
+            }
+        }
+
+        Context context = getContext();
+        GeckoMediaScannerClient.startScan(context, aFile, aMimeType);
+    }
+
+    @WrapElementForJNI(stubName = "GetIconForExtensionWrapper")
+    public static byte[] getIconForExtension(String aExt, int iconSize) {
+        try {
+            if (iconSize <= 0)
+                iconSize = 16;
+
+            if (aExt != null && aExt.length() > 1 && aExt.charAt(0) == '.')
+                aExt = aExt.substring(1);
+
+            PackageManager pm = getContext().getPackageManager();
+            Drawable icon = getDrawableForExtension(pm, aExt);
+            if (icon == null) {
+                // Use a generic icon
+                icon = pm.getDefaultActivityIcon();
+            }
+
+            Bitmap bitmap = ((BitmapDrawable)icon).getBitmap();
+            if (bitmap.getWidth() != iconSize || bitmap.getHeight() != iconSize)
+                bitmap = Bitmap.createScaledBitmap(bitmap, iconSize, iconSize, true);
+
+            ByteBuffer buf = ByteBuffer.allocate(iconSize * iconSize * 4);
+            bitmap.copyPixelsToBuffer(buf);
+
+            return buf.array();
+        }
+        catch (Exception e) {
+            Log.w(LOGTAG, "getIconForExtension failed.",  e);
+            return null;
+        }
+    }
+
+    private static String getMimeTypeFromExtension(String ext) {
+        final MimeTypeMap mtm = MimeTypeMap.getSingleton();
+        return mtm.getMimeTypeFromExtension(ext);
+    }
+    
+    private static Drawable getDrawableForExtension(PackageManager pm, String aExt) {
+        Intent intent = new Intent(Intent.ACTION_VIEW);
+        final String mimeType = getMimeTypeFromExtension(aExt);
+        if (mimeType != null && mimeType.length() > 0)
+            intent.setType(mimeType);
+        else
+            return null;
+
+        List<ResolveInfo> list = pm.queryIntentActivities(intent, 0);
+        if (list.size() == 0)
+            return null;
+
+        ResolveInfo resolveInfo = list.get(0);
+
+        if (resolveInfo == null)
+            return null;
+
+        ActivityInfo activityInfo = resolveInfo.activityInfo;
+
+        return activityInfo.loadIcon(pm);
+    }
+
+    @WrapElementForJNI
+    public static boolean getShowPasswordSetting() {
+        try {
+            int showPassword =
+                Settings.System.getInt(getContext().getContentResolver(),
+                                       Settings.System.TEXT_SHOW_PASSWORD, 1);
+            return (showPassword > 0);
+        }
+        catch (Exception e) {
+            return true;
+        }
+    }
+
+    @WrapElementForJNI(stubName = "AddPluginViewWrapper")
+    public static void addPluginView(View view,
+                                     float x, float y,
+                                     float w, float h,
+                                     boolean isFullScreen) {
+        if (getGeckoInterface() != null)
+             getGeckoInterface().addPluginView(view, new RectF(x, y, x + w, y + h), isFullScreen);
+    }
+
+    @WrapElementForJNI
+    public static void removePluginView(View view, boolean isFullScreen) {
+        if (getGeckoInterface() != null)
+            getGeckoInterface().removePluginView(view, isFullScreen);
+    }
+
+    /**
+     * A plugin that wish to be loaded in the WebView must provide this permission
+     * in their AndroidManifest.xml.
+     */
+    public static final String PLUGIN_ACTION = "android.webkit.PLUGIN";
+    public static final String PLUGIN_PERMISSION = "android.webkit.permission.PLUGIN";
+
+    private static final String PLUGIN_SYSTEM_LIB = "/system/lib/plugins/";
+
+    private static final String PLUGIN_TYPE = "type";
+    private static final String TYPE_NATIVE = "native";
+    static public ArrayList<PackageInfo> mPackageInfoCache = new ArrayList<PackageInfo>();
+
+    // Returns null if plugins are blocked on the device.
+    static String[] getPluginDirectories() {
+
+        // An awful hack to detect Tegra devices. Easiest way to do it without spinning up a EGL context.
+        boolean isTegra = (new File("/system/lib/hw/gralloc.tegra.so")).exists() ||
+                          (new File("/system/lib/hw/gralloc.tegra3.so")).exists();
+        if (isTegra) {
+            // disable Flash on Tegra ICS with CM9 and other custom firmware (bug 736421)
+            File vfile = new File("/proc/version");
+            FileReader vreader = null;
+            try {
+                if (vfile.canRead()) {
+                    vreader = new FileReader(vfile);
+                    String version = new BufferedReader(vreader).readLine();
+                    if (version.indexOf("CM9") != -1 ||
+                        version.indexOf("cyanogen") != -1 ||
+                        version.indexOf("Nova") != -1)
+                    {
+                        Log.w(LOGTAG, "Blocking plugins because of Tegra 2 + unofficial ICS bug (bug 736421)");
+                        return null;
+                    }
+                }
+            } catch (IOException ex) {
+                // nothing
+            } finally {
+                try {
+                    if (vreader != null) {
+                        vreader.close();
+                    }
+                } catch (IOException ex) {
+                    // nothing
+                }
+            }
+
+            // disable on KitKat (bug 957694)
+            if (Build.VERSION.SDK_INT >= 19) {
+                Log.w(LOGTAG, "Blocking plugins because of Tegra (bug 957694)");
+                return null;
+            }
+        }
+
+        ArrayList<String> directories = new ArrayList<String>();
+        PackageManager pm = getContext().getPackageManager();
+        List<ResolveInfo> plugins = pm.queryIntentServices(new Intent(PLUGIN_ACTION),
+                PackageManager.GET_SERVICES | PackageManager.GET_META_DATA);
+
+        synchronized(mPackageInfoCache) {
+
+            // clear the list of existing packageInfo objects
+            mPackageInfoCache.clear();
+
+
+            for (ResolveInfo info : plugins) {
+
+                // retrieve the plugin's service information
+                ServiceInfo serviceInfo = info.serviceInfo;
+                if (serviceInfo == null) {
+                    Log.w(LOGTAG, "Ignoring bad plugin.");
+                    continue;
+                }
+
+                // Blacklist HTC's flash lite.
+                // See bug #704516 - We're not quite sure what Flash Lite does,
+                // but loading it causes Flash to give errors and fail to draw.
+                if (serviceInfo.packageName.equals("com.htc.flashliteplugin")) {
+                    Log.w(LOGTAG, "Skipping HTC's flash lite plugin");
+                    continue;
+                }
+
+
+                // Retrieve information from the plugin's manifest.
+                PackageInfo pkgInfo;
+                try {
+                    pkgInfo = pm.getPackageInfo(serviceInfo.packageName,
+                                    PackageManager.GET_PERMISSIONS
+                                    | PackageManager.GET_SIGNATURES);
+                } catch (Exception e) {
+                    Log.w(LOGTAG, "Can't find plugin: " + serviceInfo.packageName);
+                    continue;
+                }
+
+                if (pkgInfo == null) {
+                    Log.w(LOGTAG, "Not loading plugin: " + serviceInfo.packageName + ". Could not load package information.");
+                    continue;
+                }
+
+                /*
+                 * find the location of the plugin's shared library. The default
+                 * is to assume the app is either a user installed app or an
+                 * updated system app. In both of these cases the library is
+                 * stored in the app's data directory.
+                 */
+                String directory = pkgInfo.applicationInfo.dataDir + "/lib";
+                final int appFlags = pkgInfo.applicationInfo.flags;
+                final int updatedSystemFlags = ApplicationInfo.FLAG_SYSTEM |
+                                               ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
+
+                // preloaded system app with no user updates
+                if ((appFlags & updatedSystemFlags) == ApplicationInfo.FLAG_SYSTEM) {
+                    directory = PLUGIN_SYSTEM_LIB + pkgInfo.packageName;
+                }
+
+                // check if the plugin has the required permissions
+                String permissions[] = pkgInfo.requestedPermissions;
+                if (permissions == null) {
+                    Log.w(LOGTAG, "Not loading plugin: " + serviceInfo.packageName + ". Does not have required permission.");
+                    continue;
+                }
+                boolean permissionOk = false;
+                for (String permit : permissions) {
+                    if (PLUGIN_PERMISSION.equals(permit)) {
+                        permissionOk = true;
+                        break;
+                    }
+                }
+                if (!permissionOk) {
+                    Log.w(LOGTAG, "Not loading plugin: " + serviceInfo.packageName + ". Does not have required permission (2).");
+                    continue;
+                }
+
+                // check to ensure the plugin is properly signed
+                Signature signatures[] = pkgInfo.signatures;
+                if (signatures == null) {
+                    Log.w(LOGTAG, "Not loading plugin: " + serviceInfo.packageName + ". Not signed.");
+                    continue;
+                }
+
+                // determine the type of plugin from the manifest
+                if (serviceInfo.metaData == null) {
+                    Log.e(LOGTAG, "The plugin '" + serviceInfo.name + "' has no defined type.");
+                    continue;
+                }
+
+                String pluginType = serviceInfo.metaData.getString(PLUGIN_TYPE);
+                if (!TYPE_NATIVE.equals(pluginType)) {
+                    Log.e(LOGTAG, "Unrecognized plugin type: " + pluginType);
+                    continue;
+                }
+
+                try {
+                    Class<?> cls = getPluginClass(serviceInfo.packageName, serviceInfo.name);
+
+                    //TODO implement any requirements of the plugin class here!
+                    boolean classFound = true;
+
+                    if (!classFound) {
+                        Log.e(LOGTAG, "The plugin's class' " + serviceInfo.name + "' does not extend the appropriate class.");
+                        continue;
+                    }
+
+                } catch (NameNotFoundException e) {
+                    Log.e(LOGTAG, "Can't find plugin: " + serviceInfo.packageName);
+                    continue;
+                } catch (ClassNotFoundException e) {
+                    Log.e(LOGTAG, "Can't find plugin's class: " + serviceInfo.name);
+                    continue;
+                }
+
+                // if all checks have passed then make the plugin available
+                mPackageInfoCache.add(pkgInfo);
+	            Log.w(LOGTAG, "Cuong getPlugins "+directory);
+
+	            directories.add(directory);
+            }
+        }
+
+        return directories.toArray(new String[directories.size()]);
+    }
+
+    static String getPluginPackage(String pluginLib) {
+
+        if (pluginLib == null || pluginLib.length() == 0) {
+            return null;
+        }
+
+        synchronized(mPackageInfoCache) {
+            for (PackageInfo pkgInfo : mPackageInfoCache) {
+                if (pluginLib.contains(pkgInfo.packageName)) {
+	                Log.w(LOGTAG, "Cuong getPluginPackage "+pkgInfo.packageName);
+
+	                return pkgInfo.packageName;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    static Class<?> getPluginClass(String packageName, String className)
+            throws NameNotFoundException, ClassNotFoundException {
+        Context pluginContext = getContext().createPackageContext(packageName,
+                Context.CONTEXT_INCLUDE_CODE |
+                Context.CONTEXT_IGNORE_SECURITY);
+        ClassLoader pluginCL = pluginContext.getClassLoader();
+	    Log.w(LOGTAG, "Cuong getPluginClass "+packageName+":"+className);
+
+	    return pluginCL.loadClass(className);
+    }
+
+    @WrapElementForJNI(allowMultithread = true)
+    public static Class<?> loadPluginClass(String className, String libName) {
+        if (getGeckoInterface() == null)
+            return null;
+        try {
+            final String packageName = getPluginPackage(libName);
+            final int contextFlags = Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY;
+            final Context pluginContext = getContext().createPackageContext(packageName, contextFlags);
+            Log.w(LOGTAG, "Cuong Load pluginClass " + className+":"+libName);
+            return pluginContext.getClassLoader().loadClass(className);
+        } catch (java.lang.ClassNotFoundException cnfe) {
+            Log.w(LOGTAG, "Couldn't find plugin class " + className, cnfe);
+            return null;
+        } catch (android.content.pm.PackageManager.NameNotFoundException nnfe) {
+            Log.w(LOGTAG, "Couldn't find package.", nnfe);
+            return null;
+        }
+    }
+
+    private static ContextGetter sContextGetter;
+
+    @WrapElementForJNI(allowMultithread = true)
+    public static Context getContext() {
+        return sContextGetter.getContext();
+    }
+
+    public static void setContextGetter(ContextGetter cg) {
+        sContextGetter = cg;
+    }
+
+    public static SharedPreferences getSharedPreferences() {
+        if (sContextGetter == null) {
+            throw new IllegalStateException("No ContextGetter; cannot fetch prefs.");
+        }
+        return sContextGetter.getSharedPreferences();
+    }
+
+    public interface AppStateListener {
+        public void onPause();
+        public void onResume();
+        public void onOrientationChanged();
+    }
+
+    public interface GeckoInterface {
+        public GeckoProfile getProfile();
+        public PromptService getPromptService();
+        public Activity getActivity();
+        public String getDefaultUAString();
+        public LocationListener getLocationListener();
+        public SensorEventListener getSensorEventListener();
+        public void doRestart();
+        public void setFullScreen(boolean fullscreen);
+        public void addPluginView(View view, final RectF rect, final boolean isFullScreen);
+        public void removePluginView(final View view, final boolean isFullScreen);
+        public void enableCameraView();
+        public void disableCameraView();
+        public void addAppStateListener(AppStateListener listener);
+        public void removeAppStateListener(AppStateListener listener);
+        public View getCameraView();
+        public void notifyWakeLockChanged(String topic, String state);
+        public FormAssistPopup getFormAssistPopup();
+        public boolean areTabsShown();
+        public AbsoluteLayout getPluginContainer();
+        public void notifyCheckUpdateResult(String result);
+        public boolean hasTabsSideBar();
+        public void invalidateOptionsMenu();
+    };
+
+    private static GeckoInterface sGeckoInterface;
+
+    public static GeckoInterface getGeckoInterface() {
+        return sGeckoInterface;
+    }
+
+    public static void setGeckoInterface(GeckoInterface aGeckoInterface) {
+        sGeckoInterface = aGeckoInterface;
+    }
+
+    public static android.hardware.Camera sCamera = null;
+
+    static native void cameraCallbackBridge(byte[] data);
+
+    static int kPreferedFps = 25;
+    static byte[] sCameraBuffer = null;
+
+
+    @WrapElementForJNI(stubName = "InitCameraWrapper")
+    static int[] initCamera(String aContentType, int aCamera, int aWidth, int aHeight) {
+        ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        if (getGeckoInterface() != null)
+                            getGeckoInterface().enableCameraView();
+                    } catch (Exception e) {}
+                }
+            });
+
+        // [0] = 0|1 (failure/success)
+        // [1] = width
+        // [2] = height
+        // [3] = fps
+        int[] result = new int[4];
+        result[0] = 0;
+
+        if (Build.VERSION.SDK_INT >= 9) {
+            if (android.hardware.Camera.getNumberOfCameras() == 0)
+                return result;
+        }
+
+        try {
+            // no front/back camera before API level 9
+            if (Build.VERSION.SDK_INT >= 9)
+                sCamera = android.hardware.Camera.open(aCamera);
+            else
+                sCamera = android.hardware.Camera.open();
+
+            android.hardware.Camera.Parameters params = sCamera.getParameters();
+            params.setPreviewFormat(ImageFormat.NV21);
+
+            // use the preview fps closest to 25 fps.
+            int fpsDelta = 1000;
+            try {
+                Iterator<Integer> it = params.getSupportedPreviewFrameRates().iterator();
+                while (it.hasNext()) {
+                    int nFps = it.next();
+                    if (Math.abs(nFps - kPreferedFps) < fpsDelta) {
+                        fpsDelta = Math.abs(nFps - kPreferedFps);
+                        params.setPreviewFrameRate(nFps);
+                    }
+                }
+            } catch(Exception e) {
+                params.setPreviewFrameRate(kPreferedFps);
+            }
+
+            // set up the closest preview size available
+            Iterator<android.hardware.Camera.Size> sit = params.getSupportedPreviewSizes().iterator();
+            int sizeDelta = 10000000;
+            int bufferSize = 0;
+            while (sit.hasNext()) {
+                android.hardware.Camera.Size size = sit.next();
+                if (Math.abs(size.width * size.height - aWidth * aHeight) < sizeDelta) {
+                    sizeDelta = Math.abs(size.width * size.height - aWidth * aHeight);
+                    params.setPreviewSize(size.width, size.height);
+                    bufferSize = size.width * size.height;
+                }
+            }
+
+            try {
+                if (getGeckoInterface() != null) {
+                    View cameraView = getGeckoInterface().getCameraView();
+                    if (cameraView instanceof SurfaceView) {
+                        sCamera.setPreviewDisplay(((SurfaceView)cameraView).getHolder());
+                    } else if (cameraView instanceof TextureView) {
+                        sCamera.setPreviewTexture(((TextureView)cameraView).getSurfaceTexture());
+                    }
+                }
+            } catch(IOException e) {
+                Log.w(LOGTAG, "Error setPreviewXXX:", e);
+            } catch(RuntimeException e) {
+                Log.w(LOGTAG, "Error setPreviewXXX:", e);
+            }
+
+            sCamera.setParameters(params);
+            sCameraBuffer = new byte[(bufferSize * 12) / 8];
+            sCamera.addCallbackBuffer(sCameraBuffer);
+            sCamera.setPreviewCallbackWithBuffer(new android.hardware.Camera.PreviewCallback() {
+                @Override
+                public void onPreviewFrame(byte[] data, android.hardware.Camera camera) {
+                    cameraCallbackBridge(data);
+                    if (sCamera != null)
+                        sCamera.addCallbackBuffer(sCameraBuffer);
+                }
+            });
+            sCamera.startPreview();
+            params = sCamera.getParameters();
+            result[0] = 1;
+            result[1] = params.getPreviewSize().width;
+            result[2] = params.getPreviewSize().height;
+            result[3] = params.getPreviewFrameRate();
+        } catch(RuntimeException e) {
+            Log.w(LOGTAG, "initCamera RuntimeException.", e);
+            result[0] = result[1] = result[2] = result[3] = 0;
+        }
+        return result;
+    }
+
+    @WrapElementForJNI
+    static synchronized void closeCamera() {
+        ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        if (getGeckoInterface() != null)
+                            getGeckoInterface().disableCameraView();
+                    } catch (Exception e) {}
+                }
+            });
+        if (sCamera != null) {
+            sCamera.stopPreview();
+            sCamera.release();
+            sCamera = null;
+            sCameraBuffer = null;
+        }
+    }
+
+    /**
+     * Adds a listener for a gecko event.
+     * This method is thread-safe and may be called at any time. In particular, calling it
+     * with an event that is currently being processed has the properly-defined behaviour that
+     * any added listeners will not be invoked on the event currently being processed, but
+     * will be invoked on future events of that type.
+     */
+    @RobocopTarget
+    public static void registerEventListener(String event, GeckoEventListener listener) {
+        sEventDispatcher.registerEventListener(event, listener);
+    }
+
+    public static EventDispatcher getEventDispatcher() {
+        return sEventDispatcher;
+    }
+
+    /**
+     * Remove a previously-registered listener for a gecko event.
+     * This method is thread-safe and may be called at any time. In particular, calling it
+     * with an event that is currently being processed has the properly-defined behaviour that
+     * any removed listeners will still be invoked on the event currently being processed, but
+     * will not be invoked on future events of that type.
+     */
+    @RobocopTarget
+    public static void unregisterEventListener(String event, GeckoEventListener listener) {
+        sEventDispatcher.unregisterEventListener(event, listener);
+    }
+
+    /*
+     * Battery API related methods.
+     */
+    @WrapElementForJNI
+    public static void enableBatteryNotifications() {
+        GeckoBatteryManager.enableNotifications();
+    }
+
+    @WrapElementForJNI(stubName = "HandleGeckoMessageWrapper")
+    public static void handleGeckoMessage(String message) {
+        sEventDispatcher.dispatchEvent(message);
+    }
+
+    @WrapElementForJNI
+    public static void disableBatteryNotifications() {
+        GeckoBatteryManager.disableNotifications();
+    }
+
+    @WrapElementForJNI(stubName = "GetCurrentBatteryInformationWrapper")
+    public static double[] getCurrentBatteryInformation() {
+        return GeckoBatteryManager.getCurrentInformation();
+    }
+
+    @WrapElementForJNI(stubName = "CheckURIVisited")
+    static void checkUriVisited(String uri) {
+        GlobalHistory.getInstance().checkUriVisited(uri);
+    }
+
+    @WrapElementForJNI(stubName = "MarkURIVisited")
+    static void markUriVisited(final String uri) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                GlobalHistory.getInstance().add(uri);
+            }
+        });
+    }
+
+    @WrapElementForJNI(stubName = "SetURITitle")
+    static void setUriTitle(final String uri, final String title) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                GlobalHistory.getInstance().update(uri, title);
+            }
+        });
+    }
+
+    @WrapElementForJNI
+    static void hideProgressDialog() {
+        // unused stub
+    }
+
+    /*
+     * WebSMS related methods.
+     */
+    @WrapElementForJNI(stubName = "SendMessageWrapper")
+    public static void sendMessage(String aNumber, String aMessage, int aRequestId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().send(aNumber, aMessage, aRequestId);
+    }
+
+    @WrapElementForJNI(stubName = "GetMessageWrapper")
+    public static void getMessage(int aMessageId, int aRequestId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().getMessage(aMessageId, aRequestId);
+    }
+
+    @WrapElementForJNI(stubName = "DeleteMessageWrapper")
+    public static void deleteMessage(int aMessageId, int aRequestId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().deleteMessage(aMessageId, aRequestId);
+    }
+
+    @WrapElementForJNI(stubName = "CreateMessageListWrapper")
+    public static void createMessageList(long aStartDate, long aEndDate, String[] aNumbers, int aNumbersCount, int aDeliveryState, boolean aReverse, int aRequestId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().createMessageList(aStartDate, aEndDate, aNumbers, aNumbersCount, aDeliveryState, aReverse, aRequestId);
+    }
+
+    @WrapElementForJNI(stubName = "GetNextMessageInListWrapper")
+    public static void getNextMessageInList(int aListId, int aRequestId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().getNextMessageInList(aListId, aRequestId);
+    }
+
+    @WrapElementForJNI
+    public static void clearMessageList(int aListId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().clearMessageList(aListId);
+    }
+
+    /* Called by JNI from AndroidBridge, and by reflection from tests/BaseTest.java.in */
+    @WrapElementForJNI
+    @RobocopTarget
+    public static boolean isTablet() {
+        return HardwareUtils.isTablet();
+    }
+
+    public static void viewSizeChanged() {
+        LayerView v = getLayerView();
+        if (v != null && v.isIMEEnabled()) {
+            sendEventToGecko(GeckoEvent.createBroadcastEvent(
+                    "ScrollTo:FocusedInput", ""));
+        }
+    }
+
+    @WrapElementForJNI(stubName = "GetCurrentNetworkInformationWrapper")
+    public static double[] getCurrentNetworkInformation() {
+        return GeckoNetworkManager.getInstance().getCurrentInformation();
+    }
+
+    @WrapElementForJNI
+    public static void enableNetworkNotifications() {
+        GeckoNetworkManager.getInstance().enableNotifications();
+    }
+
+    @WrapElementForJNI
+    public static void disableNetworkNotifications() {
+        GeckoNetworkManager.getInstance().disableNotifications();
+    }
+
+    // values taken from android's Base64
+    public static final int BASE64_DEFAULT = 0;
+    public static final int BASE64_URL_SAFE = 8;
+
+    /**
+     * taken from http://www.source-code.biz/base64coder/java/Base64Coder.java.txt and modified (MIT License)
+     */
+    // Mapping table from 6-bit nibbles to Base64 characters.
+    private static final byte[] map1 = new byte[64];
+    private static final byte[] map1_urlsafe;
+    static {
+      int i=0;
+      for (byte c='A'; c<='Z'; c++) map1[i++] = c;
+      for (byte c='a'; c<='z'; c++) map1[i++] = c;
+      for (byte c='0'; c<='9'; c++) map1[i++] = c;
+      map1[i++] = '+'; map1[i++] = '/';
+      map1_urlsafe = map1.clone();
+      map1_urlsafe[62] = '-'; map1_urlsafe[63] = '_'; 
+    }
+
+    // Mapping table from Base64 characters to 6-bit nibbles.
+    private static final byte[] map2 = new byte[128];
+    static {
+        for (int i=0; i<map2.length; i++) map2[i] = -1;
+        for (int i=0; i<64; i++) map2[map1[i]] = (byte)i;
+        map2['-'] = (byte)62; map2['_'] = (byte)63;
+    }
+
+    final static byte EQUALS_ASCII = (byte) '=';
+
+    /**
+     * Encodes a byte array into Base64 format.
+     * No blanks or line breaks are inserted in the output.
+     * @param in    An array containing the data bytes to be encoded.
+     * @return      A character array containing the Base64 encoded data.
+     */
+    public static byte[] encodeBase64(byte[] in, int flags) {
+        if (Build.VERSION.SDK_INT >=Build.VERSION_CODES.FROYO)
+            return Base64.encode(in, flags | Base64.NO_WRAP);
+        int oDataLen = (in.length*4+2)/3;       // output length without padding
+        int oLen = ((in.length+2)/3)*4;         // output length including padding
+        byte[] out = new byte[oLen];
+        int ip = 0;
+        int iEnd = in.length;
+        int op = 0;
+        byte[] toMap = ((flags & BASE64_URL_SAFE) == 0 ? map1 : map1_urlsafe);
+        while (ip < iEnd) {
+            int i0 = in[ip++] & 0xff;
+            int i1 = ip < iEnd ? in[ip++] & 0xff : 0;
+            int i2 = ip < iEnd ? in[ip++] & 0xff : 0;
+            int o0 = i0 >>> 2;
+            int o1 = ((i0 &   3) << 4) | (i1 >>> 4);
+            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
+            int o3 = i2 & 0x3F;
+            out[op++] = toMap[o0];
+            out[op++] = toMap[o1];
+            out[op] = op < oDataLen ? toMap[o2] : EQUALS_ASCII; op++;
+            out[op] = op < oDataLen ? toMap[o3] : EQUALS_ASCII; op++;
+        }
+        return out; 
+    }
+
+    /**
+     * Decodes a byte array from Base64 format.
+     * No blanks or line breaks are allowed within the Base64 encoded input data.
+     * @param in    A character array containing the Base64 encoded data.
+     * @param iOff  Offset of the first character in <code>in</code> to be processed.
+     * @param iLen  Number of characters to process in <code>in</code>, starting at <code>iOff</code>.
+     * @return      An array containing the decoded data bytes.
+     * @throws      IllegalArgumentException If the input is not valid Base64 encoded data.
+     */
+    public static byte[] decodeBase64(byte[] in, int flags) {
+        if (Build.VERSION.SDK_INT >=Build.VERSION_CODES.FROYO)
+            return Base64.decode(in, flags);
+        int iOff = 0;
+        int iLen = in.length;
+        if (iLen%4 != 0) throw new IllegalArgumentException ("Length of Base64 encoded input string is not a multiple of 4.");
+        while (iLen > 0 && in[iOff+iLen-1] == '=') iLen--;
+        int oLen = (iLen*3) / 4;
+        byte[] out = new byte[oLen];
+        int ip = iOff;
+        int iEnd = iOff + iLen;
+        int op = 0;
+        while (ip < iEnd) {
+            int i0 = in[ip++];
+            int i1 = in[ip++];
+            int i2 = ip < iEnd ? in[ip++] : 'A';
+            int i3 = ip < iEnd ? in[ip++] : 'A';
+            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)
+                throw new IllegalArgumentException ("Illegal character in Base64 encoded data.");
+            int b0 = map2[i0];
+            int b1 = map2[i1];
+            int b2 = map2[i2];
+            int b3 = map2[i3];
+            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)
+                throw new IllegalArgumentException ("Illegal character in Base64 encoded data.");
+            int o0 = ( b0       <<2) | (b1>>>4);
+            int o1 = ((b1 & 0xf)<<4) | (b2>>>2);
+            int o2 = ((b2 &   3)<<6) |  b3;
+            out[op++] = (byte)o0;
+            if (op<oLen) out[op++] = (byte)o1;
+            if (op<oLen) out[op++] = (byte)o2; }
+        return out; 
+    }
+
+    public static byte[] decodeBase64(String s, int flags) {
+        return decodeBase64(s.getBytes(), flags);
+    }
+
+    @WrapElementForJNI(stubName = "GetScreenOrientationWrapper")
+    public static short getScreenOrientation() {
+        return GeckoScreenOrientation.getInstance().getScreenOrientation().value;
+    }
+
+    @WrapElementForJNI
+    public static void enableScreenOrientationNotifications() {
+        GeckoScreenOrientation.getInstance().enableNotifications();
+    }
+
+    @WrapElementForJNI
+    public static void disableScreenOrientationNotifications() {
+        GeckoScreenOrientation.getInstance().disableNotifications();
+    }
+
+    @WrapElementForJNI
+    public static void lockScreenOrientation(int aOrientation) {
+        GeckoScreenOrientation.getInstance().lock(aOrientation);
+    }
+
+    @WrapElementForJNI
+    public static void unlockScreenOrientation() {
+        GeckoScreenOrientation.getInstance().unlock();
+    }
+
+    @WrapElementForJNI
+    public static boolean pumpMessageLoop() {
+        Handler geckoHandler = ThreadUtils.sGeckoHandler;
+        Message msg = getNextMessageFromQueue(ThreadUtils.sGeckoQueue);
+
+        if (msg == null)
+            return false;
+        if (msg.obj == geckoHandler && msg.getTarget() == geckoHandler) {
+            // Our "queue is empty" message; see runGecko()
+            msg.recycle();
+            return false;
+        }
+        if (msg.getTarget() == null) 
+            Looper.myLooper().quit();
+        else
+            msg.getTarget().dispatchMessage(msg);
+        msg.recycle();
+        return true;
+    }
+
+    @WrapElementForJNI
+    public static void notifyWakeLockChanged(String topic, String state) {
+        if (getGeckoInterface() != null)
+            getGeckoInterface().notifyWakeLockChanged(topic, state);
+    }
+
+    @WrapElementForJNI
+    public static void registerSurfaceTextureFrameListener(Object surfaceTexture, final int id) {
+        ((SurfaceTexture)surfaceTexture).setOnFrameAvailableListener(new SurfaceTexture.OnFrameAvailableListener() {
+            @Override
+            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
+                GeckoAppShell.onSurfaceTextureFrameAvailable(surfaceTexture, id);
+            }
+        });
+    }
+
+    @WrapElementForJNI(allowMultithread = true)
+    public static void unregisterSurfaceTextureFrameListener(Object surfaceTexture) {
+        ((SurfaceTexture)surfaceTexture).setOnFrameAvailableListener(null);
+    }
+
+    @WrapElementForJNI
+    public static boolean unlockProfile() {
+        // Try to kill any zombie Fennec's that might be running
+        GeckoAppShell.killAnyZombies();
+
+        // Then force unlock this profile
+        if (getGeckoInterface() != null) {
+            GeckoProfile profile = getGeckoInterface().getProfile();
+            File lock = profile.getFile(".parentlock");
+            return lock.exists() && lock.delete();
+        }
+        return false;
+    }
+
+    @WrapElementForJNI(stubName = "GetProxyForURIWrapper")
+    public static String getProxyForURI(String spec, String scheme, String host, int port) {
+        final ProxySelector ps = new ProxySelector();
+
+        Proxy proxy = ps.select(scheme, host);
+        if (Proxy.NO_PROXY.equals(proxy)) {
+            return "DIRECT";
+        }
+        
+        switch (proxy.type()) {
+            case HTTP:
+                return "PROXY " + proxy.address().toString();
+            case SOCKS:
+                return "SOCKS " + proxy.address().toString();
+        }
+
+        return "DIRECT";
+    }
+
+}
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/GeckoAppShell.java~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/GeckoAppShell.java~	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,2683 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.gecko;
+
+import java.io.BufferedReader;
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.net.Proxy;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.StringTokenizer;
+import java.util.TreeMap;
+
+import org.mozilla.gecko.favicons.OnFaviconLoadedListener;
+import org.mozilla.gecko.favicons.decoders.FaviconDecoder;
+import org.mozilla.gecko.gfx.BitmapUtils;
+import org.mozilla.gecko.gfx.GeckoLayerClient;
+import org.mozilla.gecko.gfx.LayerView;
+import org.mozilla.gecko.gfx.PanZoomController;
+import org.mozilla.gecko.mozglue.GeckoLoader;
+import org.mozilla.gecko.mozglue.JNITarget;
+import org.mozilla.gecko.mozglue.RobocopTarget;
+import org.mozilla.gecko.mozglue.generatorannotations.OptionalGeneratedParameter;
+import org.mozilla.gecko.mozglue.generatorannotations.WrapElementForJNI;
+import org.mozilla.gecko.prompts.PromptService;
+import org.mozilla.gecko.util.GeckoEventListener;
+import org.mozilla.gecko.util.HardwareUtils;
+import org.mozilla.gecko.util.ProxySelector;
+import org.mozilla.gecko.util.ThreadUtils;
+import org.mozilla.gecko.webapp.Allocator;
+
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.PendingIntent;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+import android.content.pm.ServiceInfo;
+import android.content.pm.Signature;
+import android.content.res.TypedArray;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ImageFormat;
+import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.graphics.SurfaceTexture;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.hardware.Sensor;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.location.Criteria;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.media.MediaScannerConnection;
+import android.media.MediaScannerConnection.MediaScannerConnectionClient;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.MessageQueue;
+import android.os.SystemClock;
+import android.os.Vibrator;
+import android.provider.Settings;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+import android.util.Base64;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.ContextThemeWrapper;
+import android.view.HapticFeedbackConstants;
+import android.view.Surface;
+import android.view.SurfaceView;
+import android.view.TextureView;
+import android.view.View;
+import android.view.inputmethod.InputMethodManager;
+import android.webkit.MimeTypeMap;
+import android.widget.AbsoluteLayout;
+import android.widget.Toast;
+
+public class GeckoAppShell
+{
+    private static final String LOGTAG = "GeckoAppShell";
+
+    // static members only
+    private GeckoAppShell() { }
+
+    static private LinkedList<GeckoEvent> gPendingEvents =
+        new LinkedList<GeckoEvent>();
+
+    static private boolean gRestartScheduled = false;
+
+    static private GeckoEditableListener mEditableListener = null;
+
+    static private final HashMap<String, String>
+        mAlertCookies = new HashMap<String, String>();
+
+    // See also HardwareUtils.LOW_MEMORY_THRESHOLD_MB.
+    static private final int HIGH_MEMORY_DEVICE_THRESHOLD_MB = 768;
+
+    /* Keep in sync with constants found here:
+      http://mxr.mozilla.org/mozilla-central/source/uriloader/base/nsIWebProgressListener.idl
+    */
+    static public final int WPL_STATE_START = 0x00000001;
+    static public final int WPL_STATE_STOP = 0x00000010;
+    static public final int WPL_STATE_IS_DOCUMENT = 0x00020000;
+    static public final int WPL_STATE_IS_NETWORK = 0x00040000;
+
+    /* Keep in sync with constants found here:
+      http://mxr.mozilla.org/mozilla-central/source/netwerk/base/public/nsINetworkLinkService.idl
+    */
+    static public final int LINK_TYPE_UNKNOWN = 0;
+    static public final int LINK_TYPE_ETHERNET = 1;
+    static public final int LINK_TYPE_USB = 2;
+    static public final int LINK_TYPE_WIFI = 3;
+    static public final int LINK_TYPE_WIMAX = 4;
+    static public final int LINK_TYPE_2G = 5;
+    static public final int LINK_TYPE_3G = 6;
+    static public final int LINK_TYPE_4G = 7;
+
+    public static final String SHORTCUT_TYPE_WEBAPP = "webapp";
+    public static final String SHORTCUT_TYPE_BOOKMARK = "bookmark";
+
+    static private final boolean LOGGING = false;
+
+    static private int sDensityDpi = 0;
+    static private int sScreenDepth = 0;
+
+    private static final EventDispatcher sEventDispatcher = new EventDispatcher();
+
+    /* Default colors. */
+    private static final float[] DEFAULT_LAUNCHER_ICON_HSV = { 32.0f, 1.0f, 1.0f };
+
+    /* Is the value in sVibrationEndTime valid? */
+    private static boolean sVibrationMaybePlaying = false;
+
+    /* Time (in System.nanoTime() units) when the currently-playing vibration
+     * is scheduled to end.  This value is valid only when
+     * sVibrationMaybePlaying is true. */
+    private static long sVibrationEndTime = 0;
+
+    /* Default value of how fast we should hint the Android sensors. */
+    private static int sDefaultSensorHint = 100;
+
+    private static Sensor gAccelerometerSensor = null;
+    private static Sensor gLinearAccelerometerSensor = null;
+    private static Sensor gGyroscopeSensor = null;
+    private static Sensor gOrientationSensor = null;
+    private static Sensor gProximitySensor = null;
+    private static Sensor gLightSensor = null;
+
+    private static volatile boolean mLocationHighAccuracy;
+
+    static NotificationClient sNotificationClient;
+
+    /* The Android-side API: API methods that Android calls */
+
+    // Initialization methods
+    public static native void nativeInit();
+
+    // helper methods
+    //    public static native void setSurfaceView(GeckoSurfaceView sv);
+    public static native void setLayerClient(GeckoLayerClient client);
+    public static native void onResume();
+    public static void callObserver(String observerKey, String topic, String data) {
+        sendEventToGecko(GeckoEvent.createCallObserverEvent(observerKey, topic, data));
+    }
+    public static void removeObserver(String observerKey) {
+        sendEventToGecko(GeckoEvent.createRemoveObserverEvent(observerKey));
+    }
+    public static native Message getNextMessageFromQueue(MessageQueue queue);
+    public static native void onSurfaceTextureFrameAvailable(Object surfaceTexture, int id);
+    public static native void dispatchMemoryPressure();
+
+    public static void registerGlobalExceptionHandler() {
+        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+            @Override
+            public void uncaughtException(Thread thread, Throwable e) {
+                handleUncaughtException(thread, e);
+            }
+        });
+    }
+
+    private static String getStackTraceString(Throwable e) {
+        StringWriter sw = new StringWriter();
+        PrintWriter pw = new PrintWriter(sw);
+        e.printStackTrace(pw);
+        pw.flush();
+        return sw.toString();
+    }
+
+    private static native void reportJavaCrash(String stackTrace);
+
+    public static void notifyUriVisited(String uri) {
+        sendEventToGecko(GeckoEvent.createVisitedEvent(uri));
+    }
+
+    public static native void processNextNativeEvent(boolean mayWait);
+
+    public static native void notifyBatteryChange(double aLevel, boolean aCharging, double aRemainingTime);
+
+    public static native void scheduleComposite();
+
+    // Resuming the compositor is a synchronous request, so be
+    // careful of possible deadlock. Resuming the compositor will also cause
+    // a composition, so there is no need to schedule a composition after
+    // resuming.
+    public static native void scheduleResumeComposition(int width, int height);
+
+    public static native float computeRenderIntegrity();
+
+    public static native SurfaceBits getSurfaceBits(Surface surface);
+
+    public static native void onFullScreenPluginHidden(View view);
+
+    public static class CreateShortcutFaviconLoadedListener implements OnFaviconLoadedListener {
+        private final String title;
+        private final String url;
+
+        public CreateShortcutFaviconLoadedListener(final String url, final String title) {
+            this.url = url;
+            this.title = title;
+        }
+
+        @Override
+        public void onFaviconLoaded(String pageUrl, String faviconURL, Bitmap favicon) {
+            GeckoAppShell.createShortcut(title, url, url, favicon, "");
+        }
+    }
+
+    private static final class GeckoMediaScannerClient implements MediaScannerConnectionClient {
+        private final String mFile;
+        private final String mMimeType;
+        private MediaScannerConnection mScanner;
+
+        public static void startScan(Context context, String file, String mimeType) {
+            new GeckoMediaScannerClient(context, file, mimeType);
+        }
+
+        private GeckoMediaScannerClient(Context context, String file, String mimeType) {
+            mFile = file;
+            mMimeType = mimeType;
+            mScanner = new MediaScannerConnection(context, this);
+            mScanner.connect();
+        }
+
+        @Override
+        public void onMediaScannerConnected() {
+            mScanner.scanFile(mFile, mMimeType);
+        }
+
+        @Override
+        public void onScanCompleted(String path, Uri uri) {
+            if(path.equals(mFile)) {
+                mScanner.disconnect();
+                mScanner = null;
+            }
+        }
+    }
+
+    private static LayerView sLayerView;
+
+    public static void setLayerView(LayerView lv) {
+        sLayerView = lv;
+    }
+
+    @RobocopTarget
+    public static LayerView getLayerView() {
+        return sLayerView;
+    }
+
+    public static void runGecko(String apkPath, String args, String url, String type) {
+        // Preparation for pumpMessageLoop()
+        MessageQueue.IdleHandler idleHandler = new MessageQueue.IdleHandler() {
+            @Override public boolean queueIdle() {
+                final Handler geckoHandler = ThreadUtils.sGeckoHandler;
+                Message idleMsg = Message.obtain(geckoHandler);
+                // Use |Message.obj == GeckoHandler| to identify our "queue is empty" message
+                idleMsg.obj = geckoHandler;
+                geckoHandler.sendMessageAtFrontOfQueue(idleMsg);
+                // Keep this IdleHandler
+                return true;
+            }
+        };
+        Looper.myQueue().addIdleHandler(idleHandler);
+
+        // run gecko -- it will spawn its own thread
+        GeckoAppShell.nativeInit();
+
+        if (sLayerView != null)
+            GeckoAppShell.setLayerClient(sLayerView.getLayerClient());
+
+        // First argument is the .apk path
+        String combinedArgs = apkPath + " -greomni " + apkPath;
+        if (args != null)
+            combinedArgs += " " + args;
+        if (url != null)
+            combinedArgs += " -url " + url;
+        if (type != null)
+            combinedArgs += " " + type;
+
+        DisplayMetrics metrics = getContext().getResources().getDisplayMetrics();
+        combinedArgs += " -width " + metrics.widthPixels + " -height " + metrics.heightPixels;
+
+        ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    geckoLoaded();
+                }
+            });
+
+        // and go
+        Log.d(LOGTAG, "GeckoLoader.nativeRun " + combinedArgs);
+        GeckoLoader.nativeRun(combinedArgs);
+
+        // Remove pumpMessageLoop() idle handler
+        Looper.myQueue().removeIdleHandler(idleHandler);
+    }
+
+    // Called on the UI thread after Gecko loads.
+    private static void geckoLoaded() {
+        GeckoEditable editable = new GeckoEditable();
+        // install the gecko => editable listener
+        mEditableListener = editable;
+    }
+
+    static void sendPendingEventsToGecko() {
+        try {
+            while (!gPendingEvents.isEmpty()) {
+                GeckoEvent e = gPendingEvents.removeFirst();
+                notifyGeckoOfEvent(e);
+            }
+        } catch (NoSuchElementException e) {}
+    }
+
+    @RobocopTarget
+    public static void sendEventToGecko(GeckoEvent e) {
+        if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoRunning)) {
+            notifyGeckoOfEvent(e);
+            // Gecko will copy the event data into a normal C++ object. We can recycle the evet now.
+            e.recycle();
+        } else {
+            gPendingEvents.addLast(e);
+        }
+    }
+
+    // Tell the Gecko event loop that an event is available.
+    public static native void notifyGeckoOfEvent(GeckoEvent event);
+
+    /*
+     *  The Gecko-side API: API methods that Gecko calls
+     */
+
+    @WrapElementForJNI(allowMultithread = true, generateStatic = true, noThrow = true)
+    public static void handleUncaughtException(Thread thread, Throwable e) {
+        if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoExited)) {
+            // We've called System.exit. All exceptions after this point are Android
+            // berating us for being nasty to it.
+            return;
+        }
+
+        if (thread == null) {
+            thread = Thread.currentThread();
+        }
+        // If the uncaught exception was rethrown, walk the exception `cause` chain to find
+        // the original exception so Socorro can correctly collate related crash reports.
+        Throwable cause;
+        while ((cause = e.getCause()) != null) {
+            e = cause;
+        }
+
+        try {
+            Log.e(LOGTAG, ">>> REPORTING UNCAUGHT EXCEPTION FROM THREAD "
+                          + thread.getId() + " (\"" + thread.getName() + "\")", e);
+
+            Thread mainThread = ThreadUtils.getUiThread();
+            if (mainThread != null && thread != mainThread) {
+                Log.e(LOGTAG, "Main thread stack:");
+                for (StackTraceElement ste : mainThread.getStackTrace()) {
+                    Log.e(LOGTAG, ste.toString());
+                }
+            }
+
+            if (e instanceof OutOfMemoryError) {
+                SharedPreferences prefs = getSharedPreferences();
+                SharedPreferences.Editor editor = prefs.edit();
+                editor.putBoolean(GeckoApp.PREFS_OOM_EXCEPTION, true);
+                editor.commit();
+            }
+        } finally {
+            reportJavaCrash(getStackTraceString(e));
+        }
+    }
+
+    @WrapElementForJNI(generateStatic = true)
+    public static void notifyIME(int type) {
+        if (mEditableListener != null) {
+            mEditableListener.notifyIME(type);
+        }
+    }
+
+    @WrapElementForJNI(generateStatic = true)
+    public static void notifyIMEContext(int state, String typeHint,
+                                        String modeHint, String actionHint) {
+        if (mEditableListener != null) {
+            mEditableListener.notifyIMEContext(state, typeHint,
+                                               modeHint, actionHint);
+        }
+    }
+
+    @WrapElementForJNI(generateStatic = true)
+    public static void notifyIMEChange(String text, int start, int end, int newEnd) {
+        if (newEnd < 0) { // Selection change
+            mEditableListener.onSelectionChange(start, end);
+        } else { // Text change
+            mEditableListener.onTextChange(text, start, end, newEnd);
+        }
+    }
+
+    private static final Object sEventAckLock = new Object();
+    private static boolean sWaitingForEventAck;
+
+    // Block the current thread until the Gecko event loop is caught up
+    public static void sendEventToGeckoSync(GeckoEvent e) {
+        e.setAckNeeded(true);
+
+        long time = SystemClock.uptimeMillis();
+        boolean isUiThread = ThreadUtils.isOnUiThread();
+
+        synchronized (sEventAckLock) {
+            if (sWaitingForEventAck) {
+                // should never happen since we always leave it as false when we exit this function.
+                Log.e(LOGTAG, "geckoEventSync() may have been called twice concurrently!", new Exception());
+                // fall through for graceful handling
+            }
+
+            sendEventToGecko(e);
+            sWaitingForEventAck = true;
+            while (true) {
+                try {
+                    sEventAckLock.wait(1000);
+                } catch (InterruptedException ie) {
+                }
+                if (!sWaitingForEventAck) {
+                    // response received
+                    break;
+                }
+                long waited = SystemClock.uptimeMillis() - time;
+                Log.d(LOGTAG, "Gecko event sync taking too long: " + waited + "ms");
+            }
+        }
+    }
+
+    // Signal the Java thread that it's time to wake up
+    @WrapElementForJNI
+    public static void acknowledgeEvent() {
+        synchronized (sEventAckLock) {
+            sWaitingForEventAck = false;
+            sEventAckLock.notifyAll();
+        }
+    }
+
+    private static float getLocationAccuracy(Location location) {
+        float radius = location.getAccuracy();
+        return (location.hasAccuracy() && radius > 0) ? radius : 1001;
+    }
+
+    private static Location getLastKnownLocation(LocationManager lm) {
+        Location lastKnownLocation = null;
+        List<String> providers = lm.getAllProviders();
+
+        for (String provider : providers) {
+            Location location = lm.getLastKnownLocation(provider);
+            if (location == null) {
+                continue;
+            }
+
+            if (lastKnownLocation == null) {
+                lastKnownLocation = location;
+                continue;
+            }
+
+            long timeDiff = location.getTime() - lastKnownLocation.getTime();
+            if (timeDiff > 0 ||
+                (timeDiff == 0 &&
+                 getLocationAccuracy(location) < getLocationAccuracy(lastKnownLocation))) {
+                lastKnownLocation = location;
+            }
+        }
+
+        return lastKnownLocation;
+    }
+
+    @WrapElementForJNI
+    public static void enableLocation(final boolean enable) {
+        ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    LocationManager lm = getLocationManager(getContext());
+                    if (lm == null) {
+                        return;
+                    }
+
+                    if (enable) {
+                        Location lastKnownLocation = getLastKnownLocation(lm);
+                        if (lastKnownLocation != null) {
+                            getGeckoInterface().getLocationListener().onLocationChanged(lastKnownLocation);
+                        }
+
+                        Criteria criteria = new Criteria();
+                        criteria.setSpeedRequired(false);
+                        criteria.setBearingRequired(false);
+                        criteria.setAltitudeRequired(false);
+                        if (mLocationHighAccuracy) {
+                            criteria.setAccuracy(Criteria.ACCURACY_FINE);
+                            criteria.setCostAllowed(true);
+                            criteria.setPowerRequirement(Criteria.POWER_HIGH);
+                        } else {
+                            criteria.setAccuracy(Criteria.ACCURACY_COARSE);
+                            criteria.setCostAllowed(false);
+                            criteria.setPowerRequirement(Criteria.POWER_LOW);
+                        }
+
+                        String provider = lm.getBestProvider(criteria, true);
+                        if (provider == null)
+                            return;
+
+                        Looper l = Looper.getMainLooper();
+                        lm.requestLocationUpdates(provider, 100, (float).5, getGeckoInterface().getLocationListener(), l);
+                    } else {
+                        lm.removeUpdates(getGeckoInterface().getLocationListener());
+                    }
+                }
+            });
+    }
+
+    private static LocationManager getLocationManager(Context context) {
+        try {
+            return (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
+        } catch (NoSuchFieldError e) {
+            // Some Tegras throw exceptions about missing the CONTROL_LOCATION_UPDATES permission,
+            // which allows enabling/disabling location update notifications from the cell radio.
+            // CONTROL_LOCATION_UPDATES is not for use by normal applications, but we might be
+            // hitting this problem if the Tegras are confused about missing cell radios.
+            Log.e(LOGTAG, "LOCATION_SERVICE not found?!", e);
+            return null;
+        }
+    }
+
+    @WrapElementForJNI
+    public static void enableLocationHighAccuracy(final boolean enable) {
+        mLocationHighAccuracy = enable;
+    }
+
+    @WrapElementForJNI
+    public static void enableSensor(int aSensortype) {
+        GeckoInterface gi = getGeckoInterface();
+        if (gi == null)
+            return;
+        SensorManager sm = (SensorManager)
+            getContext().getSystemService(Context.SENSOR_SERVICE);
+
+        switch(aSensortype) {
+        case GeckoHalDefines.SENSOR_ORIENTATION:
+            if(gOrientationSensor == null)
+                gOrientationSensor = sm.getDefaultSensor(Sensor.TYPE_ORIENTATION);
+            if (gOrientationSensor != null) 
+                sm.registerListener(gi.getSensorEventListener(), gOrientationSensor, sDefaultSensorHint);
+            break;
+
+        case GeckoHalDefines.SENSOR_ACCELERATION:
+            if(gAccelerometerSensor == null)
+                gAccelerometerSensor = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
+            if (gAccelerometerSensor != null)
+                sm.registerListener(gi.getSensorEventListener(), gAccelerometerSensor, sDefaultSensorHint);
+            break;
+
+        case GeckoHalDefines.SENSOR_PROXIMITY:
+            if(gProximitySensor == null  )
+                gProximitySensor = sm.getDefaultSensor(Sensor.TYPE_PROXIMITY);
+            if (gProximitySensor != null)
+                sm.registerListener(gi.getSensorEventListener(), gProximitySensor, SensorManager.SENSOR_DELAY_NORMAL);
+            break;
+
+        case GeckoHalDefines.SENSOR_LIGHT:
+            if(gLightSensor == null)
+                gLightSensor = sm.getDefaultSensor(Sensor.TYPE_LIGHT);
+            if (gLightSensor != null)
+                sm.registerListener(gi.getSensorEventListener(), gLightSensor, SensorManager.SENSOR_DELAY_NORMAL);
+            break;
+
+        case GeckoHalDefines.SENSOR_LINEAR_ACCELERATION:
+            if(gLinearAccelerometerSensor == null)
+                gLinearAccelerometerSensor = sm.getDefaultSensor(10 /* API Level 9 - TYPE_LINEAR_ACCELERATION */);
+            if (gLinearAccelerometerSensor != null)
+                sm.registerListener(gi.getSensorEventListener(), gLinearAccelerometerSensor, sDefaultSensorHint);
+            break;
+
+        case GeckoHalDefines.SENSOR_GYROSCOPE:
+            if(gGyroscopeSensor == null)
+                gGyroscopeSensor = sm.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
+            if (gGyroscopeSensor != null)
+                sm.registerListener(gi.getSensorEventListener(), gGyroscopeSensor, sDefaultSensorHint);
+            break;
+        default:
+            Log.w(LOGTAG, "Error! Can't enable unknown SENSOR type " + aSensortype);
+        }
+    }
+
+    @WrapElementForJNI
+    public static void disableSensor(int aSensortype) {
+        GeckoInterface gi = getGeckoInterface();
+        if (gi == null)
+            return;
+
+        SensorManager sm = (SensorManager)
+            getContext().getSystemService(Context.SENSOR_SERVICE);
+
+        switch (aSensortype) {
+        case GeckoHalDefines.SENSOR_ORIENTATION:
+            if (gOrientationSensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gOrientationSensor);
+            break;
+
+        case GeckoHalDefines.SENSOR_ACCELERATION:
+            if (gAccelerometerSensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gAccelerometerSensor);
+            break;
+
+        case GeckoHalDefines.SENSOR_PROXIMITY:
+            if (gProximitySensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gProximitySensor);
+            break;
+
+        case GeckoHalDefines.SENSOR_LIGHT:
+            if (gLightSensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gLightSensor);
+            break;
+
+        case GeckoHalDefines.SENSOR_LINEAR_ACCELERATION:
+            if (gLinearAccelerometerSensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gLinearAccelerometerSensor);
+            break;
+
+        case GeckoHalDefines.SENSOR_GYROSCOPE:
+            if (gGyroscopeSensor != null)
+                sm.unregisterListener(gi.getSensorEventListener(), gGyroscopeSensor);
+            break;
+        default:
+            Log.w(LOGTAG, "Error! Can't disable unknown SENSOR type " + aSensortype);
+        }
+    }
+
+    @WrapElementForJNI
+    public static void moveTaskToBack() {
+        if (getGeckoInterface() != null)
+            getGeckoInterface().getActivity().moveTaskToBack(true);
+    }
+
+    public static void returnIMEQueryResult(String result, int selectionStart, int selectionLength) {
+        // This method may be called from JNI to report Gecko's current selection indexes, but
+        // Native Fennec doesn't care because the Java code already knows the selection indexes.
+    }
+
+    @WrapElementForJNI(stubName = "NotifyXreExit")
+    static void onXreExit() {
+        // The launch state can only be Launched or GeckoRunning at this point
+        GeckoThread.setLaunchState(GeckoThread.LaunchState.GeckoExiting);
+        if (getGeckoInterface() != null) {
+            if (gRestartScheduled) {
+                getGeckoInterface().doRestart();
+            } else {
+                getGeckoInterface().getActivity().finish();
+            }
+        }
+
+        systemExit();
+    }
+
+    static void systemExit() {
+        Log.d(LOGTAG, "Killing via System.exit()");
+        GeckoThread.setLaunchState(GeckoThread.LaunchState.GeckoExited);
+        System.exit(0);
+    }
+
+    @WrapElementForJNI
+    static void scheduleRestart() {
+        gRestartScheduled = true;
+    }
+
+    public static Intent getWebappIntent(String aURI, String aOrigin, String aTitle, Bitmap aIcon) {
+        Intent intent;
+
+        if (AppConstants.MOZ_ANDROID_SYNTHAPKS) {
+            Allocator slots = Allocator.getInstance(getContext());
+            int index = slots.getIndexForOrigin(aOrigin);
+
+            if (index == -1) {
+                return null;
+            }
+            String packageName = slots.getAppForIndex(index);
+            intent = getContext().getPackageManager().getLaunchIntentForPackage(packageName);
+            if (aURI != null) {
+                intent.setData(Uri.parse(aURI));
+            }
+        } else {
+            int index;
+            if (aIcon != null && !TextUtils.isEmpty(aTitle))
+                index = WebappAllocator.getInstance(getContext()).findAndAllocateIndex(aOrigin, aTitle, aIcon);
+            else
+                index = WebappAllocator.getInstance(getContext()).getIndexForApp(aOrigin);
+
+            if (index == -1)
+                return null;
+
+            intent = getWebappIntent(index, aURI);
+        }
+
+        return intent;
+    }
+
+    // The old implementation of getWebappIntent.  Not used by MOZ_ANDROID_SYNTHAPKS.
+    public static Intent getWebappIntent(int aIndex, String aURI) {
+        Intent intent = new Intent();
+        intent.setAction(GeckoApp.ACTION_WEBAPP_PREFIX + aIndex);
+        intent.setData(Uri.parse(aURI));
+        intent.setClassName(AppConstants.ANDROID_PACKAGE_NAME,
+                            AppConstants.ANDROID_PACKAGE_NAME + ".WebApps$WebApp" + aIndex);
+        return intent;
+    }
+
+    // "Installs" an application by creating a shortcut
+    // This is the entry point from AndroidBridge.h
+    @WrapElementForJNI
+    static void createShortcut(String aTitle, String aURI, String aIconData, String aType) {
+        if ("webapp".equals(aType)) {
+            Log.w(LOGTAG, "createShortcut with no unique URI should not be used for aType = webapp!");
+        }
+
+        createShortcut(aTitle, aURI, aURI, aIconData, aType);
+    }
+
+    // For non-webapps.
+    public static void createShortcut(String aTitle, String aURI, Bitmap aBitmap, String aType) {
+        createShortcut(aTitle, aURI, aURI, aBitmap, aType);
+    }
+
+    // Internal, for webapps.
+    static void createShortcut(final String aTitle, final String aURI, final String aUniqueURI, final String aIconData, final String aType) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                // TODO: use the cache. Bug 961600.
+                Bitmap icon = FaviconDecoder.getMostSuitableBitmapFromDataURI(aIconData, getPreferredIconSize());
+                GeckoAppShell.doCreateShortcut(aTitle, aURI, aURI, icon, aType);
+            }
+        });
+    }
+
+    public static void createShortcut(final String aTitle, final String aURI, final String aUniqueURI,
+                                      final Bitmap aIcon, final String aType) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                GeckoAppShell.doCreateShortcut(aTitle, aURI, aUniqueURI, aIcon, aType);
+            }
+        });
+    }
+
+    /**
+     * Call this method only on the background thread.
+     */
+    private static void doCreateShortcut(final String aTitle, final String aURI, final String aUniqueURI,
+                                         final Bitmap aIcon, final String aType) {
+        // The intent to be launched by the shortcut.
+        Intent shortcutIntent;
+        if (aType.equalsIgnoreCase(SHORTCUT_TYPE_WEBAPP)) {
+            shortcutIntent = getWebappIntent(aURI, aUniqueURI, aTitle, aIcon);
+        } else {
+            shortcutIntent = new Intent();
+            shortcutIntent.setAction(GeckoApp.ACTION_BOOKMARK);
+            shortcutIntent.setData(Uri.parse(aURI));
+            shortcutIntent.setClassName(AppConstants.ANDROID_PACKAGE_NAME,
+                                        AppConstants.BROWSER_INTENT_CLASS);
+        }
+
+        Intent intent = new Intent();
+        intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
+        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON, getLauncherIcon(aIcon, aType));
+
+        if (aTitle != null) {
+            intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, aTitle);
+        } else {
+            intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, aURI);
+        }
+
+        // Do not allow duplicate items.
+        intent.putExtra("duplicate", false);
+
+        intent.setAction("com.android.launcher.action.INSTALL_SHORTCUT");
+        getContext().sendBroadcast(intent);
+    }
+
+    public static void removeShortcut(final String aTitle, final String aURI, final String aType) {
+        removeShortcut(aTitle, aURI, null, aType);
+    }
+
+    public static void removeShortcut(final String aTitle, final String aURI, final String aUniqueURI, final String aType) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                // the intent to be launched by the shortcut
+                Intent shortcutIntent;
+                if (aType.equalsIgnoreCase(SHORTCUT_TYPE_WEBAPP)) {
+                    shortcutIntent = getWebappIntent(aURI, aUniqueURI, "", null);
+                    if (shortcutIntent == null)
+                        return;
+                } else {
+                    shortcutIntent = new Intent();
+                    shortcutIntent.setAction(GeckoApp.ACTION_BOOKMARK);
+                    shortcutIntent.setClassName(AppConstants.ANDROID_PACKAGE_NAME,
+                                                AppConstants.BROWSER_INTENT_CLASS);
+                    shortcutIntent.setData(Uri.parse(aURI));
+                }
+        
+                Intent intent = new Intent();
+                intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
+                if (aTitle != null)
+                    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, aTitle);
+                else
+                    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, aURI);
+
+                intent.setAction("com.android.launcher.action.UNINSTALL_SHORTCUT");
+                getContext().sendBroadcast(intent);
+            }
+        });
+    }
+
+    @JNITarget
+    static public int getPreferredIconSize() {
+        if (android.os.Build.VERSION.SDK_INT >= 11) {
+            ActivityManager am = (ActivityManager)getContext().getSystemService(Context.ACTIVITY_SERVICE);
+            return am.getLauncherLargeIconSize();
+        } else {
+            switch (getDpi()) {
+                case DisplayMetrics.DENSITY_MEDIUM:
+                    return 48;
+                case DisplayMetrics.DENSITY_XHIGH:
+                    return 96;
+                case DisplayMetrics.DENSITY_HIGH:
+                default:
+                    return 72;
+            }
+        }
+    }
+
+    static private Bitmap getLauncherIcon(Bitmap aSource, String aType) {
+        final int kOffset = 6;
+        final int kRadius = 5;
+        int size = getPreferredIconSize();
+        int insetSize = aSource != null ? size * 2 / 3 : size;
+
+        Bitmap bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);
+        Canvas canvas = new Canvas(bitmap);
+
+
+        // draw a base color
+        Paint paint = new Paint();
+        if (aSource == null) {
+            // If we aren't drawing a favicon, just use an orange color.
+            paint.setColor(Color.HSVToColor(DEFAULT_LAUNCHER_ICON_HSV));
+            canvas.drawRoundRect(new RectF(kOffset, kOffset, size - kOffset, size - kOffset), kRadius, kRadius, paint);
+        } else if (aType.equalsIgnoreCase(SHORTCUT_TYPE_WEBAPP) || aSource.getWidth() >= insetSize || aSource.getHeight() >= insetSize) {
+            // otherwise, if this is a webapp or if the icons is lare enough, just draw it
+            Rect iconBounds = new Rect(0, 0, size, size);
+            canvas.drawBitmap(aSource, null, iconBounds, null);
+            return bitmap;
+        } else {
+            // otherwise use the dominant color from the icon + a layer of transparent white to lighten it somewhat
+            int color = BitmapUtils.getDominantColor(aSource);
+            paint.setColor(color);
+            canvas.drawRoundRect(new RectF(kOffset, kOffset, size - kOffset, size - kOffset), kRadius, kRadius, paint);
+            paint.setColor(Color.argb(100, 255, 255, 255));
+            canvas.drawRoundRect(new RectF(kOffset, kOffset, size - kOffset, size - kOffset), kRadius, kRadius, paint);
+        }
+
+        // draw the overlay
+        Bitmap overlay = BitmapUtils.decodeResource(getContext(), R.drawable.home_bg);
+        canvas.drawBitmap(overlay, null, new Rect(0, 0, size, size), null);
+
+        // draw the favicon
+        if (aSource == null)
+            aSource = BitmapUtils.decodeResource(getContext(), R.drawable.home_star);
+
+        // by default, we scale the icon to this size
+        int sWidth = insetSize / 2;
+        int sHeight = sWidth;
+
+        int halfSize = size / 2;
+        canvas.drawBitmap(aSource,
+                          null,
+                          new Rect(halfSize - sWidth,
+                                   halfSize - sHeight,
+                                   halfSize + sWidth,
+                                   halfSize + sHeight),
+                          null);
+
+        return bitmap;
+    }
+
+    @WrapElementForJNI(stubName = "GetHandlersForMimeTypeWrapper")
+    static String[] getHandlersForMimeType(String aMimeType, String aAction) {
+        Intent intent = getIntentForActionString(aAction);
+        if (aMimeType != null && aMimeType.length() > 0)
+            intent.setType(aMimeType);
+        return getHandlersForIntent(intent);
+    }
+
+    @WrapElementForJNI(stubName = "GetHandlersForURLWrapper")
+    static String[] getHandlersForURL(String aURL, String aAction) {
+        // aURL may contain the whole URL or just the protocol
+        Uri uri = aURL.indexOf(':') >= 0 ? Uri.parse(aURL) : new Uri.Builder().scheme(aURL).build();
+
+        Intent intent = getOpenURIIntent(getContext(), uri.toString(), "",
+            TextUtils.isEmpty(aAction) ? Intent.ACTION_VIEW : aAction, "");
+
+        return getHandlersForIntent(intent);
+    }
+
+    static boolean hasHandlersForIntent(Intent intent) {
+        PackageManager pm = getContext().getPackageManager();
+        List<ResolveInfo> list = pm.queryIntentActivities(intent, 0);
+        return !list.isEmpty();
+    }
+
+    static String[] getHandlersForIntent(Intent intent) {
+        PackageManager pm = getContext().getPackageManager();
+        List<ResolveInfo> list = pm.queryIntentActivities(intent, 0);
+        int numAttr = 4;
+        String[] ret = new String[list.size() * numAttr];
+        for (int i = 0; i < list.size(); i++) {
+            ResolveInfo resolveInfo = list.get(i);
+            ret[i * numAttr] = resolveInfo.loadLabel(pm).toString();
+            if (resolveInfo.isDefault)
+                ret[i * numAttr + 1] = "default";
+            else
+                ret[i * numAttr + 1] = "";
+            ret[i * numAttr + 2] = resolveInfo.activityInfo.applicationInfo.packageName;
+            ret[i * numAttr + 3] = resolveInfo.activityInfo.name;
+        }
+        return ret;
+    }
+
+    static Intent getIntentForActionString(String aAction) {
+        // Default to the view action if no other action as been specified.
+        if (TextUtils.isEmpty(aAction)) {
+            return new Intent(Intent.ACTION_VIEW);
+        }
+        return new Intent(aAction);
+    }
+
+    @WrapElementForJNI(stubName = "GetExtensionFromMimeTypeWrapper")
+    static String getExtensionFromMimeType(String aMimeType) {
+        return MimeTypeMap.getSingleton().getExtensionFromMimeType(aMimeType);
+    }
+
+    @WrapElementForJNI(stubName = "GetMimeTypeFromExtensionsWrapper")
+    static String getMimeTypeFromExtensions(String aFileExt) {
+        StringTokenizer st = new StringTokenizer(aFileExt, ".,; ");
+        String type = null;
+        String subType = null;
+        while (st.hasMoreElements()) {
+            String ext = st.nextToken();
+            String mt = getMimeTypeFromExtension(ext);
+            if (mt == null)
+                continue;
+            int slash = mt.indexOf('/');
+            String tmpType = mt.substring(0, slash);
+            if (!tmpType.equalsIgnoreCase(type))
+                type = type == null ? tmpType : "*";
+            String tmpSubType = mt.substring(slash + 1);
+            if (!tmpSubType.equalsIgnoreCase(subType))
+                subType = subType == null ? tmpSubType : "*";
+        }
+        if (type == null)
+            type = "*";
+        if (subType == null)
+            subType = "*";
+        return type + "/" + subType;
+    }
+
+    static void safeStreamClose(Closeable stream) {
+        try {
+            if (stream != null)
+                stream.close();
+        } catch (IOException e) {}
+    }
+
+    static void shareImage(String aSrc, String aType) {
+
+        Intent intent = new Intent(Intent.ACTION_SEND);
+        boolean isDataURI = aSrc.startsWith("data:");
+        OutputStream os = null;
+        File dir = GeckoApp.getTempDirectory();
+
+        if (dir == null) {
+            showImageShareFailureToast();
+            return;
+        }
+
+        GeckoApp.deleteTempFiles();
+
+        try {
+            // Create a temporary file for the image
+            File imageFile = File.createTempFile("image",
+                                                 "." + aType.replace("image/",""),
+                                                 dir);
+            os = new FileOutputStream(imageFile);
+
+            if (isDataURI) {
+                // We are dealing with a Data URI
+                int dataStart = aSrc.indexOf(',');
+                byte[] buf = Base64.decode(aSrc.substring(dataStart+1), Base64.DEFAULT);
+                os.write(buf);
+            } else {
+                // We are dealing with a URL
+                InputStream is = null;
+                try {
+                    URL url = new URL(aSrc);
+                    is = url.openStream();
+                    byte[] buf = new byte[2048];
+                    int length;
+
+                    while ((length = is.read(buf)) != -1) {
+                        os.write(buf, 0, length);
+                    }
+                } finally {
+                    safeStreamClose(is);
+                }
+            }
+            intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(imageFile));
+
+            // If we were able to determine the image type, send that in the intent. Otherwise,
+            // use a generic type.
+            if (aType.startsWith("image/")) {
+                intent.setType(aType);
+            } else {
+                intent.setType("image/*");
+            }
+        } catch (IOException e) {
+            if (!isDataURI) {
+               // If we failed, at least send through the URL link
+               intent.putExtra(Intent.EXTRA_TEXT, aSrc);
+               intent.setType("text/plain");
+            } else {
+               showImageShareFailureToast();
+               return;
+            }
+        } finally {
+            safeStreamClose(os);
+        }
+        getContext().startActivity(Intent.createChooser(intent,
+                getContext().getResources().getString(R.string.share_title)));
+    }
+
+    // Don't fail silently, tell the user that we weren't able to share the image
+    private static final void showImageShareFailureToast() {
+        Toast toast = Toast.makeText(getContext(),
+                                     getContext().getResources().getString(R.string.share_image_failed),
+                                     Toast.LENGTH_SHORT);
+        toast.show();
+    }
+
+    static boolean isUriSafeForScheme(Uri aUri) {
+        // Bug 794034 - We don't want to pass MWI or USSD codes to the
+        // dialer, and ensure the Uri class doesn't parse a URI
+        // containing a fragment ('#')
+        final String scheme = aUri.getScheme();
+        if ("tel".equals(scheme) || "sms".equals(scheme)) {
+            final String number = aUri.getSchemeSpecificPart();
+            if (number.contains("#") || number.contains("*") || aUri.getFragment() != null) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Given the inputs to <code>getOpenURIIntent</code>, plus an optional
+     * package name and class name, create and fire an intent to open the
+     * provided URI. If a class name is specified but a package name is not,
+     * we will default to using the current fennec package.
+     *
+     * @param targetURI the string spec of the URI to open.
+     * @param mimeType an optional MIME type string.
+     * @param packageName an optional app package name.
+     * @param className an optional intent class name.
+     * @param action an Android action specifier, such as
+     *               <code>Intent.ACTION_SEND</code>.
+     * @param title the title to use in <code>ACTION_SEND</code> intents.
+     * @return true if the activity started successfully; false otherwise.
+     */
+    @WrapElementForJNI
+    public static boolean openUriExternal(String targetURI,
+                                          String mimeType,
+              @OptionalGeneratedParameter String packageName,
+              @OptionalGeneratedParameter String className,
+              @OptionalGeneratedParameter String action,
+              @OptionalGeneratedParameter String title) {
+        final Context context = getContext();
+        final Intent intent = getOpenURIIntent(context, targetURI,
+                                               mimeType, action, title);
+
+        if (intent == null) {
+            return false;
+        }
+
+        if (!TextUtils.isEmpty(className)) {
+            if (!TextUtils.isEmpty(packageName)) {
+                intent.setClassName(packageName, className);
+            } else {
+                // Default to using the fennec app context.
+                intent.setClassName(context, className);
+            }
+        }
+
+        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+        try {
+            context.startActivity(intent);
+            return true;
+        } catch (ActivityNotFoundException e) {
+            return false;
+        }
+    }
+
+    /**
+     * Return a <code>Uri</code> instance which is equivalent to <code>u</code>,
+     * but with a guaranteed-lowercase scheme as if the API level 16 method
+     * <code>u.normalizeScheme</code> had been called.
+     *
+     * @param u the <code>Uri</code> to normalize.
+     * @return a <code>Uri</code>, which might be <code>u</code>.
+     */
+    static Uri normalizeUriScheme(final Uri u) {
+        final String scheme = u.getScheme();
+        final String lower  = scheme.toLowerCase(Locale.US);
+        if (lower.equals(scheme)) {
+            return u;
+        }
+
+        // Otherwise, return a new URI with a normalized scheme.
+        return u.buildUpon().scheme(lower).build();
+    }
+
+    /**
+     * Given a URI, a MIME type, and a title,
+     * produce a share intent which can be used to query all activities
+     * than can open the specified URI.
+     *
+     * @param context a <code>Context</code> instance.
+     * @param targetURI the string spec of the URI to open.
+     * @param mimeType an optional MIME type string.
+     * @param title the title to use in <code>ACTION_SEND</code> intents.
+     * @return an <code>Intent</code>, or <code>null</code> if none could be
+     *         produced.
+     */
+    public static Intent getShareIntent(final Context context,
+                                        final String targetURI,
+                                        final String mimeType,
+                                        final String title) {
+        Intent shareIntent = getIntentForActionString(Intent.ACTION_SEND);
+        shareIntent.putExtra(Intent.EXTRA_TEXT, targetURI);
+        shareIntent.putExtra(Intent.EXTRA_SUBJECT, title);
+
+        // Note that EXTRA_TITLE is intended to be used for share dialog
+        // titles. Common usage (e.g., Pocket) suggests that it's sometimes
+        // interpreted as an alternate to EXTRA_SUBJECT, so we include it.
+        shareIntent.putExtra(Intent.EXTRA_TITLE, title);
+
+        if (mimeType != null && mimeType.length() > 0) {
+            shareIntent.setType(mimeType);
+        }
+
+        return shareIntent;
+    }
+
+    /**
+     * Given a URI, a MIME type, an Android intent "action", and a title,
+     * produce an intent which can be used to start an activity to open
+     * the specified URI.
+     *
+     * @param context a <code>Context</code> instance.
+     * @param targetURI the string spec of the URI to open.
+     * @param mimeType an optional MIME type string.
+     * @param action an Android action specifier, such as
+     *               <code>Intent.ACTION_SEND</code>.
+     * @param title the title to use in <code>ACTION_SEND</code> intents.
+     * @return an <code>Intent</code>, or <code>null</code> if none could be
+     *         produced.
+     */
+    static Intent getOpenURIIntent(final Context context,
+                                   final String targetURI,
+                                   final String mimeType,
+                                   final String action,
+                                   final String title) {
+
+        if (action.equalsIgnoreCase(Intent.ACTION_SEND)) {
+            Intent shareIntent = getShareIntent(context, targetURI, mimeType, title);
+            return Intent.createChooser(shareIntent,
+                                        context.getResources().getString(R.string.share_title)); 
+        }
+
+        final Uri uri = normalizeUriScheme(targetURI.indexOf(':') >= 0 ? Uri.parse(targetURI) : new Uri.Builder().scheme(targetURI).build());
+        if (mimeType.length() > 0) {
+            Intent intent = getIntentForActionString(action);
+            intent.setDataAndType(uri, mimeType);
+            return intent;
+        }
+
+        if (!isUriSafeForScheme(uri)) {
+            return null;
+        }
+
+        final String scheme = uri.getScheme();
+
+        final Intent intent;
+
+        // Compute our most likely intent, then check to see if there are any
+        // custom handlers that would apply.
+        // Start with the original URI. If we end up modifying it, we'll
+        // overwrite it.
+        final Intent likelyIntent = getIntentForActionString(action);
+        likelyIntent.setData(uri);
+
+        if ("vnd.youtube".equals(scheme) && !hasHandlersForIntent(likelyIntent)) {
+            // Special-case YouTube to use our own player if no system handler
+            // exists.
+            intent = new Intent(VideoPlayer.VIDEO_ACTION);
+            intent.setClassName(AppConstants.ANDROID_PACKAGE_NAME,
+                                "org.mozilla.gecko.VideoPlayer");
+            intent.setData(uri);
+        } else {
+            intent = likelyIntent;
+        }
+
+        // Have a special handling for SMS, as the message body
+        // is not extracted from the URI automatically.
+        if (!"sms".equals(scheme)) {
+            return intent;
+        }
+
+        final String query = uri.getEncodedQuery();
+        if (TextUtils.isEmpty(query)) {
+            return intent;
+        }
+
+        final String[] fields = query.split("&");
+        boolean foundBody = false;
+        String resultQuery = "";
+        for (String field : fields) {
+            if (foundBody || !field.startsWith("body=")) {
+                resultQuery = resultQuery.concat(resultQuery.length() > 0 ? "&" + field : field);
+                continue;
+            }
+
+            // Found the first body param. Put it into the intent.
+            final String body = Uri.decode(field.substring(5));
+            intent.putExtra("sms_body", body);
+            foundBody = true;
+        }
+
+        if (!foundBody) {
+            // No need to rewrite the URI, then.
+            return intent;
+        }
+
+        // Form a new URI without the body field in the query part, and
+        // push that into the new Intent.
+        final String newQuery = resultQuery.length() > 0 ? "?" + resultQuery : "";
+        final Uri pruned = uri.buildUpon().encodedQuery(newQuery).build();
+        intent.setData(pruned);
+
+        return intent;
+    }
+
+    public static void setNotificationClient(NotificationClient client) {
+        if (sNotificationClient == null) {
+            sNotificationClient = client;
+        } else {
+            Log.d(LOGTAG, "Notification client already set");
+        }
+    }
+
+    @WrapElementForJNI(stubName = "ShowAlertNotificationWrapper")
+    public static void showAlertNotification(String aImageUrl, String aAlertTitle, String aAlertText,
+                                             String aAlertCookie, String aAlertName) {
+        // The intent to launch when the user clicks the expanded notification
+        String app = getContext().getClass().getName();
+        Intent notificationIntent = new Intent(GeckoApp.ACTION_ALERT_CALLBACK);
+        notificationIntent.setClassName(AppConstants.ANDROID_PACKAGE_NAME, app);
+        notificationIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+
+        int notificationID = aAlertName.hashCode();
+
+        // Put the strings into the intent as an URI "alert:?name=<alertName>&app=<appName>&cookie=<cookie>"
+        Uri.Builder b = new Uri.Builder();
+        Uri dataUri = b.scheme("alert").path(Integer.toString(notificationID))
+                                       .appendQueryParameter("name", aAlertName)
+                                       .appendQueryParameter("cookie", aAlertCookie)
+                                       .build();
+        notificationIntent.setData(dataUri);
+        PendingIntent contentIntent = PendingIntent.getActivity(
+                getContext(), 0, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+
+        mAlertCookies.put(aAlertName, aAlertCookie);
+        callObserver(aAlertName, "alertshow", aAlertCookie);
+
+        sNotificationClient.add(notificationID, aImageUrl, aAlertTitle, aAlertText, contentIntent);
+    }
+
+    @WrapElementForJNI
+    public static void alertsProgressListener_OnProgress(String aAlertName, long aProgress, long aProgressMax, String aAlertText) {
+        int notificationID = aAlertName.hashCode();
+        sNotificationClient.update(notificationID, aProgress, aProgressMax, aAlertText);
+    }
+
+    @WrapElementForJNI
+    public static void closeNotification(String aAlertName) {
+        String alertCookie = mAlertCookies.get(aAlertName);
+        if (alertCookie != null) {
+            callObserver(aAlertName, "alertfinished", alertCookie);
+            mAlertCookies.remove(aAlertName);
+        }
+
+        removeObserver(aAlertName);
+
+        int notificationID = aAlertName.hashCode();
+        sNotificationClient.remove(notificationID);
+    }
+
+    public static void handleNotification(String aAction, String aAlertName, String aAlertCookie) {
+        int notificationID = aAlertName.hashCode();
+
+        if (GeckoApp.ACTION_ALERT_CALLBACK.equals(aAction)) {
+            callObserver(aAlertName, "alertclickcallback", aAlertCookie);
+
+            if (sNotificationClient.isOngoing(notificationID)) {
+                // When clicked, keep the notification if it displays progress
+                return;
+            }
+        }
+        closeNotification(aAlertName);
+    }
+
+    @WrapElementForJNI(stubName = "GetDpiWrapper")
+    public static int getDpi() {
+        if (sDensityDpi == 0) {
+            sDensityDpi = getContext().getResources().getDisplayMetrics().densityDpi;
+        }
+
+        return sDensityDpi;
+    }
+
+    @WrapElementForJNI
+    public static float getDensity() {
+        return getContext().getResources().getDisplayMetrics().density;
+    }
+
+    private static boolean isHighMemoryDevice() {
+        return HardwareUtils.getMemSize() > HIGH_MEMORY_DEVICE_THRESHOLD_MB;
+    }
+
+    /**
+     * Returns the colour depth of the default screen. This will either be
+     * 24 or 16.
+     */
+    @WrapElementForJNI(stubName = "GetScreenDepthWrapper")
+    public static synchronized int getScreenDepth() {
+        if (sScreenDepth == 0) {
+            sScreenDepth = 16;
+            PixelFormat info = new PixelFormat();
+            PixelFormat.getPixelFormatInfo(getGeckoInterface().getActivity().getWindowManager().getDefaultDisplay().getPixelFormat(), info);
+            if (info.bitsPerPixel >= 24 && isHighMemoryDevice()) {
+                sScreenDepth = 24;
+            }
+        }
+
+        return sScreenDepth;
+    }
+
+    public static synchronized void setScreenDepthOverride(int aScreenDepth) {
+        if (sScreenDepth != 0) {
+            Log.e(LOGTAG, "Tried to override screen depth after it's already been set");
+            return;
+        }
+
+        sScreenDepth = aScreenDepth;
+    }
+
+    @WrapElementForJNI
+    public static void setFullScreen(boolean fullscreen) {
+        if (getGeckoInterface() != null)
+            getGeckoInterface().setFullScreen(fullscreen);
+    }
+
+    @WrapElementForJNI
+    public static void performHapticFeedback(boolean aIsLongPress) {
+        // Don't perform haptic feedback if a vibration is currently playing,
+        // because the haptic feedback will nuke the vibration.
+        if (!sVibrationMaybePlaying || System.nanoTime() >= sVibrationEndTime) {
+            LayerView layerView = getLayerView();
+            layerView.performHapticFeedback(aIsLongPress ?
+                                            HapticFeedbackConstants.LONG_PRESS :
+                                            HapticFeedbackConstants.VIRTUAL_KEY);
+        }
+    }
+
+    private static Vibrator vibrator() {
+        LayerView layerView = getLayerView();
+        return (Vibrator) layerView.getContext().getSystemService(Context.VIBRATOR_SERVICE);
+    }
+
+    @WrapElementForJNI(stubName = "Vibrate1")
+    public static void vibrate(long milliseconds) {
+        sVibrationEndTime = System.nanoTime() + milliseconds * 1000000;
+        sVibrationMaybePlaying = true;
+        vibrator().vibrate(milliseconds);
+    }
+
+    @WrapElementForJNI(stubName = "VibrateA")
+    public static void vibrate(long[] pattern, int repeat) {
+        // If pattern.length is even, the last element in the pattern is a
+        // meaningless delay, so don't include it in vibrationDuration.
+        long vibrationDuration = 0;
+        int iterLen = pattern.length - (pattern.length % 2 == 0 ? 1 : 0);
+        for (int i = 0; i < iterLen; i++) {
+          vibrationDuration += pattern[i];
+        }
+
+        sVibrationEndTime = System.nanoTime() + vibrationDuration * 1000000;
+        sVibrationMaybePlaying = true;
+        vibrator().vibrate(pattern, repeat);
+    }
+
+    @WrapElementForJNI
+    public static void cancelVibrate() {
+        sVibrationMaybePlaying = false;
+        sVibrationEndTime = 0;
+        vibrator().cancel();
+    }
+
+    @WrapElementForJNI
+    public static void showInputMethodPicker() {
+        InputMethodManager imm = (InputMethodManager)
+            getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+        imm.showInputMethodPicker();
+    }
+
+    @WrapElementForJNI
+    public static void setKeepScreenOn(final boolean on) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                // TODO
+            }
+        });
+    }
+
+    @WrapElementForJNI
+    public static void notifyDefaultPrevented(final boolean defaultPrevented) {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                LayerView view = getLayerView();
+                PanZoomController controller = (view == null ? null : view.getPanZoomController());
+                if (controller != null) {
+                    controller.notifyDefaultActionPrevented(defaultPrevented);
+                }
+            }
+        });
+    }
+
+    @WrapElementForJNI
+    public static boolean isNetworkLinkUp() {
+        ConnectivityManager cm = (ConnectivityManager)
+           getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
+        try {
+            NetworkInfo info = cm.getActiveNetworkInfo();
+            if (info == null || !info.isConnected())
+                return false;
+        } catch (SecurityException se) {
+            return false;
+        }
+        return true;
+    }
+
+    @WrapElementForJNI
+    public static boolean isNetworkLinkKnown() {
+        ConnectivityManager cm = (ConnectivityManager)
+            getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
+        try {
+            if (cm.getActiveNetworkInfo() == null)
+                return false;
+        } catch (SecurityException se) {
+            return false;
+        }
+        return true;
+    }
+
+    @WrapElementForJNI
+    public static int networkLinkType() {
+        ConnectivityManager cm = (ConnectivityManager)
+            getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
+        NetworkInfo info = cm.getActiveNetworkInfo();
+        if (info == null) {
+            return LINK_TYPE_UNKNOWN;
+        }
+
+        switch (info.getType()) {
+            case ConnectivityManager.TYPE_ETHERNET:
+                return LINK_TYPE_ETHERNET;
+            case ConnectivityManager.TYPE_WIFI:
+                return LINK_TYPE_WIFI;
+            case ConnectivityManager.TYPE_WIMAX:
+                return LINK_TYPE_WIMAX;
+            case ConnectivityManager.TYPE_MOBILE:
+                break; // We will handle sub-types after the switch.
+            default:
+                Log.w(LOGTAG, "Ignoring the current network type.");
+                return LINK_TYPE_UNKNOWN;
+        }
+
+        TelephonyManager tm = (TelephonyManager)
+            getContext().getSystemService(Context.TELEPHONY_SERVICE);
+        if (tm == null) {
+            Log.e(LOGTAG, "Telephony service does not exist");
+            return LINK_TYPE_UNKNOWN;
+        }
+
+        switch (tm.getNetworkType()) {
+            case TelephonyManager.NETWORK_TYPE_IDEN:
+            case TelephonyManager.NETWORK_TYPE_CDMA:
+            case TelephonyManager.NETWORK_TYPE_GPRS:
+                return LINK_TYPE_2G;
+            case TelephonyManager.NETWORK_TYPE_1xRTT:
+            case TelephonyManager.NETWORK_TYPE_EDGE:
+                return LINK_TYPE_2G; // 2.5G
+            case TelephonyManager.NETWORK_TYPE_UMTS:
+            case TelephonyManager.NETWORK_TYPE_EVDO_0:
+                return LINK_TYPE_3G;
+            case TelephonyManager.NETWORK_TYPE_HSPA:
+            case TelephonyManager.NETWORK_TYPE_HSDPA:
+            case TelephonyManager.NETWORK_TYPE_HSUPA:
+            case TelephonyManager.NETWORK_TYPE_EVDO_A:
+            case TelephonyManager.NETWORK_TYPE_EVDO_B:
+            case TelephonyManager.NETWORK_TYPE_EHRPD:
+                return LINK_TYPE_3G; // 3.5G
+            case TelephonyManager.NETWORK_TYPE_HSPAP:
+                return LINK_TYPE_3G; // 3.75G
+            case TelephonyManager.NETWORK_TYPE_LTE:
+                return LINK_TYPE_4G; // 3.9G
+            case TelephonyManager.NETWORK_TYPE_UNKNOWN:
+            default:
+                Log.w(LOGTAG, "Connected to an unknown mobile network!");
+                return LINK_TYPE_UNKNOWN;
+        }
+    }
+
+    @WrapElementForJNI(stubName = "GetSystemColoursWrapper")
+    public static int[] getSystemColors() {
+        // attrsAppearance[] must correspond to AndroidSystemColors structure in android/AndroidBridge.h
+        final int[] attrsAppearance = {
+            android.R.attr.textColor,
+            android.R.attr.textColorPrimary,
+            android.R.attr.textColorPrimaryInverse,
+            android.R.attr.textColorSecondary,
+            android.R.attr.textColorSecondaryInverse,
+            android.R.attr.textColorTertiary,
+            android.R.attr.textColorTertiaryInverse,
+            android.R.attr.textColorHighlight,
+            android.R.attr.colorForeground,
+            android.R.attr.colorBackground,
+            android.R.attr.panelColorForeground,
+            android.R.attr.panelColorBackground
+        };
+
+        int[] result = new int[attrsAppearance.length];
+
+        final ContextThemeWrapper contextThemeWrapper =
+            new ContextThemeWrapper(getContext(), android.R.style.TextAppearance);
+
+        final TypedArray appearance = contextThemeWrapper.getTheme().obtainStyledAttributes(attrsAppearance);
+
+        if (appearance != null) {
+            for (int i = 0; i < appearance.getIndexCount(); i++) {
+                int idx = appearance.getIndex(i);
+                int color = appearance.getColor(idx, 0);
+                result[idx] = color;
+            }
+            appearance.recycle();
+        }
+
+        return result;
+    }
+
+    @WrapElementForJNI
+    public static void killAnyZombies() {
+        GeckoProcessesVisitor visitor = new GeckoProcessesVisitor() {
+            @Override
+            public boolean callback(int pid) {
+                if (pid != android.os.Process.myPid())
+                    android.os.Process.killProcess(pid);
+                return true;
+            }
+        };
+            
+        EnumerateGeckoProcesses(visitor);
+    }
+
+    public static boolean checkForGeckoProcs() {
+
+        class GeckoPidCallback implements GeckoProcessesVisitor {
+            public boolean otherPidExist = false;
+            @Override
+            public boolean callback(int pid) {
+                if (pid != android.os.Process.myPid()) {
+                    otherPidExist = true;
+                    return false;
+                }
+                return true;
+            }            
+        }
+        GeckoPidCallback visitor = new GeckoPidCallback();            
+        EnumerateGeckoProcesses(visitor);
+        return visitor.otherPidExist;
+    }
+
+    interface GeckoProcessesVisitor{
+        boolean callback(int pid);
+    }
+
+    private static void EnumerateGeckoProcesses(GeckoProcessesVisitor visiter) {
+        int pidColumn = -1;
+        int userColumn = -1;
+
+        try {
+            // run ps and parse its output
+            java.lang.Process ps = Runtime.getRuntime().exec("ps");
+            BufferedReader in = new BufferedReader(new InputStreamReader(ps.getInputStream()),
+                                                   2048);
+
+            String headerOutput = in.readLine();
+
+            // figure out the column offsets.  We only care about the pid and user fields
+            StringTokenizer st = new StringTokenizer(headerOutput);
+            
+            int tokenSoFar = 0;
+            while (st.hasMoreTokens()) {
+                String next = st.nextToken();
+                if (next.equalsIgnoreCase("PID"))
+                    pidColumn = tokenSoFar;
+                else if (next.equalsIgnoreCase("USER"))
+                    userColumn = tokenSoFar;
+                tokenSoFar++;
+            }
+
+            // alright, the rest are process entries.
+            String psOutput = null;
+            while ((psOutput = in.readLine()) != null) {
+                String[] split = psOutput.split("\\s+");
+                if (split.length <= pidColumn || split.length <= userColumn)
+                    continue;
+                int uid = android.os.Process.getUidForName(split[userColumn]);
+                if (uid == android.os.Process.myUid() &&
+                    !split[split.length - 1].equalsIgnoreCase("ps")) {
+                    int pid = Integer.parseInt(split[pidColumn]);
+                    boolean keepGoing = visiter.callback(pid);
+                    if (keepGoing == false)
+                        break;
+                }
+            }
+            in.close();
+        }
+        catch (Exception e) {
+            Log.w(LOGTAG, "Failed to enumerate Gecko processes.",  e);
+        }
+    }
+
+    public static void waitForAnotherGeckoProc(){
+        int countdown = 40;
+        while (!checkForGeckoProcs() &&  --countdown > 0) {
+            try {
+                Thread.sleep(100);
+            } catch (InterruptedException ie) {}
+        }
+    }
+    public static String getAppNameByPID(int pid) {
+        BufferedReader cmdlineReader = null;
+        String path = "/proc/" + pid + "/cmdline";
+        try {
+            File cmdlineFile = new File(path);
+            if (!cmdlineFile.exists())
+                return "";
+            cmdlineReader = new BufferedReader(new FileReader(cmdlineFile));
+            return cmdlineReader.readLine().trim();
+        } catch (Exception ex) {
+            return "";
+        } finally {
+            if (null != cmdlineReader) {
+                try {
+                    cmdlineReader.close();
+                } catch (Exception e) {}
+            }
+        }
+    }
+
+    public static void listOfOpenFiles() {
+        int pidColumn = -1;
+        int nameColumn = -1;
+
+        try {
+            String filter = GeckoProfile.get(getContext()).getDir().toString();
+            Log.i(LOGTAG, "[OPENFILE] Filter: " + filter);
+
+            // run lsof and parse its output
+            java.lang.Process lsof = Runtime.getRuntime().exec("lsof");
+            BufferedReader in = new BufferedReader(new InputStreamReader(lsof.getInputStream()), 2048);
+
+            String headerOutput = in.readLine();
+            StringTokenizer st = new StringTokenizer(headerOutput);
+            int token = 0;
+            while (st.hasMoreTokens()) {
+                String next = st.nextToken();
+                if (next.equalsIgnoreCase("PID"))
+                    pidColumn = token;
+                else if (next.equalsIgnoreCase("NAME"))
+                    nameColumn = token;
+                token++;
+            }
+
+            // alright, the rest are open file entries.
+            Map<Integer, String> pidNameMap = new TreeMap<Integer, String>();
+            String output = null;
+            while ((output = in.readLine()) != null) {
+                String[] split = output.split("\\s+");
+                if (split.length <= pidColumn || split.length <= nameColumn)
+                    continue;
+                Integer pid = new Integer(split[pidColumn]);
+                String name = pidNameMap.get(pid);
+                if (name == null) {
+                    name = getAppNameByPID(pid.intValue());
+                    pidNameMap.put(pid, name);
+                }
+                String file = split[nameColumn];
+                if (!TextUtils.isEmpty(name) && !TextUtils.isEmpty(file) && file.startsWith(filter))
+                    Log.i(LOGTAG, "[OPENFILE] " + name + "(" + split[pidColumn] + ") : " + file);
+            }
+            in.close();
+        } catch (Exception e) { }
+    }
+
+    @WrapElementForJNI
+    public static void scanMedia(String aFile, String aMimeType) {
+        // If the platform didn't give us a mimetype, try to guess one from the filename
+        if (TextUtils.isEmpty(aMimeType)) {
+            int extPosition = aFile.lastIndexOf(".");
+            if (extPosition > 0 && extPosition < aFile.length() - 1) {
+                aMimeType = getMimeTypeFromExtension(aFile.substring(extPosition+1));
+            }
+        }
+
+        Context context = getContext();
+        GeckoMediaScannerClient.startScan(context, aFile, aMimeType);
+    }
+
+    @WrapElementForJNI(stubName = "GetIconForExtensionWrapper")
+    public static byte[] getIconForExtension(String aExt, int iconSize) {
+        try {
+            if (iconSize <= 0)
+                iconSize = 16;
+
+            if (aExt != null && aExt.length() > 1 && aExt.charAt(0) == '.')
+                aExt = aExt.substring(1);
+
+            PackageManager pm = getContext().getPackageManager();
+            Drawable icon = getDrawableForExtension(pm, aExt);
+            if (icon == null) {
+                // Use a generic icon
+                icon = pm.getDefaultActivityIcon();
+            }
+
+            Bitmap bitmap = ((BitmapDrawable)icon).getBitmap();
+            if (bitmap.getWidth() != iconSize || bitmap.getHeight() != iconSize)
+                bitmap = Bitmap.createScaledBitmap(bitmap, iconSize, iconSize, true);
+
+            ByteBuffer buf = ByteBuffer.allocate(iconSize * iconSize * 4);
+            bitmap.copyPixelsToBuffer(buf);
+
+            return buf.array();
+        }
+        catch (Exception e) {
+            Log.w(LOGTAG, "getIconForExtension failed.",  e);
+            return null;
+        }
+    }
+
+    private static String getMimeTypeFromExtension(String ext) {
+        final MimeTypeMap mtm = MimeTypeMap.getSingleton();
+        return mtm.getMimeTypeFromExtension(ext);
+    }
+    
+    private static Drawable getDrawableForExtension(PackageManager pm, String aExt) {
+        Intent intent = new Intent(Intent.ACTION_VIEW);
+        final String mimeType = getMimeTypeFromExtension(aExt);
+        if (mimeType != null && mimeType.length() > 0)
+            intent.setType(mimeType);
+        else
+            return null;
+
+        List<ResolveInfo> list = pm.queryIntentActivities(intent, 0);
+        if (list.size() == 0)
+            return null;
+
+        ResolveInfo resolveInfo = list.get(0);
+
+        if (resolveInfo == null)
+            return null;
+
+        ActivityInfo activityInfo = resolveInfo.activityInfo;
+
+        return activityInfo.loadIcon(pm);
+    }
+
+    @WrapElementForJNI
+    public static boolean getShowPasswordSetting() {
+        try {
+            int showPassword =
+                Settings.System.getInt(getContext().getContentResolver(),
+                                       Settings.System.TEXT_SHOW_PASSWORD, 1);
+            return (showPassword > 0);
+        }
+        catch (Exception e) {
+            return true;
+        }
+    }
+
+    @WrapElementForJNI(stubName = "AddPluginViewWrapper")
+    public static void addPluginView(View view,
+                                     float x, float y,
+                                     float w, float h,
+                                     boolean isFullScreen) {
+        if (getGeckoInterface() != null)
+             getGeckoInterface().addPluginView(view, new RectF(x, y, x + w, y + h), isFullScreen);
+    }
+
+    @WrapElementForJNI
+    public static void removePluginView(View view, boolean isFullScreen) {
+        if (getGeckoInterface() != null)
+            getGeckoInterface().removePluginView(view, isFullScreen);
+    }
+
+    /**
+     * A plugin that wish to be loaded in the WebView must provide this permission
+     * in their AndroidManifest.xml.
+     */
+    public static final String PLUGIN_ACTION = "android.webkit.PLUGIN";
+    public static final String PLUGIN_PERMISSION = "android.webkit.permission.PLUGIN";
+
+    private static final String PLUGIN_SYSTEM_LIB = "/system/lib/plugins/";
+
+    private static final String PLUGIN_TYPE = "type";
+    private static final String TYPE_NATIVE = "native";
+    static public ArrayList<PackageInfo> mPackageInfoCache = new ArrayList<PackageInfo>();
+
+    // Returns null if plugins are blocked on the device.
+    static String[] getPluginDirectories() {
+
+        // An awful hack to detect Tegra devices. Easiest way to do it without spinning up a EGL context.
+        boolean isTegra = (new File("/system/lib/hw/gralloc.tegra.so")).exists() ||
+                          (new File("/system/lib/hw/gralloc.tegra3.so")).exists();
+        if (isTegra) {
+            // disable Flash on Tegra ICS with CM9 and other custom firmware (bug 736421)
+            File vfile = new File("/proc/version");
+            FileReader vreader = null;
+            try {
+                if (vfile.canRead()) {
+                    vreader = new FileReader(vfile);
+                    String version = new BufferedReader(vreader).readLine();
+                    if (version.indexOf("CM9") != -1 ||
+                        version.indexOf("cyanogen") != -1 ||
+                        version.indexOf("Nova") != -1)
+                    {
+                        Log.w(LOGTAG, "Blocking plugins because of Tegra 2 + unofficial ICS bug (bug 736421)");
+                        return null;
+                    }
+                }
+            } catch (IOException ex) {
+                // nothing
+            } finally {
+                try {
+                    if (vreader != null) {
+                        vreader.close();
+                    }
+                } catch (IOException ex) {
+                    // nothing
+                }
+            }
+
+            // disable on KitKat (bug 957694)
+            if (Build.VERSION.SDK_INT >= 19) {
+                Log.w(LOGTAG, "Blocking plugins because of Tegra (bug 957694)");
+                return null;
+            }
+        }
+
+        ArrayList<String> directories = new ArrayList<String>();
+        PackageManager pm = getContext().getPackageManager();
+        List<ResolveInfo> plugins = pm.queryIntentServices(new Intent(PLUGIN_ACTION),
+                PackageManager.GET_SERVICES | PackageManager.GET_META_DATA);
+
+        synchronized(mPackageInfoCache) {
+
+            // clear the list of existing packageInfo objects
+            mPackageInfoCache.clear();
+
+
+            for (ResolveInfo info : plugins) {
+
+                // retrieve the plugin's service information
+                ServiceInfo serviceInfo = info.serviceInfo;
+                if (serviceInfo == null) {
+                    Log.w(LOGTAG, "Ignoring bad plugin.");
+                    continue;
+                }
+
+                // Blacklist HTC's flash lite.
+                // See bug #704516 - We're not quite sure what Flash Lite does,
+                // but loading it causes Flash to give errors and fail to draw.
+                if (serviceInfo.packageName.equals("com.htc.flashliteplugin")) {
+                    Log.w(LOGTAG, "Skipping HTC's flash lite plugin");
+                    continue;
+                }
+
+
+                // Retrieve information from the plugin's manifest.
+                PackageInfo pkgInfo;
+                try {
+                    pkgInfo = pm.getPackageInfo(serviceInfo.packageName,
+                                    PackageManager.GET_PERMISSIONS
+                                    | PackageManager.GET_SIGNATURES);
+                } catch (Exception e) {
+                    Log.w(LOGTAG, "Can't find plugin: " + serviceInfo.packageName);
+                    continue;
+                }
+
+                if (pkgInfo == null) {
+                    Log.w(LOGTAG, "Not loading plugin: " + serviceInfo.packageName + ". Could not load package information.");
+                    continue;
+                }
+
+                /*
+                 * find the location of the plugin's shared library. The default
+                 * is to assume the app is either a user installed app or an
+                 * updated system app. In both of these cases the library is
+                 * stored in the app's data directory.
+                 */
+                String directory = pkgInfo.applicationInfo.dataDir + "/lib";
+                final int appFlags = pkgInfo.applicationInfo.flags;
+                final int updatedSystemFlags = ApplicationInfo.FLAG_SYSTEM |
+                                               ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
+
+                // preloaded system app with no user updates
+                if ((appFlags & updatedSystemFlags) == ApplicationInfo.FLAG_SYSTEM) {
+                    directory = PLUGIN_SYSTEM_LIB + pkgInfo.packageName;
+                }
+
+                // check if the plugin has the required permissions
+                String permissions[] = pkgInfo.requestedPermissions;
+                if (permissions == null) {
+                    Log.w(LOGTAG, "Not loading plugin: " + serviceInfo.packageName + ". Does not have required permission.");
+                    continue;
+                }
+                boolean permissionOk = false;
+                for (String permit : permissions) {
+                    if (PLUGIN_PERMISSION.equals(permit)) {
+                        permissionOk = true;
+                        break;
+                    }
+                }
+                if (!permissionOk) {
+                    Log.w(LOGTAG, "Not loading plugin: " + serviceInfo.packageName + ". Does not have required permission (2).");
+                    continue;
+                }
+
+                // check to ensure the plugin is properly signed
+                Signature signatures[] = pkgInfo.signatures;
+                if (signatures == null) {
+                    Log.w(LOGTAG, "Not loading plugin: " + serviceInfo.packageName + ". Not signed.");
+                    continue;
+                }
+
+                // determine the type of plugin from the manifest
+                if (serviceInfo.metaData == null) {
+                    Log.e(LOGTAG, "The plugin '" + serviceInfo.name + "' has no defined type.");
+                    continue;
+                }
+
+                String pluginType = serviceInfo.metaData.getString(PLUGIN_TYPE);
+                if (!TYPE_NATIVE.equals(pluginType)) {
+                    Log.e(LOGTAG, "Unrecognized plugin type: " + pluginType);
+                    continue;
+                }
+
+                try {
+                    Class<?> cls = getPluginClass(serviceInfo.packageName, serviceInfo.name);
+
+                    //TODO implement any requirements of the plugin class here!
+                    boolean classFound = true;
+
+                    if (!classFound) {
+                        Log.e(LOGTAG, "The plugin's class' " + serviceInfo.name + "' does not extend the appropriate class.");
+                        continue;
+                    }
+
+                } catch (NameNotFoundException e) {
+                    Log.e(LOGTAG, "Can't find plugin: " + serviceInfo.packageName);
+                    continue;
+                } catch (ClassNotFoundException e) {
+                    Log.e(LOGTAG, "Can't find plugin's class: " + serviceInfo.name);
+                    continue;
+                }
+
+                // if all checks have passed then make the plugin available
+                mPackageInfoCache.add(pkgInfo);
+                directories.add(directory);
+            }
+        }
+
+        return directories.toArray(new String[directories.size()]);
+    }
+
+    static String getPluginPackage(String pluginLib) {
+
+        if (pluginLib == null || pluginLib.length() == 0) {
+            return null;
+        }
+
+        synchronized(mPackageInfoCache) {
+            for (PackageInfo pkgInfo : mPackageInfoCache) {
+                if (pluginLib.contains(pkgInfo.packageName)) {
+                    return pkgInfo.packageName;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    static Class<?> getPluginClass(String packageName, String className)
+            throws NameNotFoundException, ClassNotFoundException {
+        Context pluginContext = getContext().createPackageContext(packageName,
+                Context.CONTEXT_INCLUDE_CODE |
+                Context.CONTEXT_IGNORE_SECURITY);
+        ClassLoader pluginCL = pluginContext.getClassLoader();
+        return pluginCL.loadClass(className);
+    }
+
+    @WrapElementForJNI(allowMultithread = true)
+    public static Class<?> loadPluginClass(String className, String libName) {
+        if (getGeckoInterface() == null)
+            return null;
+        try {
+            final String packageName = getPluginPackage(libName);
+            final int contextFlags = Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY;
+            final Context pluginContext = getContext().createPackageContext(packageName, contextFlags);
+            Log.w(LOGTAG, "Load pluginClass " + className+":"+libName);
+            return pluginContext.getClassLoader().loadClass(className);
+        } catch (java.lang.ClassNotFoundException cnfe) {
+            Log.w(LOGTAG, "Couldn't find plugin class " + className, cnfe);
+            return null;
+        } catch (android.content.pm.PackageManager.NameNotFoundException nnfe) {
+            Log.w(LOGTAG, "Couldn't find package.", nnfe);
+            return null;
+        }
+    }
+
+    private static ContextGetter sContextGetter;
+
+    @WrapElementForJNI(allowMultithread = true)
+    public static Context getContext() {
+        return sContextGetter.getContext();
+    }
+
+    public static void setContextGetter(ContextGetter cg) {
+        sContextGetter = cg;
+    }
+
+    public static SharedPreferences getSharedPreferences() {
+        if (sContextGetter == null) {
+            throw new IllegalStateException("No ContextGetter; cannot fetch prefs.");
+        }
+        return sContextGetter.getSharedPreferences();
+    }
+
+    public interface AppStateListener {
+        public void onPause();
+        public void onResume();
+        public void onOrientationChanged();
+    }
+
+    public interface GeckoInterface {
+        public GeckoProfile getProfile();
+        public PromptService getPromptService();
+        public Activity getActivity();
+        public String getDefaultUAString();
+        public LocationListener getLocationListener();
+        public SensorEventListener getSensorEventListener();
+        public void doRestart();
+        public void setFullScreen(boolean fullscreen);
+        public void addPluginView(View view, final RectF rect, final boolean isFullScreen);
+        public void removePluginView(final View view, final boolean isFullScreen);
+        public void enableCameraView();
+        public void disableCameraView();
+        public void addAppStateListener(AppStateListener listener);
+        public void removeAppStateListener(AppStateListener listener);
+        public View getCameraView();
+        public void notifyWakeLockChanged(String topic, String state);
+        public FormAssistPopup getFormAssistPopup();
+        public boolean areTabsShown();
+        public AbsoluteLayout getPluginContainer();
+        public void notifyCheckUpdateResult(String result);
+        public boolean hasTabsSideBar();
+        public void invalidateOptionsMenu();
+    };
+
+    private static GeckoInterface sGeckoInterface;
+
+    public static GeckoInterface getGeckoInterface() {
+        return sGeckoInterface;
+    }
+
+    public static void setGeckoInterface(GeckoInterface aGeckoInterface) {
+        sGeckoInterface = aGeckoInterface;
+    }
+
+    public static android.hardware.Camera sCamera = null;
+
+    static native void cameraCallbackBridge(byte[] data);
+
+    static int kPreferedFps = 25;
+    static byte[] sCameraBuffer = null;
+
+
+    @WrapElementForJNI(stubName = "InitCameraWrapper")
+    static int[] initCamera(String aContentType, int aCamera, int aWidth, int aHeight) {
+        ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        if (getGeckoInterface() != null)
+                            getGeckoInterface().enableCameraView();
+                    } catch (Exception e) {}
+                }
+            });
+
+        // [0] = 0|1 (failure/success)
+        // [1] = width
+        // [2] = height
+        // [3] = fps
+        int[] result = new int[4];
+        result[0] = 0;
+
+        if (Build.VERSION.SDK_INT >= 9) {
+            if (android.hardware.Camera.getNumberOfCameras() == 0)
+                return result;
+        }
+
+        try {
+            // no front/back camera before API level 9
+            if (Build.VERSION.SDK_INT >= 9)
+                sCamera = android.hardware.Camera.open(aCamera);
+            else
+                sCamera = android.hardware.Camera.open();
+
+            android.hardware.Camera.Parameters params = sCamera.getParameters();
+            params.setPreviewFormat(ImageFormat.NV21);
+
+            // use the preview fps closest to 25 fps.
+            int fpsDelta = 1000;
+            try {
+                Iterator<Integer> it = params.getSupportedPreviewFrameRates().iterator();
+                while (it.hasNext()) {
+                    int nFps = it.next();
+                    if (Math.abs(nFps - kPreferedFps) < fpsDelta) {
+                        fpsDelta = Math.abs(nFps - kPreferedFps);
+                        params.setPreviewFrameRate(nFps);
+                    }
+                }
+            } catch(Exception e) {
+                params.setPreviewFrameRate(kPreferedFps);
+            }
+
+            // set up the closest preview size available
+            Iterator<android.hardware.Camera.Size> sit = params.getSupportedPreviewSizes().iterator();
+            int sizeDelta = 10000000;
+            int bufferSize = 0;
+            while (sit.hasNext()) {
+                android.hardware.Camera.Size size = sit.next();
+                if (Math.abs(size.width * size.height - aWidth * aHeight) < sizeDelta) {
+                    sizeDelta = Math.abs(size.width * size.height - aWidth * aHeight);
+                    params.setPreviewSize(size.width, size.height);
+                    bufferSize = size.width * size.height;
+                }
+            }
+
+            try {
+                if (getGeckoInterface() != null) {
+                    View cameraView = getGeckoInterface().getCameraView();
+                    if (cameraView instanceof SurfaceView) {
+                        sCamera.setPreviewDisplay(((SurfaceView)cameraView).getHolder());
+                    } else if (cameraView instanceof TextureView) {
+                        sCamera.setPreviewTexture(((TextureView)cameraView).getSurfaceTexture());
+                    }
+                }
+            } catch(IOException e) {
+                Log.w(LOGTAG, "Error setPreviewXXX:", e);
+            } catch(RuntimeException e) {
+                Log.w(LOGTAG, "Error setPreviewXXX:", e);
+            }
+
+            sCamera.setParameters(params);
+            sCameraBuffer = new byte[(bufferSize * 12) / 8];
+            sCamera.addCallbackBuffer(sCameraBuffer);
+            sCamera.setPreviewCallbackWithBuffer(new android.hardware.Camera.PreviewCallback() {
+                @Override
+                public void onPreviewFrame(byte[] data, android.hardware.Camera camera) {
+                    cameraCallbackBridge(data);
+                    if (sCamera != null)
+                        sCamera.addCallbackBuffer(sCameraBuffer);
+                }
+            });
+            sCamera.startPreview();
+            params = sCamera.getParameters();
+            result[0] = 1;
+            result[1] = params.getPreviewSize().width;
+            result[2] = params.getPreviewSize().height;
+            result[3] = params.getPreviewFrameRate();
+        } catch(RuntimeException e) {
+            Log.w(LOGTAG, "initCamera RuntimeException.", e);
+            result[0] = result[1] = result[2] = result[3] = 0;
+        }
+        return result;
+    }
+
+    @WrapElementForJNI
+    static synchronized void closeCamera() {
+        ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    try {
+                        if (getGeckoInterface() != null)
+                            getGeckoInterface().disableCameraView();
+                    } catch (Exception e) {}
+                }
+            });
+        if (sCamera != null) {
+            sCamera.stopPreview();
+            sCamera.release();
+            sCamera = null;
+            sCameraBuffer = null;
+        }
+    }
+
+    /**
+     * Adds a listener for a gecko event.
+     * This method is thread-safe and may be called at any time. In particular, calling it
+     * with an event that is currently being processed has the properly-defined behaviour that
+     * any added listeners will not be invoked on the event currently being processed, but
+     * will be invoked on future events of that type.
+     */
+    @RobocopTarget
+    public static void registerEventListener(String event, GeckoEventListener listener) {
+        sEventDispatcher.registerEventListener(event, listener);
+    }
+
+    public static EventDispatcher getEventDispatcher() {
+        return sEventDispatcher;
+    }
+
+    /**
+     * Remove a previously-registered listener for a gecko event.
+     * This method is thread-safe and may be called at any time. In particular, calling it
+     * with an event that is currently being processed has the properly-defined behaviour that
+     * any removed listeners will still be invoked on the event currently being processed, but
+     * will not be invoked on future events of that type.
+     */
+    @RobocopTarget
+    public static void unregisterEventListener(String event, GeckoEventListener listener) {
+        sEventDispatcher.unregisterEventListener(event, listener);
+    }
+
+    /*
+     * Battery API related methods.
+     */
+    @WrapElementForJNI
+    public static void enableBatteryNotifications() {
+        GeckoBatteryManager.enableNotifications();
+    }
+
+    @WrapElementForJNI(stubName = "HandleGeckoMessageWrapper")
+    public static void handleGeckoMessage(String message) {
+        sEventDispatcher.dispatchEvent(message);
+    }
+
+    @WrapElementForJNI
+    public static void disableBatteryNotifications() {
+        GeckoBatteryManager.disableNotifications();
+    }
+
+    @WrapElementForJNI(stubName = "GetCurrentBatteryInformationWrapper")
+    public static double[] getCurrentBatteryInformation() {
+        return GeckoBatteryManager.getCurrentInformation();
+    }
+
+    @WrapElementForJNI(stubName = "CheckURIVisited")
+    static void checkUriVisited(String uri) {
+        GlobalHistory.getInstance().checkUriVisited(uri);
+    }
+
+    @WrapElementForJNI(stubName = "MarkURIVisited")
+    static void markUriVisited(final String uri) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                GlobalHistory.getInstance().add(uri);
+            }
+        });
+    }
+
+    @WrapElementForJNI(stubName = "SetURITitle")
+    static void setUriTitle(final String uri, final String title) {
+        ThreadUtils.postToBackgroundThread(new Runnable() {
+            @Override
+            public void run() {
+                GlobalHistory.getInstance().update(uri, title);
+            }
+        });
+    }
+
+    @WrapElementForJNI
+    static void hideProgressDialog() {
+        // unused stub
+    }
+
+    /*
+     * WebSMS related methods.
+     */
+    @WrapElementForJNI(stubName = "SendMessageWrapper")
+    public static void sendMessage(String aNumber, String aMessage, int aRequestId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().send(aNumber, aMessage, aRequestId);
+    }
+
+    @WrapElementForJNI(stubName = "GetMessageWrapper")
+    public static void getMessage(int aMessageId, int aRequestId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().getMessage(aMessageId, aRequestId);
+    }
+
+    @WrapElementForJNI(stubName = "DeleteMessageWrapper")
+    public static void deleteMessage(int aMessageId, int aRequestId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().deleteMessage(aMessageId, aRequestId);
+    }
+
+    @WrapElementForJNI(stubName = "CreateMessageListWrapper")
+    public static void createMessageList(long aStartDate, long aEndDate, String[] aNumbers, int aNumbersCount, int aDeliveryState, boolean aReverse, int aRequestId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().createMessageList(aStartDate, aEndDate, aNumbers, aNumbersCount, aDeliveryState, aReverse, aRequestId);
+    }
+
+    @WrapElementForJNI(stubName = "GetNextMessageInListWrapper")
+    public static void getNextMessageInList(int aListId, int aRequestId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().getNextMessageInList(aListId, aRequestId);
+    }
+
+    @WrapElementForJNI
+    public static void clearMessageList(int aListId) {
+        if (SmsManager.getInstance() == null) {
+            return;
+        }
+
+        SmsManager.getInstance().clearMessageList(aListId);
+    }
+
+    /* Called by JNI from AndroidBridge, and by reflection from tests/BaseTest.java.in */
+    @WrapElementForJNI
+    @RobocopTarget
+    public static boolean isTablet() {
+        return HardwareUtils.isTablet();
+    }
+
+    public static void viewSizeChanged() {
+        LayerView v = getLayerView();
+        if (v != null && v.isIMEEnabled()) {
+            sendEventToGecko(GeckoEvent.createBroadcastEvent(
+                    "ScrollTo:FocusedInput", ""));
+        }
+    }
+
+    @WrapElementForJNI(stubName = "GetCurrentNetworkInformationWrapper")
+    public static double[] getCurrentNetworkInformation() {
+        return GeckoNetworkManager.getInstance().getCurrentInformation();
+    }
+
+    @WrapElementForJNI
+    public static void enableNetworkNotifications() {
+        GeckoNetworkManager.getInstance().enableNotifications();
+    }
+
+    @WrapElementForJNI
+    public static void disableNetworkNotifications() {
+        GeckoNetworkManager.getInstance().disableNotifications();
+    }
+
+    // values taken from android's Base64
+    public static final int BASE64_DEFAULT = 0;
+    public static final int BASE64_URL_SAFE = 8;
+
+    /**
+     * taken from http://www.source-code.biz/base64coder/java/Base64Coder.java.txt and modified (MIT License)
+     */
+    // Mapping table from 6-bit nibbles to Base64 characters.
+    private static final byte[] map1 = new byte[64];
+    private static final byte[] map1_urlsafe;
+    static {
+      int i=0;
+      for (byte c='A'; c<='Z'; c++) map1[i++] = c;
+      for (byte c='a'; c<='z'; c++) map1[i++] = c;
+      for (byte c='0'; c<='9'; c++) map1[i++] = c;
+      map1[i++] = '+'; map1[i++] = '/';
+      map1_urlsafe = map1.clone();
+      map1_urlsafe[62] = '-'; map1_urlsafe[63] = '_'; 
+    }
+
+    // Mapping table from Base64 characters to 6-bit nibbles.
+    private static final byte[] map2 = new byte[128];
+    static {
+        for (int i=0; i<map2.length; i++) map2[i] = -1;
+        for (int i=0; i<64; i++) map2[map1[i]] = (byte)i;
+        map2['-'] = (byte)62; map2['_'] = (byte)63;
+    }
+
+    final static byte EQUALS_ASCII = (byte) '=';
+
+    /**
+     * Encodes a byte array into Base64 format.
+     * No blanks or line breaks are inserted in the output.
+     * @param in    An array containing the data bytes to be encoded.
+     * @return      A character array containing the Base64 encoded data.
+     */
+    public static byte[] encodeBase64(byte[] in, int flags) {
+        if (Build.VERSION.SDK_INT >=Build.VERSION_CODES.FROYO)
+            return Base64.encode(in, flags | Base64.NO_WRAP);
+        int oDataLen = (in.length*4+2)/3;       // output length without padding
+        int oLen = ((in.length+2)/3)*4;         // output length including padding
+        byte[] out = new byte[oLen];
+        int ip = 0;
+        int iEnd = in.length;
+        int op = 0;
+        byte[] toMap = ((flags & BASE64_URL_SAFE) == 0 ? map1 : map1_urlsafe);
+        while (ip < iEnd) {
+            int i0 = in[ip++] & 0xff;
+            int i1 = ip < iEnd ? in[ip++] & 0xff : 0;
+            int i2 = ip < iEnd ? in[ip++] & 0xff : 0;
+            int o0 = i0 >>> 2;
+            int o1 = ((i0 &   3) << 4) | (i1 >>> 4);
+            int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);
+            int o3 = i2 & 0x3F;
+            out[op++] = toMap[o0];
+            out[op++] = toMap[o1];
+            out[op] = op < oDataLen ? toMap[o2] : EQUALS_ASCII; op++;
+            out[op] = op < oDataLen ? toMap[o3] : EQUALS_ASCII; op++;
+        }
+        return out; 
+    }
+
+    /**
+     * Decodes a byte array from Base64 format.
+     * No blanks or line breaks are allowed within the Base64 encoded input data.
+     * @param in    A character array containing the Base64 encoded data.
+     * @param iOff  Offset of the first character in <code>in</code> to be processed.
+     * @param iLen  Number of characters to process in <code>in</code>, starting at <code>iOff</code>.
+     * @return      An array containing the decoded data bytes.
+     * @throws      IllegalArgumentException If the input is not valid Base64 encoded data.
+     */
+    public static byte[] decodeBase64(byte[] in, int flags) {
+        if (Build.VERSION.SDK_INT >=Build.VERSION_CODES.FROYO)
+            return Base64.decode(in, flags);
+        int iOff = 0;
+        int iLen = in.length;
+        if (iLen%4 != 0) throw new IllegalArgumentException ("Length of Base64 encoded input string is not a multiple of 4.");
+        while (iLen > 0 && in[iOff+iLen-1] == '=') iLen--;
+        int oLen = (iLen*3) / 4;
+        byte[] out = new byte[oLen];
+        int ip = iOff;
+        int iEnd = iOff + iLen;
+        int op = 0;
+        while (ip < iEnd) {
+            int i0 = in[ip++];
+            int i1 = in[ip++];
+            int i2 = ip < iEnd ? in[ip++] : 'A';
+            int i3 = ip < iEnd ? in[ip++] : 'A';
+            if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127)
+                throw new IllegalArgumentException ("Illegal character in Base64 encoded data.");
+            int b0 = map2[i0];
+            int b1 = map2[i1];
+            int b2 = map2[i2];
+            int b3 = map2[i3];
+            if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0)
+                throw new IllegalArgumentException ("Illegal character in Base64 encoded data.");
+            int o0 = ( b0       <<2) | (b1>>>4);
+            int o1 = ((b1 & 0xf)<<4) | (b2>>>2);
+            int o2 = ((b2 &   3)<<6) |  b3;
+            out[op++] = (byte)o0;
+            if (op<oLen) out[op++] = (byte)o1;
+            if (op<oLen) out[op++] = (byte)o2; }
+        return out; 
+    }
+
+    public static byte[] decodeBase64(String s, int flags) {
+        return decodeBase64(s.getBytes(), flags);
+    }
+
+    @WrapElementForJNI(stubName = "GetScreenOrientationWrapper")
+    public static short getScreenOrientation() {
+        return GeckoScreenOrientation.getInstance().getScreenOrientation().value;
+    }
+
+    @WrapElementForJNI
+    public static void enableScreenOrientationNotifications() {
+        GeckoScreenOrientation.getInstance().enableNotifications();
+    }
+
+    @WrapElementForJNI
+    public static void disableScreenOrientationNotifications() {
+        GeckoScreenOrientation.getInstance().disableNotifications();
+    }
+
+    @WrapElementForJNI
+    public static void lockScreenOrientation(int aOrientation) {
+        GeckoScreenOrientation.getInstance().lock(aOrientation);
+    }
+
+    @WrapElementForJNI
+    public static void unlockScreenOrientation() {
+        GeckoScreenOrientation.getInstance().unlock();
+    }
+
+    @WrapElementForJNI
+    public static boolean pumpMessageLoop() {
+        Handler geckoHandler = ThreadUtils.sGeckoHandler;
+        Message msg = getNextMessageFromQueue(ThreadUtils.sGeckoQueue);
+
+        if (msg == null)
+            return false;
+        if (msg.obj == geckoHandler && msg.getTarget() == geckoHandler) {
+            // Our "queue is empty" message; see runGecko()
+            msg.recycle();
+            return false;
+        }
+        if (msg.getTarget() == null) 
+            Looper.myLooper().quit();
+        else
+            msg.getTarget().dispatchMessage(msg);
+        msg.recycle();
+        return true;
+    }
+
+    @WrapElementForJNI
+    public static void notifyWakeLockChanged(String topic, String state) {
+        if (getGeckoInterface() != null)
+            getGeckoInterface().notifyWakeLockChanged(topic, state);
+    }
+
+    @WrapElementForJNI
+    public static void registerSurfaceTextureFrameListener(Object surfaceTexture, final int id) {
+        ((SurfaceTexture)surfaceTexture).setOnFrameAvailableListener(new SurfaceTexture.OnFrameAvailableListener() {
+            @Override
+            public void onFrameAvailable(SurfaceTexture surfaceTexture) {
+                GeckoAppShell.onSurfaceTextureFrameAvailable(surfaceTexture, id);
+            }
+        });
+    }
+
+    @WrapElementForJNI(allowMultithread = true)
+    public static void unregisterSurfaceTextureFrameListener(Object surfaceTexture) {
+        ((SurfaceTexture)surfaceTexture).setOnFrameAvailableListener(null);
+    }
+
+    @WrapElementForJNI
+    public static boolean unlockProfile() {
+        // Try to kill any zombie Fennec's that might be running
+        GeckoAppShell.killAnyZombies();
+
+        // Then force unlock this profile
+        if (getGeckoInterface() != null) {
+            GeckoProfile profile = getGeckoInterface().getProfile();
+            File lock = profile.getFile(".parentlock");
+            return lock.exists() && lock.delete();
+        }
+        return false;
+    }
+
+    @WrapElementForJNI(stubName = "GetProxyForURIWrapper")
+    public static String getProxyForURI(String spec, String scheme, String host, int port) {
+        final ProxySelector ps = new ProxySelector();
+
+        Proxy proxy = ps.select(scheme, host);
+        if (Proxy.NO_PROXY.equals(proxy)) {
+            return "DIRECT";
+        }
+        
+        switch (proxy.type()) {
+            case HTTP:
+                return "PROXY " + proxy.address().toString();
+            case SOCKS:
+                return "SOCKS " + proxy.address().toString();
+        }
+
+        return "DIRECT";
+    }
+
+}
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/GeckoApplication.java
--- a/mobile/android/base/GeckoApplication.java	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/GeckoApplication.java	Mon Mar 31 16:57:28 2014 +0700
@@ -4,6 +4,7 @@
 
 package org.mozilla.gecko;
 
+import org.mozilla.gecko.PrefsHelper;
 import org.mozilla.gecko.db.BrowserContract;
 import org.mozilla.gecko.db.BrowserDB;
 import org.mozilla.gecko.home.HomeConfigInvalidator;
@@ -94,7 +95,8 @@
 
     @Override
     public void onCreate() {
-        HardwareUtils.init(getApplicationContext());
+	    PrefsHelper.setPref("plugin.enable", "1");
+	    HardwareUtils.init(getApplicationContext());
         Clipboard.init(getApplicationContext());
         FilePicker.init(getApplicationContext());
         GeckoLoader.loadMozGlue();
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/GeckoScreenOrientation.java
--- a/mobile/android/base/GeckoScreenOrientation.java	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/GeckoScreenOrientation.java	Mon Mar 31 16:57:28 2014 +0700
@@ -54,7 +54,7 @@
     // Singleton instance.
     private static GeckoScreenOrientation sInstance = null;
     // Default screen orientation, used for initialization and unlocking.
-    private static final ScreenOrientation DEFAULT_SCREEN_ORIENTATION = ScreenOrientation.DEFAULT;
+    private static final ScreenOrientation DEFAULT_SCREEN_ORIENTATION = ScreenOrientation.LANDSCAPE_PRIMARY;
     // Default rotation, used when device rotation is unknown.
     private static final int DEFAULT_ROTATION = Surface.ROTATION_0;
     // Default orientation, used if screen orientation is unspecified.
@@ -76,7 +76,8 @@
         });
 
         mDefaultScreenOrientation = DEFAULT_SCREEN_ORIENTATION;
-        update();
+	    mScreenOrientation = mDefaultScreenOrientation;
+//        update();
     }
 
     public static GeckoScreenOrientation getInstance() {
@@ -237,24 +238,25 @@
      * @return Gecko screen orientation.
      */
     private ScreenOrientation getScreenOrientation(int aAndroidOrientation, int aRotation) {
-        boolean isPrimary = aRotation == Surface.ROTATION_0 || aRotation == Surface.ROTATION_90;
-        if (aAndroidOrientation == Configuration.ORIENTATION_PORTRAIT) {
-            if (isPrimary) {
-                // Non-rotated portrait device or landscape device rotated
-                // to primary portrait mode counter-clockwise.
-                return ScreenOrientation.PORTRAIT_PRIMARY;
-            }
-            return ScreenOrientation.PORTRAIT_SECONDARY;
-        }
-        if (aAndroidOrientation == Configuration.ORIENTATION_LANDSCAPE) {
-            if (isPrimary) {
-                // Non-rotated landscape device or portrait device rotated
-                // to primary landscape mode counter-clockwise.
-                return ScreenOrientation.LANDSCAPE_PRIMARY;
-            }
-            return ScreenOrientation.LANDSCAPE_SECONDARY;
-        }
-        return ScreenOrientation.NONE;
+	    return ScreenOrientation.LANDSCAPE_PRIMARY;
+//        boolean isPrimary = aRotation == Surface.ROTATION_0 || aRotation == Surface.ROTATION_90;
+//        if (aAndroidOrientation == Configuration.ORIENTATION_PORTRAIT) {
+//            if (isPrimary) {
+//                // Non-rotated portrait device or landscape device rotated
+//                // to primary portrait mode counter-clockwise.
+//                return ScreenOrientation.PORTRAIT_PRIMARY;
+//            }
+//            return ScreenOrientation.PORTRAIT_SECONDARY;
+//        }
+//        if (aAndroidOrientation == Configuration.ORIENTATION_LANDSCAPE) {
+//            if (isPrimary) {
+//                // Non-rotated landscape device or portrait device rotated
+//                // to primary landscape mode counter-clockwise.
+//                return ScreenOrientation.LANDSCAPE_PRIMARY;
+//            }
+//            return ScreenOrientation.LANDSCAPE_SECONDARY;
+//        }
+//        return ScreenOrientation.NONE;
     }
 
     /*
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/LocaleManager.java
--- a/mobile/android/base/LocaleManager.java	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/LocaleManager.java	Mon Mar 31 16:57:28 2014 +0700
@@ -63,6 +63,13 @@
         inited = true;
     }
 
+	public static void destroy(){
+		if(receiver!=null){
+		getContext().unregisterReceiver(receiver);
+			receiver =null;
+		}
+	}
+
     public static boolean systemLocaleDidChange() {
         return systemLocaleDidChange;
     }
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/base.iml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/base.iml	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="JAVA_MODULE" version="4">
+  <component name="NewModuleRootManager" inherit-compiler-output="true">
+    <exclude-output />
+    <content url="file://$MODULE_DIR$">
+      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
+    </content>
+    <orderEntry type="inheritedJdk" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+</module>
+
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/gfx/JavaPanZoomController.java.orig
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/gfx/JavaPanZoomController.java.orig	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,1477 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.gecko.gfx;
+
+import org.mozilla.gecko.GeckoAppShell;
+import org.mozilla.gecko.GeckoEvent;
+import org.mozilla.gecko.PrefsHelper;
+import org.mozilla.gecko.Tab;
+import org.mozilla.gecko.Tabs;
+import org.mozilla.gecko.ZoomConstraints;
+import org.mozilla.gecko.EventDispatcher;
+import org.mozilla.gecko.util.FloatUtils;
+import org.mozilla.gecko.util.GamepadUtils;
+import org.mozilla.gecko.util.GeckoEventListener;
+import org.mozilla.gecko.util.ThreadUtils;
+
+import org.json.JSONObject;
+
+import android.graphics.PointF;
+import android.graphics.RectF;
+import android.os.Build;
+import android.util.FloatMath;
+import android.util.Log;
+import android.view.GestureDetector;
+import android.view.InputDevice;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.View;
+
+/*
+ * Handles the kinetic scrolling and zooming physics for a layer controller.
+ *
+ * Many ideas are from Joe Hewitt's Scrollability:
+ *   https://github.com/joehewitt/scrollability/
+ */
+class JavaPanZoomController
+    extends GestureDetector.SimpleOnGestureListener
+    implements PanZoomController, SimpleScaleGestureDetector.SimpleScaleGestureListener, GeckoEventListener
+{
+    private static final String LOGTAG = "GeckoPanZoomController";
+
+    private static String MESSAGE_ZOOM_RECT = "Browser:ZoomToRect";
+    private static String MESSAGE_ZOOM_PAGE = "Browser:ZoomToPageWidth";
+    private static String MESSAGE_TOUCH_LISTENER = "Tab:HasTouchListener";
+
+    // Animation stops if the velocity is below this value when overscrolled or panning.
+    private static final float STOPPED_THRESHOLD = 4.0f;
+
+    // Animation stops is the velocity is below this threshold when flinging.
+    private static final float FLING_STOPPED_THRESHOLD = 0.1f;
+
+    // The distance the user has to pan before we recognize it as such (e.g. to avoid 1-pixel pans
+    // between the touch-down and touch-up of a click). In units of density-independent pixels.
+    public static final float PAN_THRESHOLD = 1/16f * GeckoAppShell.getDpi();
+
+    // Angle from axis within which we stay axis-locked
+    private static final double AXIS_LOCK_ANGLE = Math.PI / 6.0; // 30 degrees
+
+    // Axis-lock breakout angle
+    private static final double AXIS_BREAKOUT_ANGLE = Math.PI / 8.0;
+
+    // The distance the user has to pan before we consider breaking out of a locked axis
+    public static final float AXIS_BREAKOUT_THRESHOLD = 1/32f * GeckoAppShell.getDpi();
+
+    // The maximum amount we allow you to zoom into a page
+    private static final float MAX_ZOOM = 4.0f;
+
+    // The maximum amount we would like to scroll with the mouse
+    private static final float MAX_SCROLL = 0.075f * GeckoAppShell.getDpi();
+
+    // The maximum zoom factor adjustment per frame of the AUTONAV animation
+    private static final float MAX_ZOOM_DELTA = 0.125f;
+
+    // The duration of the bounce animation in ns
+    private static final int BOUNCE_ANIMATION_DURATION = 250000000;
+
+    private enum PanZoomState {
+        NOTHING,                /* no touch-start events received */
+        FLING,                  /* all touches removed, but we're still scrolling page */
+        TOUCHING,               /* one touch-start event received */
+        PANNING_LOCKED_X,       /* touch-start followed by move (i.e. panning with axis lock) X axis */
+        PANNING_LOCKED_Y,       /* as above for Y axis */
+        PANNING,                /* panning without axis lock */
+        PANNING_HOLD,           /* in panning, but not moving.
+                                 * similar to TOUCHING but after starting a pan */
+        PANNING_HOLD_LOCKED_X,  /* like PANNING_HOLD, but axis lock still in effect for X axis */
+        PANNING_HOLD_LOCKED_Y,  /* as above but for Y axis */
+        PINCHING,               /* nth touch-start, where n > 1. this mode allows pan and zoom */
+        ANIMATED_ZOOM,          /* animated zoom to a new rect */
+        BOUNCE,                 /* in a bounce animation */
+        WAITING_LISTENERS,      /* a state halfway between NOTHING and TOUCHING - the user has
+                                   put a finger down, but we don't yet know if a touch listener has
+                                   prevented the default actions yet. we still need to abort animations. */
+        AUTONAV,                /* We are scrolling using an AutonavRunnable animation. This is similar
+                                   to the FLING state except that it must be stopped manually by the code that
+                                   started it, and it's velocity can be updated while it's running. */
+    }
+
+    private enum AxisLockMode {
+        STANDARD,       /* Default axis locking mode that doesn't break out until finger release */
+        FREE,           /* No locking at all */
+        STICKY          /* Break out with hysteresis so that it feels as free as possible whilst locking */
+    }
+
+    private final PanZoomTarget mTarget;
+    private final SubdocumentScrollHelper mSubscroller;
+    private final Axis mX;
+    private final Axis mY;
+    private final TouchEventHandler mTouchEventHandler;
+    private final EventDispatcher mEventDispatcher;
+
+    /* The task that handles flings, autonav or bounces. */
+    private PanZoomRenderTask mAnimationRenderTask;
+    /* The zoom focus at the first zoom event (in page coordinates). */
+    private PointF mLastZoomFocus;
+    /* The time the last motion event took place. */
+    private long mLastEventTime;
+    /* Current state the pan/zoom UI is in. */
+    private PanZoomState mState;
+    /* The per-frame zoom delta for the currently-running AUTONAV animation. */
+    private float mAutonavZoomDelta;
+    /* The user selected panning mode */
+    private AxisLockMode mMode;
+    /* A medium-length tap/press is happening */
+    private boolean mMediumPress;
+    /* Used to change the scrollY direction */
+    private boolean mNegateWheelScrollY;
+    /* Whether the current event has been default-prevented. */
+    private boolean mDefaultPrevented;
+
+    // Handler to be notified when overscroll occurs
+    private Overscroll mOverscroll;
+
+    public JavaPanZoomController(PanZoomTarget target, View view, EventDispatcher eventDispatcher) {
+        mTarget = target;
+        mSubscroller = new SubdocumentScrollHelper(eventDispatcher);
+        mX = new AxisX(mSubscroller);
+        mY = new AxisY(mSubscroller);
+        mTouchEventHandler = new TouchEventHandler(view.getContext(), view, this);
+	     Log.d("GeckoBrowser","JavaPanZoomController TouchEventHandler created");
+        checkMainThread();
+
+        setState(PanZoomState.NOTHING);
+
+        mEventDispatcher = eventDispatcher;
+        registerEventListener(MESSAGE_ZOOM_RECT);
+        registerEventListener(MESSAGE_ZOOM_PAGE);
+        registerEventListener(MESSAGE_TOUCH_LISTENER);
+
+        mMode = AxisLockMode.STANDARD;
+
+        String[] prefs = { "ui.scrolling.axis_lock_mode",
+                           "ui.scrolling.negate_wheel_scrollY",
+                           "ui.scrolling.gamepad_dead_zone" };
+        mNegateWheelScrollY = false;
+        PrefsHelper.getPrefs(prefs, new PrefsHelper.PrefHandlerBase() {
+            @Override public void prefValue(String pref, String value) {
+                if (pref.equals("ui.scrolling.axis_lock_mode")) {
+                    if (value.equals("standard")) {
+                        mMode = AxisLockMode.STANDARD;
+                    } else if (value.equals("free")) {
+                        mMode = AxisLockMode.FREE;
+                    } else {
+                        mMode = AxisLockMode.STICKY;
+                    }
+                }
+            }
+
+            @Override public void prefValue(String pref, int value) {
+                if (pref.equals("ui.scrolling.gamepad_dead_zone")) {
+                    GamepadUtils.overrideDeadZoneThreshold((float)value / 1000f);
+                }
+            }
+
+            @Override public void prefValue(String pref, boolean value) {
+                if (pref.equals("ui.scrolling.negate_wheel_scrollY")) {
+                    mNegateWheelScrollY = value;
+                }
+            }
+
+            @Override
+            public boolean isObserver() {
+                return true;
+            }
+
+        });
+
+        Axis.initPrefs();
+    }
+
+    @Override
+    public void destroy() {
+        unregisterEventListener(MESSAGE_ZOOM_RECT);
+        unregisterEventListener(MESSAGE_ZOOM_PAGE);
+        unregisterEventListener(MESSAGE_TOUCH_LISTENER);
+        mSubscroller.destroy();
+        mTouchEventHandler.destroy();
+    }
+
+    private final static float easeOut(float t) {
+        // ease-out approx.
+        // -(t-1)^2+1
+        t = t-1;
+        return -t*t+1;
+    }
+
+    private void registerEventListener(String event) {
+        mEventDispatcher.registerEventListener(event, this);
+    }
+
+    private void unregisterEventListener(String event) {
+        mEventDispatcher.unregisterEventListener(event, this);
+    }
+
+    private void setState(PanZoomState state) {
+        if (state != mState) {
+            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("PanZoom:StateChange", state.toString()));
+            mState = state;
+
+            // Let the target know we've finished with it (for now)
+            if (state == PanZoomState.NOTHING) {
+                mTarget.panZoomStopped();
+            }
+        }
+    }
+
+    private ImmutableViewportMetrics getMetrics() {
+        return mTarget.getViewportMetrics();
+    }
+
+    private void checkMainThread() {
+        if (!ThreadUtils.isOnUiThread()) {
+            // log with full stack trace
+            Log.e(LOGTAG, "Uh-oh, we're running on the wrong thread!", new Exception());
+        }
+    }
+
+    @Override
+    public void handleMessage(String event, JSONObject message) {
+        try {
+            if (MESSAGE_ZOOM_RECT.equals(event)) {
+                float x = (float)message.getDouble("x");
+                float y = (float)message.getDouble("y");
+                final RectF zoomRect = new RectF(x, y,
+                                     x + (float)message.getDouble("w"),
+                                     y + (float)message.getDouble("h"));
+                if (message.optBoolean("animate", true)) {
+                    mTarget.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            animatedZoomTo(zoomRect);
+                        }
+                    });
+                } else {
+                    mTarget.setViewportMetrics(getMetricsToZoomTo(zoomRect));
+                }
+            } else if (MESSAGE_ZOOM_PAGE.equals(event)) {
+                ImmutableViewportMetrics metrics = getMetrics();
+                RectF cssPageRect = metrics.getCssPageRect();
+
+                RectF viewableRect = metrics.getCssViewport();
+                float y = viewableRect.top;
+                // attempt to keep zoom keep focused on the center of the viewport
+                float newHeight = viewableRect.height() * cssPageRect.width() / viewableRect.width();
+                float dh = viewableRect.height() - newHeight; // increase in the height
+                final RectF r = new RectF(0.0f,
+                                    y + dh/2,
+                                    cssPageRect.width(),
+                                    y + dh/2 + newHeight);
+                if (message.optBoolean("animate", true)) {
+                    mTarget.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            animatedZoomTo(r);
+                        }
+                    });
+                } else {
+                    mTarget.setViewportMetrics(getMetricsToZoomTo(r));
+                }
+            } else if (MESSAGE_TOUCH_LISTENER.equals(event)) {
+	            Log.d("GeckoBrowser","JavaPanZoomController TouchEventHandler MESSAGE_TOUCH_LISTENER ");
+
+	            int tabId = message.getInt("tabID");
+                final Tab tab = Tabs.getInstance().getTab(tabId);
+                tab.setHasTouchListeners(true);
+                mTarget.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        if (Tabs.getInstance().isSelectedTab(tab))
+                            mTouchEventHandler.setWaitForTouchListeners(true);
+                    }
+                });
+            }
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Exception handling message \"" + event + "\":", e);
+        }
+    }
+
+    /** This function MUST be called on the UI thread */
+    @Override
+    public boolean onKeyEvent(KeyEvent event) {
+        if (Build.VERSION.SDK_INT <= 11) {
+            return false;
+        }
+
+        if ((event.getSource() & InputDevice.SOURCE_GAMEPAD) == InputDevice.SOURCE_GAMEPAD
+            && event.getAction() == KeyEvent.ACTION_DOWN) {
+
+            switch (event.getKeyCode()) {
+            case KeyEvent.KEYCODE_ZOOM_IN:
+                return animatedScale(0.2f);
+            case KeyEvent.KEYCODE_ZOOM_OUT:
+                return animatedScale(-0.2f);
+            }
+        }
+        return false;
+    }
+
+    /** This function MUST be called on the UI thread */
+    @Override
+    public boolean onMotionEvent(MotionEvent event) {
+        if (Build.VERSION.SDK_INT <= 11) {
+            return false;
+        }
+
+        switch (event.getSource() & InputDevice.SOURCE_CLASS_MASK) {
+        case InputDevice.SOURCE_CLASS_POINTER:
+            switch (event.getAction() & MotionEvent.ACTION_MASK) {
+            case MotionEvent.ACTION_SCROLL: return handlePointerScroll(event);
+            }
+            break;
+        case InputDevice.SOURCE_CLASS_JOYSTICK:
+            switch (event.getAction() & MotionEvent.ACTION_MASK) {
+            case MotionEvent.ACTION_MOVE: return handleJoystickNav(event);
+            }
+            break;
+        }
+        return false;
+    }
+
+    /** This function MUST be called on the UI thread */
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+	    Log.d("GeckoBrowser","JavaPanZoomController onTouchEvent ");
+	    return mTouchEventHandler.handleEvent(event);
+    }
+
+    boolean handleEvent(MotionEvent event, boolean defaultPrevented) {
+
+	    mDefaultPrevented = defaultPrevented;
+	    Log.d("GeckoBrowser","JavaPanZoomController handleEvent "+defaultPrevented+": ~~~ "+(event.getAction() & MotionEvent.ACTION_MASK));
+
+	    switch (event.getAction() & MotionEvent.ACTION_MASK) {
+        case MotionEvent.ACTION_DOWN:   return handleTouchStart(event);
+        case MotionEvent.ACTION_MOVE:   return handleTouchMove(event);
+        case MotionEvent.ACTION_UP:     return handleTouchEnd(event);
+        case MotionEvent.ACTION_CANCEL: return handleTouchCancel(event);
+        }
+        return false;
+    }
+
+    /** This function MUST be called on the UI thread */
+    @Override
+    public void notifyDefaultActionPrevented(boolean prevented) {
+	    Log.d("GeckoBrowser","JavaPanZoomController notifyDefaultActionPrevented "+prevented);
+
+	    mTouchEventHandler.handleEventListenerAction(!prevented);
+    }
+
+    /** This function must be called from the UI thread. */
+    @Override
+    public void abortAnimation() {
+        checkMainThread();
+        // this happens when gecko changes the viewport on us or if the device is rotated.
+        // if that's the case, abort any animation in progress and re-zoom so that the page
+        // snaps to edges. for other cases (where the user's finger(s) are down) don't do
+        // anything special.
+        switch (mState) {
+        case FLING:
+            mX.stopFling();
+            mY.stopFling();
+            // fall through
+        case BOUNCE:
+        case ANIMATED_ZOOM:
+            // the zoom that's in progress likely makes no sense any more (such as if
+            // the screen orientation changed) so abort it
+            setState(PanZoomState.NOTHING);
+            // fall through
+        case NOTHING:
+            // Don't do animations here; they're distracting and can cause flashes on page
+            // transitions.
+            synchronized (mTarget.getLock()) {
+                mTarget.setViewportMetrics(getValidViewportMetrics());
+                mTarget.forceRedraw(null);
+            }
+            break;
+        }
+    }
+
+    /** This function must be called on the UI thread. */
+    public void startingNewEventBlock(MotionEvent event, boolean waitingForTouchListeners) {
+        checkMainThread();
+        mSubscroller.cancel();
+        if (waitingForTouchListeners && (event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
+            // this is the first touch point going down, so we enter the pending state
+            // seting the state will kill any animations in progress, possibly leaving
+            // the page in overscroll
+            setState(PanZoomState.WAITING_LISTENERS);
+        }
+    }
+
+    /** This must be called on the UI thread. */
+    @Override
+    public void pageRectUpdated() {
+        if (mState == PanZoomState.NOTHING) {
+            synchronized (mTarget.getLock()) {
+                ImmutableViewportMetrics validated = getValidViewportMetrics();
+                if (!getMetrics().fuzzyEquals(validated)) {
+                    // page size changed such that we are now in overscroll. snap to the
+                    // the nearest valid viewport
+                    mTarget.setViewportMetrics(validated);
+                }
+            }
+        }
+    }
+
+    /*
+     * Panning/scrolling
+     */
+
+    private boolean handleTouchStart(MotionEvent event) {
+        // user is taking control of movement, so stop
+        // any auto-movement we have going
+        stopAnimationTask();
+
+        switch (mState) {
+        case ANIMATED_ZOOM:
+            // We just interrupted a double-tap animation, so force a redraw in
+            // case this touchstart is just a tap that doesn't end up triggering
+            // a redraw
+            mTarget.forceRedraw(null);
+            // fall through
+        case FLING:
+        case AUTONAV:
+        case BOUNCE:
+        case NOTHING:
+        case WAITING_LISTENERS:
+            startTouch(event.getX(0), event.getY(0), event.getEventTime());
+            return false;
+        case TOUCHING:
+        case PANNING:
+        case PANNING_LOCKED_X:
+        case PANNING_LOCKED_Y:
+        case PANNING_HOLD:
+        case PANNING_HOLD_LOCKED_X:
+        case PANNING_HOLD_LOCKED_Y:
+        case PINCHING:
+            Log.e(LOGTAG, "Received impossible touch down while in " + mState);
+            return false;
+        }
+        Log.e(LOGTAG, "Unhandled case " + mState + " in handleTouchStart");
+        return false;
+    }
+
+    private boolean handleTouchMove(MotionEvent event) {
+	    Log.d("GeckoBrowser","JavaPanZoomController handleTouchMove "+mState);
+
+	    switch (mState) {
+        case FLING:
+        case AUTONAV:
+        case BOUNCE:
+        case WAITING_LISTENERS:
+            // should never happen
+            Log.e(LOGTAG, "Received impossible touch move while in " + mState);
+            // fall through
+        case ANIMATED_ZOOM:
+        case NOTHING:
+            // may happen if user double-taps and drags without lifting after the
+            // second tap. ignore the move if this happens.
+            return false;
+
+        case TOUCHING:
+            // Don't allow panning if there is an element in full-screen mode. See bug 775511.
+            if ((mTarget.isFullScreen() && !mSubscroller.scrolling()) || panDistance(event) < PAN_THRESHOLD) {
+                return false;
+            }
+            cancelTouch();
+            startPanning(event.getX(0), event.getY(0), event.getEventTime());
+            track(event);
+            return true;
+
+        case PANNING_HOLD_LOCKED_X:
+            setState(PanZoomState.PANNING_LOCKED_X);
+            track(event);
+            return true;
+        case PANNING_HOLD_LOCKED_Y:
+            setState(PanZoomState.PANNING_LOCKED_Y);
+            // fall through
+        case PANNING_LOCKED_X:
+        case PANNING_LOCKED_Y:
+            track(event);
+            return true;
+
+        case PANNING_HOLD:
+            setState(PanZoomState.PANNING);
+            // fall through
+        case PANNING:
+            track(event);
+            return true;
+
+        case PINCHING:
+            // scale gesture listener will handle this
+            return false;
+        }
+        Log.e(LOGTAG, "Unhandled case " + mState + " in handleTouchMove");
+        return false;
+    }
+
+    private boolean handleTouchEnd(MotionEvent event) {
+	    Log.d("GeckoBrowser","JavaPanZoomController handleTouchEnd "+mState);
+
+	    switch (mState) {
+        case FLING:
+        case AUTONAV:
+        case BOUNCE:
+        case ANIMATED_ZOOM:
+        case NOTHING:
+            // may happen if user double-taps and drags without lifting after the
+            // second tap. ignore if this happens.
+            return false;
+
+        case WAITING_LISTENERS:
+            if (!mDefaultPrevented) {
+              // should never happen
+              Log.e(LOGTAG, "Received impossible touch end while in " + mState);
+            }
+            // fall through
+        case TOUCHING:
+            // the switch into TOUCHING might have happened while the page was
+            // snapping back after overscroll. we need to finish the snap if that
+            // was the case
+            bounce();
+            return false;
+
+        case PANNING:
+        case PANNING_LOCKED_X:
+        case PANNING_LOCKED_Y:
+        case PANNING_HOLD:
+        case PANNING_HOLD_LOCKED_X:
+        case PANNING_HOLD_LOCKED_Y:
+            setState(PanZoomState.FLING);
+            fling();
+            return true;
+
+        case PINCHING:
+            setState(PanZoomState.NOTHING);
+            return true;
+        }
+        Log.e(LOGTAG, "Unhandled case " + mState + " in handleTouchEnd");
+        return false;
+    }
+
+    private boolean handleTouchCancel(MotionEvent event) {
+	    Log.d("GeckoBrowser","JavaPanZoomController handleTouchCancel "+mState);
+
+	    cancelTouch();
+
+        // ensure we snap back if we're overscrolled
+        bounce();
+        return false;
+    }
+
+    private boolean handlePointerScroll(MotionEvent event) {
+        if (mState == PanZoomState.NOTHING || mState == PanZoomState.FLING) {
+            float scrollX = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
+            float scrollY = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
+            if (mNegateWheelScrollY) {
+                scrollY *= -1.0;
+            }
+            scrollBy(scrollX * MAX_SCROLL, scrollY * MAX_SCROLL);
+            bounce();
+            return true;
+        }
+        return false;
+    }
+
+    private float filterDeadZone(MotionEvent event, int axis) {
+        return (GamepadUtils.isValueInDeadZone(event, axis) ? 0 : event.getAxisValue(axis));
+    }
+
+    private float normalizeJoystickScroll(MotionEvent event, int axis) {
+        return filterDeadZone(event, axis) * MAX_SCROLL;
+    }
+
+    private float normalizeJoystickZoom(MotionEvent event, int axis) {
+        // negate MAX_ZOOM_DELTA so that pushing up on the stick zooms in
+        return filterDeadZone(event, axis) * -MAX_ZOOM_DELTA;
+    }
+
+    // Since this event is a position-based event rather than a motion-based event, we need to
+    // set up an AUTONAV animation to keep scrolling even while we don't get events.
+    private boolean handleJoystickNav(MotionEvent event) {
+        float velocityX = normalizeJoystickScroll(event, MotionEvent.AXIS_X);
+        float velocityY = normalizeJoystickScroll(event, MotionEvent.AXIS_Y);
+        float zoomDelta = normalizeJoystickZoom(event, MotionEvent.AXIS_RZ);
+
+        if (velocityX == 0 && velocityY == 0 && zoomDelta == 0) {
+            if (mState == PanZoomState.AUTONAV) {
+                bounce(); // if not needed, this will automatically go to state NOTHING
+                return true;
+            }
+            return false;
+        }
+
+        if (mState == PanZoomState.NOTHING) {
+            setState(PanZoomState.AUTONAV);
+            startAnimationRenderTask(new AutonavRenderTask());
+        }
+        if (mState == PanZoomState.AUTONAV) {
+            mX.setAutoscrollVelocity(velocityX);
+            mY.setAutoscrollVelocity(velocityY);
+            mAutonavZoomDelta = zoomDelta;
+            return true;
+        }
+        return false;
+    }
+
+    private void startTouch(float x, float y, long time) {
+        mX.startTouch(x);
+        mY.startTouch(y);
+        setState(PanZoomState.TOUCHING);
+        mLastEventTime = time;
+    }
+
+    private void startPanning(float x, float y, long time) {
+        float dx = mX.panDistance(x);
+        float dy = mY.panDistance(y);
+        double angle = Math.atan2(dy, dx); // range [-pi, pi]
+        angle = Math.abs(angle); // range [0, pi]
+
+        // When the touch move breaks through the pan threshold, reposition the touch down origin
+        // so the page won't jump when we start panning.
+        mX.startTouch(x);
+        mY.startTouch(y);
+        mLastEventTime = time;
+
+        if (mMode == AxisLockMode.STANDARD || mMode == AxisLockMode.STICKY) {
+            if (!mX.scrollable() || !mY.scrollable()) {
+                setState(PanZoomState.PANNING);
+            } else if (angle < AXIS_LOCK_ANGLE || angle > (Math.PI - AXIS_LOCK_ANGLE)) {
+                mY.setScrollingDisabled(true);
+                setState(PanZoomState.PANNING_LOCKED_X);
+            } else if (Math.abs(angle - (Math.PI / 2)) < AXIS_LOCK_ANGLE) {
+                mX.setScrollingDisabled(true);
+                setState(PanZoomState.PANNING_LOCKED_Y);
+            } else {
+                setState(PanZoomState.PANNING);
+            }
+        } else if (mMode == AxisLockMode.FREE) {
+            setState(PanZoomState.PANNING);
+        }
+    }
+
+    private float panDistance(MotionEvent move) {
+        float dx = mX.panDistance(move.getX(0));
+        float dy = mY.panDistance(move.getY(0));
+        return FloatMath.sqrt(dx * dx + dy * dy);
+    }
+
+    private void track(float x, float y, long time) {
+        float timeDelta = (float)(time - mLastEventTime);
+        if (FloatUtils.fuzzyEquals(timeDelta, 0)) {
+            // probably a duplicate event, ignore it. using a zero timeDelta will mess
+            // up our velocity
+            return;
+        }
+        mLastEventTime = time;
+
+
+        // if we're axis-locked check if the user is trying to scroll away from the lock
+        if (mMode == AxisLockMode.STICKY) {
+            float dx = mX.panDistance(x);
+            float dy = mY.panDistance(y);
+            double angle = Math.atan2(dy, dx); // range [-pi, pi]
+            angle = Math.abs(angle); // range [0, pi]
+
+            if (Math.abs(dx) > AXIS_BREAKOUT_THRESHOLD || Math.abs(dy) > AXIS_BREAKOUT_THRESHOLD) {
+                if (mState == PanZoomState.PANNING_LOCKED_X) {
+                    if (angle > AXIS_BREAKOUT_ANGLE && angle < (Math.PI - AXIS_BREAKOUT_ANGLE)) {
+                        mY.setScrollingDisabled(false);
+                        setState(PanZoomState.PANNING);
+                    }
+                 } else if (mState == PanZoomState.PANNING_LOCKED_Y) {
+                    if (Math.abs(angle - (Math.PI / 2)) > AXIS_BREAKOUT_ANGLE) {
+                        mX.setScrollingDisabled(false);
+                        setState(PanZoomState.PANNING);
+                    }
+                }
+            }
+        }
+
+        mX.updateWithTouchAt(x, timeDelta);
+        mY.updateWithTouchAt(y, timeDelta);
+    }
+
+    private void track(MotionEvent event) {
+        mX.saveTouchPos();
+        mY.saveTouchPos();
+
+        for (int i = 0; i < event.getHistorySize(); i++) {
+            track(event.getHistoricalX(0, i),
+                  event.getHistoricalY(0, i),
+                  event.getHistoricalEventTime(i));
+        }
+        track(event.getX(0), event.getY(0), event.getEventTime());
+
+        if (stopped()) {
+            if (mState == PanZoomState.PANNING) {
+                setState(PanZoomState.PANNING_HOLD);
+            } else if (mState == PanZoomState.PANNING_LOCKED_X) {
+                setState(PanZoomState.PANNING_HOLD_LOCKED_X);
+            } else if (mState == PanZoomState.PANNING_LOCKED_Y) {
+                setState(PanZoomState.PANNING_HOLD_LOCKED_Y);
+            } else {
+                // should never happen, but handle anyway for robustness
+                Log.e(LOGTAG, "Impossible case " + mState + " when stopped in track");
+                setState(PanZoomState.PANNING_HOLD);
+            }
+        }
+
+        mX.startPan();
+        mY.startPan();
+        updatePosition();
+    }
+
+    private void scrollBy(float dx, float dy) {
+        mTarget.scrollBy(dx, dy);
+    }
+
+    private void fling() {
+        updatePosition();
+
+        stopAnimationTask();
+
+        boolean stopped = stopped();
+        mX.startFling(stopped);
+        mY.startFling(stopped);
+
+        startAnimationRenderTask(new FlingRenderTask());
+    }
+
+    /* Performs a bounce-back animation to the given viewport metrics. */
+    private void bounce(ImmutableViewportMetrics metrics, PanZoomState state) {
+        stopAnimationTask();
+
+        ImmutableViewportMetrics bounceStartMetrics = getMetrics();
+        if (bounceStartMetrics.fuzzyEquals(metrics)) {
+            setState(PanZoomState.NOTHING);
+            return;
+        }
+
+        setState(state);
+
+        // At this point we have already set mState to BOUNCE or ANIMATED_ZOOM, so
+        // getRedrawHint() is returning false. This means we can safely call
+        // setAnimationTarget to set the new final display port and not have it get
+        // clobbered by display ports from intermediate animation frames.
+        mTarget.setAnimationTarget(metrics);
+        startAnimationRenderTask(new BounceRenderTask(bounceStartMetrics, metrics));
+    }
+
+    /* Performs a bounce-back animation to the nearest valid viewport metrics. */
+    private void bounce() {
+        bounce(getValidViewportMetrics(), PanZoomState.BOUNCE);
+    }
+
+    /* Starts the fling or bounce animation. */
+    private void startAnimationRenderTask(final PanZoomRenderTask task) {
+        if (mAnimationRenderTask != null) {
+            Log.e(LOGTAG, "Attempted to start a new task without canceling the old one!");
+            stopAnimationTask();
+        }
+
+        mAnimationRenderTask = task;
+        mTarget.postRenderTask(mAnimationRenderTask);
+    }
+
+    /* Stops the fling or bounce animation. */
+    private void stopAnimationTask() {
+        if (mAnimationRenderTask != null) {
+            mAnimationRenderTask.terminate();
+            mTarget.removeRenderTask(mAnimationRenderTask);
+            mAnimationRenderTask = null;
+        }
+    }
+
+    private float getVelocity() {
+        float xvel = mX.getRealVelocity();
+        float yvel = mY.getRealVelocity();
+        return FloatMath.sqrt(xvel * xvel + yvel * yvel);
+    }
+
+    @Override
+    public PointF getVelocityVector() {
+        return new PointF(mX.getRealVelocity(), mY.getRealVelocity());
+    }
+
+    private boolean stopped() {
+        return getVelocity() < STOPPED_THRESHOLD;
+    }
+
+    PointF resetDisplacement() {
+        return new PointF(mX.resetDisplacement(), mY.resetDisplacement());
+    }
+
+    private void updatePosition() {
+        mX.displace();
+        mY.displace();
+        PointF displacement = resetDisplacement();
+        if (FloatUtils.fuzzyEquals(displacement.x, 0.0f) && FloatUtils.fuzzyEquals(displacement.y, 0.0f)) {
+            return;
+        }
+        if (mDefaultPrevented || mSubscroller.scrollBy(displacement)) {
+            synchronized (mTarget.getLock()) {
+                mTarget.scrollMarginsBy(displacement.x, displacement.y);
+            }
+        } else {
+            synchronized (mTarget.getLock()) {
+                scrollBy(displacement.x, displacement.y);
+            }
+        }
+    }
+
+    /**
+     * This class is an implementation of RenderTask which enforces its implementor to run in the UI thread.
+     *
+     */
+    private abstract class PanZoomRenderTask extends RenderTask {
+
+        /**
+         * the time when the current frame was started in ns.
+         */
+        protected long mCurrentFrameStartTime;
+        /**
+         * The current frame duration in ns.
+         */
+        protected long mLastFrameTimeDelta;
+
+        private final Runnable mRunnable = new Runnable() {
+            @Override
+            public final void run() {
+                if (mContinueAnimation) {
+                    animateFrame();
+                }
+            }
+        };
+
+        private boolean mContinueAnimation = true;
+
+        public PanZoomRenderTask() {
+            super(false);
+        }
+
+        @Override
+        protected final boolean internalRun(long timeDelta, long currentFrameStartTime) {
+
+            mCurrentFrameStartTime = currentFrameStartTime;
+            mLastFrameTimeDelta = timeDelta;
+
+            mTarget.post(mRunnable);
+            return mContinueAnimation;
+        }
+
+        /**
+         * The method subclasses must override. This method is run on the UI thread thanks to internalRun
+         */
+        protected abstract void animateFrame();
+
+        /**
+         * Terminate the animation.
+         */
+        public void terminate() {
+            mContinueAnimation = false;
+        }
+    }
+
+    private class AutonavRenderTask extends PanZoomRenderTask {
+        public AutonavRenderTask() {
+            super();
+        }
+
+        @Override
+        protected void animateFrame() {
+            if (mState != PanZoomState.AUTONAV) {
+                finishAnimation();
+                return;
+            }
+
+            updatePosition();
+            synchronized (mTarget.getLock()) {
+                mTarget.setViewportMetrics(applyZoomDelta(getMetrics(), mAutonavZoomDelta));
+            }
+        }
+    }
+
+    /* The task that performs the bounce animation. */
+    private class BounceRenderTask extends PanZoomRenderTask {
+
+        /*
+         * The viewport metrics that represent the start and end of the bounce-back animation,
+         * respectively.
+         */
+        private ImmutableViewportMetrics mBounceStartMetrics;
+        private ImmutableViewportMetrics mBounceEndMetrics;
+        // How long ago this bounce was started in ns.
+        private long mBounceDuration;
+
+        BounceRenderTask(ImmutableViewportMetrics startMetrics, ImmutableViewportMetrics endMetrics) {
+            super();
+            mBounceStartMetrics = startMetrics;
+            mBounceEndMetrics = endMetrics;
+        }
+
+        @Override
+        protected void animateFrame() {
+            /*
+             * The pan/zoom controller might have signaled to us that it wants to abort the
+             * animation by setting the state to PanZoomState.NOTHING. Handle this case and bail
+             * out.
+             */
+            if (!(mState == PanZoomState.BOUNCE || mState == PanZoomState.ANIMATED_ZOOM)) {
+                finishAnimation();
+                return;
+            }
+
+            /* Perform the next frame of the bounce-back animation. */
+            mBounceDuration = mCurrentFrameStartTime - getStartTime();
+            if (mBounceDuration < BOUNCE_ANIMATION_DURATION) {
+                advanceBounce();
+                return;
+            }
+
+            /* Finally, if there's nothing else to do, complete the animation and go to sleep. */
+            finishBounce();
+            finishAnimation();
+            setState(PanZoomState.NOTHING);
+        }
+
+        /* Performs one frame of a bounce animation. */
+        private void advanceBounce() {
+            synchronized (mTarget.getLock()) {
+                float t = easeOut((float)mBounceDuration / BOUNCE_ANIMATION_DURATION);
+                ImmutableViewportMetrics newMetrics = mBounceStartMetrics.interpolate(mBounceEndMetrics, t);
+                mTarget.setViewportMetrics(newMetrics);
+            }
+        }
+
+        /* Concludes a bounce animation and snaps the viewport into place. */
+        private void finishBounce() {
+            synchronized (mTarget.getLock()) {
+                mTarget.setViewportMetrics(mBounceEndMetrics);
+            }
+        }
+    }
+
+    // The callback that performs the fling animation.
+    private class FlingRenderTask extends PanZoomRenderTask {
+
+        public FlingRenderTask() {
+            super();
+        }
+
+        @Override
+        protected void animateFrame() {
+            /*
+             * The pan/zoom controller might have signaled to us that it wants to abort the
+             * animation by setting the state to PanZoomState.NOTHING. Handle this case and bail
+             * out.
+             */
+            if (mState != PanZoomState.FLING) {
+                finishAnimation();
+                return;
+            }
+
+            /* Advance flings, if necessary. */
+            boolean flingingX = mX.advanceFling(mLastFrameTimeDelta);
+            boolean flingingY = mY.advanceFling(mLastFrameTimeDelta);
+
+            boolean overscrolled = (mX.overscrolled() || mY.overscrolled());
+
+            /* If we're still flinging in any direction, update the origin. */
+            if (flingingX || flingingY) {
+                updatePosition();
+
+                /*
+                 * Check to see if we're still flinging with an appreciable velocity. The threshold is
+                 * higher in the case of overscroll, so we bounce back eagerly when overscrolling but
+                 * coast smoothly to a stop when not. In other words, require a greater velocity to
+                 * maintain the fling once we enter overscroll.
+                 */
+                float threshold = (overscrolled && !mSubscroller.scrolling() ? STOPPED_THRESHOLD : FLING_STOPPED_THRESHOLD);
+                if (getVelocity() >= threshold) {
+                    // we're still flinging
+                    return;
+                }
+
+                mX.stopFling();
+                mY.stopFling();
+            }
+
+            /* Perform a bounce-back animation if overscrolled. */
+            if (overscrolled) {
+                bounce();
+            } else {
+                finishAnimation();
+                setState(PanZoomState.NOTHING);
+            }
+        }
+    }
+
+    private void finishAnimation() {
+        checkMainThread();
+
+        stopAnimationTask();
+
+        // Force a viewport synchronisation
+        mTarget.forceRedraw(null);
+    }
+
+    /* Returns the nearest viewport metrics with no overscroll visible. */
+    private ImmutableViewportMetrics getValidViewportMetrics() {
+        return getValidViewportMetrics(getMetrics());
+    }
+
+    private ImmutableViewportMetrics getValidViewportMetrics(ImmutableViewportMetrics viewportMetrics) {
+        /* First, we adjust the zoom factor so that we can make no overscrolled area visible. */
+        float zoomFactor = viewportMetrics.zoomFactor;
+        RectF pageRect = viewportMetrics.getPageRect();
+        RectF viewport = viewportMetrics.getViewport();
+
+        float focusX = viewport.width() / 2.0f;
+        float focusY = viewport.height() / 2.0f;
+
+        float minZoomFactor = 0.0f;
+        float maxZoomFactor = MAX_ZOOM;
+
+        ZoomConstraints constraints = mTarget.getZoomConstraints();
+
+        if (constraints.getMinZoom() > 0)
+            minZoomFactor = constraints.getMinZoom();
+        if (constraints.getMaxZoom() > 0)
+            maxZoomFactor = constraints.getMaxZoom();
+
+        if (!constraints.getAllowZoom()) {
+            // If allowZoom is false, clamp to the default zoom level.
+            maxZoomFactor = minZoomFactor = constraints.getDefaultZoom();
+        }
+
+        // Ensure minZoomFactor keeps the page at least as big as the viewport.
+        if (pageRect.width() > 0) {
+            float pageWidth = pageRect.width() +
+              viewportMetrics.marginLeft +
+              viewportMetrics.marginRight;
+            float scaleFactor = viewport.width() / pageWidth;
+            minZoomFactor = Math.max(minZoomFactor, zoomFactor * scaleFactor);
+            if (viewport.width() > pageWidth)
+                focusX = 0.0f;
+        }
+        if (pageRect.height() > 0) {
+            float pageHeight = pageRect.height() +
+              viewportMetrics.marginTop +
+              viewportMetrics.marginBottom;
+            float scaleFactor = viewport.height() / pageHeight;
+            minZoomFactor = Math.max(minZoomFactor, zoomFactor * scaleFactor);
+            if (viewport.height() > pageHeight)
+                focusY = 0.0f;
+        }
+
+        maxZoomFactor = Math.max(maxZoomFactor, minZoomFactor);
+
+        if (zoomFactor < minZoomFactor) {
+            // if one (or both) of the page dimensions is smaller than the viewport,
+            // zoom using the top/left as the focus on that axis. this prevents the
+            // scenario where, if both dimensions are smaller than the viewport, but
+            // by different scale factors, we end up scrolled to the end on one axis
+            // after applying the scale
+            PointF center = new PointF(focusX, focusY);
+            viewportMetrics = viewportMetrics.scaleTo(minZoomFactor, center);
+        } else if (zoomFactor > maxZoomFactor) {
+            PointF center = new PointF(viewport.width() / 2.0f, viewport.height() / 2.0f);
+            viewportMetrics = viewportMetrics.scaleTo(maxZoomFactor, center);
+        }
+
+        /* Now we pan to the right origin. */
+        viewportMetrics = viewportMetrics.clampWithMargins();
+
+        return viewportMetrics;
+    }
+
+    private class AxisX extends Axis {
+        AxisX(SubdocumentScrollHelper subscroller) { super(subscroller); }
+        @Override
+        public float getOrigin() { return getMetrics().viewportRectLeft; }
+        @Override
+        protected float getViewportLength() { return getMetrics().getWidth(); }
+        @Override
+        protected float getPageStart() { return getMetrics().pageRectLeft; }
+        @Override
+        protected float getMarginStart() { return mTarget.getMaxMargins().left - getMetrics().marginLeft; }
+        @Override
+        protected float getMarginEnd() { return mTarget.getMaxMargins().right - getMetrics().marginRight; }
+        @Override
+        protected float getPageLength() { return getMetrics().getPageWidthWithMargins(); }
+        @Override
+        protected boolean marginsHidden() {
+            ImmutableViewportMetrics metrics = getMetrics();
+            RectF maxMargins = mTarget.getMaxMargins();
+            return (metrics.marginLeft < maxMargins.left || metrics.marginRight < maxMargins.right);
+        }
+        @Override
+        protected void overscrollFling(final float velocity) {
+            if (mOverscroll != null) {
+                mOverscroll.setVelocity(velocity, Overscroll.Axis.X);
+            }
+        }
+        @Override
+        protected void overscrollPan(final float distance) {
+            if (mOverscroll != null) {
+                mOverscroll.setDistance(distance, Overscroll.Axis.X);
+            }
+        }
+    }
+
+    private class AxisY extends Axis {
+        AxisY(SubdocumentScrollHelper subscroller) { super(subscroller); }
+        @Override
+        public float getOrigin() { return getMetrics().viewportRectTop; }
+        @Override
+        protected float getViewportLength() { return getMetrics().getHeight(); }
+        @Override
+        protected float getPageStart() { return getMetrics().pageRectTop; }
+        @Override
+        protected float getPageLength() { return getMetrics().getPageHeightWithMargins(); }
+        @Override
+        protected float getMarginStart() { return mTarget.getMaxMargins().top - getMetrics().marginTop; }
+        @Override
+        protected float getMarginEnd() { return mTarget.getMaxMargins().bottom - getMetrics().marginBottom; }
+        @Override
+        protected boolean marginsHidden() {
+            ImmutableViewportMetrics metrics = getMetrics();
+            RectF maxMargins = mTarget.getMaxMargins();
+            return (metrics.marginTop < maxMargins.top || metrics.marginBottom < maxMargins.bottom);
+        }
+        @Override
+        protected void overscrollFling(final float velocity) {
+            if (mOverscroll != null) {
+                mOverscroll.setVelocity(velocity, Overscroll.Axis.Y);
+            }
+        }
+        @Override
+        protected void overscrollPan(final float distance) {
+            if (mOverscroll != null) {
+                mOverscroll.setDistance(distance, Overscroll.Axis.Y);
+            }
+        }
+    }
+
+    /*
+     * Zooming
+     */
+    @Override
+    public boolean onScaleBegin(SimpleScaleGestureDetector detector) {
+        if (mState == PanZoomState.ANIMATED_ZOOM)
+            return false;
+
+        if (!mTarget.getZoomConstraints().getAllowZoom())
+            return false;
+
+        setState(PanZoomState.PINCHING);
+        mLastZoomFocus = new PointF(detector.getFocusX(), detector.getFocusY());
+        cancelTouch();
+	    Log.d("GeckoBrowser","JavaPanZoomController onScaleBegin ");
+
+	    GeckoAppShell.sendEventToGecko(GeckoEvent.createNativeGestureEvent(GeckoEvent.ACTION_MAGNIFY_START, mLastZoomFocus, getMetrics().zoomFactor));
+
+        return true;
+    }
+
+    @Override
+    public boolean onScale(SimpleScaleGestureDetector detector) {
+        if (mTarget.isFullScreen())
+            return false;
+
+        if (mState != PanZoomState.PINCHING)
+            return false;
+
+        float prevSpan = detector.getPreviousSpan();
+        if (FloatUtils.fuzzyEquals(prevSpan, 0.0f)) {
+            // let's eat this one to avoid setting the new zoom to infinity (bug 711453)
+            return true;
+        }
+
+        synchronized (mTarget.getLock()) {
+            float zoomFactor = getAdjustedZoomFactor(detector.getCurrentSpan() / prevSpan);
+            scrollBy(mLastZoomFocus.x - detector.getFocusX(),
+                     mLastZoomFocus.y - detector.getFocusY());
+            mLastZoomFocus.set(detector.getFocusX(), detector.getFocusY());
+            ImmutableViewportMetrics target = getMetrics().scaleTo(zoomFactor, mLastZoomFocus);
+
+            // If overscroll is diabled, prevent zooming outside the normal document pans.
+            if (mX.getOverScrollMode() == View.OVER_SCROLL_NEVER || mY.getOverScrollMode() == View.OVER_SCROLL_NEVER) {
+                target = getValidViewportMetrics(target);
+            }
+            mTarget.setViewportMetrics(target);
+        }
+
+        GeckoEvent event = GeckoEvent.createNativeGestureEvent(GeckoEvent.ACTION_MAGNIFY, mLastZoomFocus, getMetrics().zoomFactor);
+        GeckoAppShell.sendEventToGecko(event);
+
+        return true;
+    }
+
+    private ImmutableViewportMetrics applyZoomDelta(ImmutableViewportMetrics metrics, float zoomDelta) {
+        float oldZoom = metrics.zoomFactor;
+        float newZoom = oldZoom + zoomDelta;
+        float adjustedZoom = getAdjustedZoomFactor(newZoom / oldZoom);
+        // since we don't have a particular focus to zoom to, just use the center
+        PointF center = new PointF(metrics.getWidth() / 2.0f, metrics.getHeight() / 2.0f);
+        metrics = metrics.scaleTo(adjustedZoom, center);
+        return metrics;
+    }
+
+    private boolean animatedScale(float zoomDelta) {
+        if (mState != PanZoomState.NOTHING && mState != PanZoomState.BOUNCE) {
+            return false;
+        }
+        synchronized (mTarget.getLock()) {
+            ImmutableViewportMetrics metrics = applyZoomDelta(getMetrics(), zoomDelta);
+            bounce(getValidViewportMetrics(metrics), PanZoomState.BOUNCE);
+        }
+        return true;
+    }
+
+    private float getAdjustedZoomFactor(float zoomRatio) {
+        /*
+         * Apply edge resistance if we're zoomed out smaller than the page size by scaling the zoom
+         * factor toward 1.0.
+         */
+        float resistance = Math.min(mX.getEdgeResistance(true), mY.getEdgeResistance(true));
+        if (zoomRatio > 1.0f)
+            zoomRatio = 1.0f + (zoomRatio - 1.0f) * resistance;
+        else
+            zoomRatio = 1.0f - (1.0f - zoomRatio) * resistance;
+
+        float newZoomFactor = getMetrics().zoomFactor * zoomRatio;
+        float minZoomFactor = 0.0f;
+        float maxZoomFactor = MAX_ZOOM;
+
+        ZoomConstraints constraints = mTarget.getZoomConstraints();
+
+        if (constraints.getMinZoom() > 0)
+            minZoomFactor = constraints.getMinZoom();
+        if (constraints.getMaxZoom() > 0)
+            maxZoomFactor = constraints.getMaxZoom();
+
+        if (newZoomFactor < minZoomFactor) {
+            // apply resistance when zooming past minZoomFactor,
+            // such that it asymptotically reaches minZoomFactor / 2.0
+            // but never exceeds that
+            final float rate = 0.5f; // controls how quickly we approach the limit
+            float excessZoom = minZoomFactor - newZoomFactor;
+            excessZoom = 1.0f - (float)Math.exp(-excessZoom * rate);
+            newZoomFactor = minZoomFactor * (1.0f - excessZoom / 2.0f);
+        }
+
+        if (newZoomFactor > maxZoomFactor) {
+            // apply resistance when zooming past maxZoomFactor,
+            // such that it asymptotically reaches maxZoomFactor + 1.0
+            // but never exceeds that
+            float excessZoom = newZoomFactor - maxZoomFactor;
+            excessZoom = 1.0f - (float)Math.exp(-excessZoom);
+            newZoomFactor = maxZoomFactor + excessZoom;
+        }
+
+        return newZoomFactor;
+    }
+
+    @Override
+    public void onScaleEnd(SimpleScaleGestureDetector detector) {
+        if (mState == PanZoomState.ANIMATED_ZOOM)
+            return;
+
+        // switch back to the touching state
+        startTouch(detector.getFocusX(), detector.getFocusY(), detector.getEventTime());
+
+        // Force a viewport synchronisation
+        mTarget.forceRedraw(null);
+
+        PointF point = new PointF(detector.getFocusX(), detector.getFocusY());
+        GeckoEvent event = GeckoEvent.createNativeGestureEvent(GeckoEvent.ACTION_MAGNIFY_END, point, getMetrics().zoomFactor);
+
+        if (event == null) {
+            return;
+        }
+
+        GeckoAppShell.sendEventToGecko(event);
+    }
+
+    @Override
+    public boolean getRedrawHint() {
+        switch (mState) {
+            case PINCHING:
+            case ANIMATED_ZOOM:
+            case BOUNCE:
+                // don't redraw during these because the zoom is (or might be, in the case
+                // of BOUNCE) be changing rapidly and gecko will have to redraw the entire
+                // display port area. we trigger a force-redraw upon exiting these states.
+                return false;
+            default:
+                // allow redrawing in other states
+                return true;
+        }
+    }
+
+    private void sendPointToGecko(String event, MotionEvent motionEvent) {
+        String json;
+        try {
+            PointF point = new PointF(motionEvent.getX(), motionEvent.getY());
+            point = mTarget.convertViewPointToLayerPoint(point);
+            if (point == null) {
+                return;
+            }
+            json = PointUtils.toJSON(point).toString();
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Unable to convert point to JSON for " + event, e);
+            return;
+        }
+
+        GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent(event, json));
+    }
+
+    @Override
+    public boolean onDown(MotionEvent motionEvent) {
+        mMediumPress = false;
+        return false;
+    }
+
+    @Override
+    public void onShowPress(MotionEvent motionEvent) {
+        // If we get this, it will be followed either by a call to
+        // onSingleTapUp (if the user lifts their finger before the
+        // long-press timeout) or a call to onLongPress (if the user
+        // does not). In the former case, we want to make sure it is
+        // treated as a click. (Note that if this is called, we will
+        // not get a call to onDoubleTap).
+        mMediumPress = true;
+    }
+
+    @Override
+    public void onLongPress(MotionEvent motionEvent) {
+        sendPointToGecko("Gesture:LongPress", motionEvent);
+    }
+
+    @Override
+    public boolean onSingleTapUp(MotionEvent motionEvent) {
+	    Log.d("GeckoBrowser","JavaPanZoomController onSingleTapUp "+mMediumPress+":"+!mTarget.getZoomConstraints().getAllowDoubleTapZoom());
+
+	    // When double-tapping is allowed, we have to wait to see if this is
+        // going to be a double-tap.
+        // However, if mMediumPress is true then we know there will be no
+        // double-tap so we treat this as a click.
+        if (mMediumPress || !mTarget.getZoomConstraints().getAllowDoubleTapZoom()) {
+            sendPointToGecko("Gesture:SingleTap", motionEvent);
+        }
+        // return false because we still want to get the ACTION_UP event that triggers this
+        return false;
+    }
+
+    @Override
+    public boolean onSingleTapConfirmed(MotionEvent motionEvent) {
+	    Log.d("GeckoBrowser","JavaPanZoomController onSingleTapConfirmed "+mTarget.getZoomConstraints().getAllowDoubleTapZoom());
+
+	    // When zooming is disabled, we handle this in onSingleTapUp.
+        if (mTarget.getZoomConstraints().getAllowDoubleTapZoom()) {
+            sendPointToGecko("Gesture:SingleTap", motionEvent);
+        }
+        return true;
+    }
+
+    @Override
+    public boolean onDoubleTap(MotionEvent motionEvent) {
+        if (mTarget.getZoomConstraints().getAllowDoubleTapZoom()) {
+            sendPointToGecko("Gesture:DoubleTap", motionEvent);
+        }
+        return true;
+    }
+
+    private void cancelTouch() {
+        GeckoEvent e = GeckoEvent.createBroadcastEvent("Gesture:CancelTouch", "");
+        GeckoAppShell.sendEventToGecko(e);
+    }
+
+    /**
+     * Zoom to a specified rect IN CSS PIXELS.
+     *
+     * While we usually use device pixels, @zoomToRect must be specified in CSS
+     * pixels.
+     */
+    private ImmutableViewportMetrics getMetricsToZoomTo(RectF zoomToRect) {
+        final float startZoom = getMetrics().zoomFactor;
+
+        RectF viewport = getMetrics().getViewport();
+        // 1. adjust the aspect ratio of zoomToRect to match that of the current viewport,
+        // enlarging as necessary (if it gets too big, it will get shrunk in the next step).
+        // while enlarging make sure we enlarge equally on both sides to keep the target rect
+        // centered.
+        float targetRatio = viewport.width() / viewport.height();
+        float rectRatio = zoomToRect.width() / zoomToRect.height();
+        if (FloatUtils.fuzzyEquals(targetRatio, rectRatio)) {
+            // all good, do nothing
+        } else if (targetRatio < rectRatio) {
+            // need to increase zoomToRect height
+            float newHeight = zoomToRect.width() / targetRatio;
+            zoomToRect.top -= (newHeight - zoomToRect.height()) / 2;
+            zoomToRect.bottom = zoomToRect.top + newHeight;
+        } else { // targetRatio > rectRatio) {
+            // need to increase zoomToRect width
+            float newWidth = targetRatio * zoomToRect.height();
+            zoomToRect.left -= (newWidth - zoomToRect.width()) / 2;
+            zoomToRect.right = zoomToRect.left + newWidth;
+        }
+
+        float finalZoom = viewport.width() / zoomToRect.width();
+
+        ImmutableViewportMetrics finalMetrics = getMetrics();
+        finalMetrics = finalMetrics.setViewportOrigin(
+            zoomToRect.left * finalMetrics.zoomFactor,
+            zoomToRect.top * finalMetrics.zoomFactor);
+        finalMetrics = finalMetrics.scaleTo(finalZoom, new PointF(0.0f, 0.0f));
+
+        // 2. now run getValidViewportMetrics on it, so that the target viewport is
+        // clamped down to prevent overscroll, over-zoom, and other bad conditions.
+        finalMetrics = getValidViewportMetrics(finalMetrics);
+        return finalMetrics;
+    }
+
+    private boolean animatedZoomTo(RectF zoomToRect) {
+        bounce(getMetricsToZoomTo(zoomToRect), PanZoomState.ANIMATED_ZOOM);
+        return true;
+    }
+
+    /** This function must be called from the UI thread. */
+    @Override
+    public void abortPanning() {
+        checkMainThread();
+        bounce();
+    }
+
+    @Override
+    public void setOverScrollMode(int overscrollMode) {
+        mX.setOverScrollMode(overscrollMode);
+        mY.setOverScrollMode(overscrollMode);
+    }
+
+    @Override
+    public int getOverScrollMode() {
+        return mX.getOverScrollMode();
+    }
+
+    @Override
+    public void setOverscrollHandler(final Overscroll handler) {
+        mOverscroll = handler;
+    }
+}
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/gfx/LayerView.java.orig
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/gfx/LayerView.java.orig	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,725 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.gecko.gfx;
+
+import org.mozilla.gecko.GeckoAccessibility;
+import org.mozilla.gecko.GeckoAppShell;
+import org.mozilla.gecko.GeckoEvent;
+import org.mozilla.gecko.PrefsHelper;
+import org.mozilla.gecko.R;
+import org.mozilla.gecko.Tab;
+import org.mozilla.gecko.Tabs;
+import org.mozilla.gecko.TouchEventInterceptor;
+import org.mozilla.gecko.ZoomConstraints;
+import org.mozilla.gecko.mozglue.generatorannotations.WrapElementForJNI;
+import org.mozilla.gecko.mozglue.RobocopTarget;
+import org.mozilla.gecko.EventDispatcher;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.PixelFormat;
+import android.graphics.Point;
+import android.graphics.PointF;
+import android.graphics.Rect;
+import android.graphics.SurfaceTexture;
+import android.os.Build;
+import android.os.Handler;
+import android.util.AttributeSet;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.SurfaceHolder;
+import android.view.SurfaceView;
+import android.view.TextureView;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.inputmethod.EditorInfo;
+import android.view.inputmethod.InputConnection;
+import android.widget.FrameLayout;
+
+import java.nio.IntBuffer;
+import java.util.ArrayList;
+
+/**
+ * A view rendered by the layer compositor.
+ *
+ * Note that LayerView is accessed by Robocop via reflection.
+ */
+public class LayerView extends FrameLayout implements Tabs.OnTabsChangedListener {
+    private static String LOGTAG = "GeckoLayerView";
+
+    private GeckoLayerClient mLayerClient;
+    private PanZoomController mPanZoomController;
+    private LayerMarginsAnimator mMarginsAnimator;
+    private GLController mGLController;
+    private InputConnectionHandler mInputConnectionHandler;
+    private LayerRenderer mRenderer;
+    /* Must be a PAINT_xxx constant */
+    private int mPaintState;
+    private int mBackgroundColor;
+    private boolean mFullScreen;
+
+    private SurfaceView mSurfaceView;
+    private TextureView mTextureView;
+
+    private Listener mListener;
+
+    /* This should only be modified on the Java UI thread. */
+    private final ArrayList<TouchEventInterceptor> mTouchInterceptors;
+    private final Overscroll mOverscroll;
+
+    /* Flags used to determine when to show the painted surface. */
+    public static final int PAINT_START = 0;
+    public static final int PAINT_BEFORE_FIRST = 1;
+    public static final int PAINT_AFTER_FIRST = 2;
+
+    public boolean shouldUseTextureView() {
+        // Disable TextureView support for now as it causes panning/zooming
+        // performance regressions (see bug 792259). Uncomment the code below
+        // once this bug is fixed.
+        return false;
+
+        /*
+        // we can only use TextureView on ICS or higher
+        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+            Log.i(LOGTAG, "Not using TextureView: not on ICS+");
+            return false;
+        }
+
+        try {
+            // and then we can only use it if we have a hardware accelerated window
+            Method m = View.class.getMethod("isHardwareAccelerated", (Class[]) null);
+            return (Boolean) m.invoke(this);
+        } catch (Exception e) {
+            Log.i(LOGTAG, "Not using TextureView: caught exception checking for hw accel: " + e.toString());
+            return false;
+        } */
+    }
+
+    public LayerView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        mGLController = GLController.getInstance(this);
+        mPaintState = PAINT_START;
+        mBackgroundColor = Color.WHITE;
+
+        mTouchInterceptors = new ArrayList<TouchEventInterceptor>();
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+            mOverscroll = new OverscrollEdgeEffect(this);
+        } else {
+            mOverscroll = null;
+        }
+        Tabs.registerOnTabsChangedListener(this);
+    }
+
+    public LayerView(Context context) {
+        this(context, null);
+    }
+
+    public void initializeView(EventDispatcher eventDispatcher) {
+        mLayerClient = new GeckoLayerClient(getContext(), this, eventDispatcher);
+        if (mOverscroll != null) {
+            mLayerClient.setOverscrollHandler(mOverscroll);
+        }
+
+        mPanZoomController = mLayerClient.getPanZoomController();
+        mMarginsAnimator = mLayerClient.getLayerMarginsAnimator();
+
+        mRenderer = new LayerRenderer(this);
+        mInputConnectionHandler = null;
+
+        setFocusable(true);
+        setFocusableInTouchMode(true);
+
+        GeckoAccessibility.setDelegate(this);
+    }
+
+    private Point getEventRadius(MotionEvent event) {
+        if (Build.VERSION.SDK_INT >= 9) {
+            return new Point((int)event.getToolMajor()/2,
+                             (int)event.getToolMinor()/2);
+        }
+
+        float size = event.getSize();
+        DisplayMetrics displaymetrics = getContext().getResources().getDisplayMetrics();
+        size = size * Math.min(displaymetrics.heightPixels, displaymetrics.widthPixels);
+        return new Point((int)size, (int)size);
+    }
+
+    public void geckoConnected() {
+        // See if we want to force 16-bit colour before doing anything
+        PrefsHelper.getPref("gfx.android.rgb16.force", new PrefsHelper.PrefHandlerBase() {
+            @Override public void prefValue(String pref, boolean force16bit) {
+                if (force16bit) {
+                    GeckoAppShell.setScreenDepthOverride(16);
+                }
+            }
+        });
+
+        mLayerClient.notifyGeckoReady();
+        addTouchInterceptor(new TouchEventInterceptor() {
+            private PointF mInitialTouchPoint = null;
+
+            @Override
+            public boolean onInterceptTouchEvent(View view, MotionEvent event) {
+                return false;
+            }
+
+            @Override
+            public boolean onTouch(View view, MotionEvent event) {
+	            Log.d("GeckoBrowser","28/3 onTouch "+event);
+                if (event == null) {
+                    return true;
+                }
+
+                int action = event.getActionMasked();
+                PointF point = new PointF(event.getX(), event.getY());
+	            Log.d("GeckoBrowser","28/3 onTouch action "+action);
+	            if (action == MotionEvent.ACTION_DOWN) {
+                    mInitialTouchPoint = point;
+                }
+
+                if (mInitialTouchPoint != null && action == MotionEvent.ACTION_MOVE) {
+                    Point p = getEventRadius(event);
+
+                    if (PointUtils.subtract(point, mInitialTouchPoint).length() <
+                        Math.max(PanZoomController.CLICK_THRESHOLD, Math.min(Math.min(p.x, p.y), PanZoomController.PAN_THRESHOLD))) {
+	                    Log.d("GeckoBrowser","28/3 LayerView onTouch ointUtils.subtract(point, mInitialTouchPoint).length() <\n" +
+			                    "                        Math.max(PanZoomController.CLICK_THRESHOLD, Math.min(Math.min(p.x, p.y), PanZoomController.PAN_THRESHOLD))");
+
+	                    // Don't send the touchmove event if if the users finger hasn't moved far.
+                        // Necessary for Google Maps to work correctly. See bug 771099.
+                        return true;
+                    } else {
+                        mInitialTouchPoint = null;
+                    }
+                }
+	            Log.d("GeckoBrowser","LayerView onTouch");
+
+	            GeckoAppShell.sendEventToGecko(GeckoEvent.createMotionEvent(event, false));
+                return true;
+            }
+        });
+    }
+
+    public void showSurface() {
+        // Fix this if TextureView support is turned back on above
+        mSurfaceView.setVisibility(View.VISIBLE);
+    }
+
+    public void hideSurface() {
+        // Fix this if TextureView support is turned back on above
+        mSurfaceView.setVisibility(View.INVISIBLE);
+    }
+
+    public void destroy() {
+        if (mLayerClient != null) {
+            mLayerClient.destroy();
+        }
+        if (mRenderer != null) {
+            mRenderer.destroy();
+        }
+        Tabs.unregisterOnTabsChangedListener(this);
+    }
+
+    public void addTouchInterceptor(final TouchEventInterceptor aTouchInterceptor) {
+        post(new Runnable() {
+            @Override
+            public void run() {
+                mTouchInterceptors.add(aTouchInterceptor);
+            }
+        });
+    }
+
+    public void removeTouchInterceptor(final TouchEventInterceptor aTouchInterceptor) {
+        post(new Runnable() {
+            @Override
+            public void run() {
+                mTouchInterceptors.remove(aTouchInterceptor);
+            }
+        });
+    }
+
+    private boolean runTouchInterceptors(MotionEvent event, boolean aOnTouch) {
+	    Log.d("GeckoBrowser","runTouchInterceptors "+aOnTouch+":"+mTouchInterceptors.size());
+
+	    boolean result = false;
+        for (TouchEventInterceptor i : mTouchInterceptors) {
+	        Log.d("GeckoBrowser","runTouchInterceptors mTouchInterceptors "+i);
+
+	        if (aOnTouch) {
+                result |= i.onTouch(this, event);
+            } else {
+                result |= i.onInterceptTouchEvent(this, event);
+            }
+        }
+	    Log.d("GeckoBrowser","runTouchInterceptors mTouchInterceptors result "+result);
+
+	    return result;
+    }
+
+    @Override
+    public void dispatchDraw(final Canvas canvas) {
+        super.dispatchDraw(canvas);
+
+        // We must have a layer client to get valid viewport metrics
+        if (mLayerClient != null && mOverscroll != null) {
+            mOverscroll.draw(canvas, getViewportMetrics());
+        }
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+	    Log.d("GeckoBrowser","onTouchEvent event.getActionMasked() ");
+
+	    if (event.getActionMasked() == MotionEvent.ACTION_DOWN) {
+            requestFocus();
+        }
+
+        if (runTouchInterceptors(event, false)) {
+	        Log.d("GeckoBrowser","onTouchEvent runTouchInterceptors false ");
+
+	        return true;
+        }
+
+	    if (mPanZoomController != null && mPanZoomController.onTouchEvent(event)) {
+		    Log.d("GeckoBrowser","onTouchEvent mPanZoomController.onTouchEvent(event) true ");
+		    return true;
+        }
+        if (runTouchInterceptors(event, true)) {
+	        Log.d("GeckoBrowser","onTouchEvent runTouchInterceptors true ");
+	        return true;
+        }
+	    Log.d("GeckoBrowser","onTouchEvent runTouchInterceptors false ");
+
+
+	    return false;
+    }
+
+    @Override
+    public boolean onHoverEvent(MotionEvent event) {
+	    Log.d("GeckoBrowser","onHoverEvent "+event);
+        if (runTouchInterceptors(event, true)) {
+	        Log.d("GeckoBrowser","onHoverEvent return ");
+	        return true;
+        }
+	    Log.d("GeckoBrowser","onHoverEvent false ");
+	    return false;
+    }
+
+    @Override
+    public boolean onGenericMotionEvent(MotionEvent event) {
+
+	    if (mPanZoomController != null && mPanZoomController.onMotionEvent(event)) {
+		    Log.d("GeckoBrowser","28/3 onGenericMotionEvent true");
+		    return true;
+        }
+	    Log.d("GeckoBrowser","28/3 onGenericMotionEvent false");
+	    return false;
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        // This check should not be done before the view is attached to a window
+        // as hardware acceleration will not be enabled at that point.
+        // We must create and add the SurfaceView instance before the view tree
+        // is fully created to avoid flickering (see bug 801477).
+        if (shouldUseTextureView()) {
+            mTextureView = new TextureView(getContext());
+            mTextureView.setSurfaceTextureListener(new SurfaceTextureListener());
+
+            // The background is set to this color when the LayerView is
+            // created, and it will be shown immediately at startup. Shortly
+            // after, the tab's background color will be used before any content
+            // is shown.
+            mTextureView.setBackgroundColor(Color.WHITE);
+            addView(mTextureView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
+        } else {
+            // This will stop PropertyAnimator from creating a drawing cache (i.e. a bitmap)
+            // from a SurfaceView, which is just not possible (the bitmap will be transparent).
+            setWillNotCacheDrawing(false);
+
+            mSurfaceView = new LayerSurfaceView(getContext(), this);
+            mSurfaceView.setBackgroundColor(Color.WHITE);
+            addView(mSurfaceView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
+
+            SurfaceHolder holder = mSurfaceView.getHolder();
+            holder.addCallback(new SurfaceListener());
+            holder.setFormat(PixelFormat.RGB_565);
+        }
+    }
+
+    @RobocopTarget
+    public GeckoLayerClient getLayerClient() { return mLayerClient; }
+    public PanZoomController getPanZoomController() { return mPanZoomController; }
+    public LayerMarginsAnimator getLayerMarginsAnimator() { return mMarginsAnimator; }
+
+    public ImmutableViewportMetrics getViewportMetrics() {
+        return mLayerClient.getViewportMetrics();
+    }
+
+    public void abortPanning() {
+        if (mPanZoomController != null) {
+            mPanZoomController.abortPanning();
+        }
+    }
+
+    public PointF convertViewPointToLayerPoint(PointF viewPoint) {
+        return mLayerClient.convertViewPointToLayerPoint(viewPoint);
+    }
+
+    int getBackgroundColor() {
+        return mBackgroundColor;
+    }
+
+    @Override
+    public void setBackgroundColor(int newColor) {
+        mBackgroundColor = newColor;
+        requestRender();
+    }
+
+    public void setZoomConstraints(ZoomConstraints constraints) {
+        mLayerClient.setZoomConstraints(constraints);
+    }
+
+    public void setIsRTL(boolean aIsRTL) {
+        mLayerClient.setIsRTL(aIsRTL);
+    }
+
+    public void setInputConnectionHandler(InputConnectionHandler inputConnectionHandler) {
+        mInputConnectionHandler = inputConnectionHandler;
+        mLayerClient.forceRedraw(null);
+    }
+
+    @Override
+    public Handler getHandler() {
+        if (mInputConnectionHandler != null)
+            return mInputConnectionHandler.getHandler(super.getHandler());
+        return super.getHandler();
+    }
+
+    @Override
+    public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
+        if (mInputConnectionHandler != null)
+            return mInputConnectionHandler.onCreateInputConnection(outAttrs);
+        return null;
+    }
+
+    @Override
+    public boolean onKeyPreIme(int keyCode, KeyEvent event) {
+        if (mInputConnectionHandler != null && mInputConnectionHandler.onKeyPreIme(keyCode, event)) {
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+	    Log.d("GeckoBrowser","28/3 onKeyDown");
+
+	    if (mPanZoomController != null && mPanZoomController.onKeyEvent(event)) {
+		    Log.d("GeckoBrowser","28/3 onKeyDown mPanZoomController");
+		    return true;
+        }
+        if (mInputConnectionHandler != null && mInputConnectionHandler.onKeyDown(keyCode, event)) {
+	        Log.d("GeckoBrowser","28/3 onKeyDown mInputConnectionHandler");
+	        return true;
+        }
+	    Log.d("GeckoBrowser","28/3 onKeyDown false");
+
+	    return false;
+    }
+
+    @Override
+    public boolean onKeyLongPress(int keyCode, KeyEvent event) {
+        if (mInputConnectionHandler != null && mInputConnectionHandler.onKeyLongPress(keyCode, event)) {
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event) {
+        if (mInputConnectionHandler != null && mInputConnectionHandler.onKeyMultiple(keyCode, repeatCount, event)) {
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean onKeyUp(int keyCode, KeyEvent event) {
+        if (mInputConnectionHandler != null && mInputConnectionHandler.onKeyUp(keyCode, event)) {
+            return true;
+        }
+        return false;
+    }
+
+    public boolean isIMEEnabled() {
+        if (mInputConnectionHandler != null) {
+            return mInputConnectionHandler.isIMEEnabled();
+        }
+        return false;
+    }
+
+    public void requestRender() {
+        if (mListener != null) {
+            mListener.renderRequested();
+        }
+    }
+
+    public void addLayer(Layer layer) {
+        mRenderer.addLayer(layer);
+    }
+
+    public void removeLayer(Layer layer) {
+        mRenderer.removeLayer(layer);
+    }
+
+    public void postRenderTask(RenderTask task) {
+        mRenderer.postRenderTask(task);
+    }
+
+    public void removeRenderTask(RenderTask task) {
+        mRenderer.removeRenderTask(task);
+    }
+
+    public int getMaxTextureSize() {
+        return mRenderer.getMaxTextureSize();
+    }
+
+    /** Used by robocop for testing purposes. Not for production use! */
+    @RobocopTarget
+    public IntBuffer getPixels() {
+        return mRenderer.getPixels();
+    }
+
+    /* paintState must be a PAINT_xxx constant. */
+    public void setPaintState(int paintState) {
+        mPaintState = paintState;
+    }
+
+    public int getPaintState() {
+        return mPaintState;
+    }
+
+    public LayerRenderer getRenderer() {
+        return mRenderer;
+    }
+
+    public void setListener(Listener listener) {
+        mListener = listener;
+    }
+
+    Listener getListener() {
+        return mListener;
+    }
+
+    public GLController getGLController() {
+        return mGLController;
+    }
+
+    private Bitmap getDrawable(String name) {
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inScaled = false;
+        Context context = getContext();
+        int resId = context.getResources().getIdentifier(name, "drawable", context.getPackageName());
+        return BitmapUtils.decodeResource(context, resId, options);
+    }
+
+    Bitmap getScrollbarImage() {
+        return getDrawable("scrollbar");
+    }
+
+    /* When using a SurfaceView (mSurfaceView != null), resizing happens in two
+     * phases. First, the LayerView changes size, then, often some frames later,
+     * the SurfaceView changes size. Because of this, we need to split the
+     * resize into two phases to avoid jittering.
+     *
+     * The first phase is the LayerView size change. mListener is notified so
+     * that a synchronous draw can be performed (otherwise a blank frame will
+     * appear).
+     *
+     * The second phase is the SurfaceView size change. At this point, the
+     * backing GL surface is resized and another synchronous draw is performed.
+     * Gecko is also sent the new window size, and this will likely cause an
+     * extra draw a few frames later, after it's re-rendered and caught up.
+     *
+     * In the case that there is no valid GL surface (for example, when
+     * resuming, or when coming back from the awesomescreen), or we're using a
+     * TextureView instead of a SurfaceView, the first phase is skipped.
+     */
+    private void onSizeChanged(int width, int height) {
+        if (!mGLController.isCompositorCreated()) {
+            return;
+        }
+
+        surfaceChanged(width, height);
+
+        if (mSurfaceView == null) {
+            return;
+        }
+
+        if (mListener != null) {
+            mListener.sizeChanged(width, height);
+        }
+
+        if (mOverscroll != null) {
+            mOverscroll.setSize(width, height);
+        }
+    }
+
+    private void surfaceChanged(int width, int height) {
+        mGLController.serverSurfaceChanged(width, height);
+
+        if (mListener != null) {
+            mListener.surfaceChanged(width, height);
+        }
+
+        if (mOverscroll != null) {
+            mOverscroll.setSize(width, height);
+        }
+    }
+
+    private void onDestroyed() {
+        mGLController.serverSurfaceDestroyed();
+    }
+
+    public Object getNativeWindow() {
+        if (mSurfaceView != null)
+            return mSurfaceView.getHolder();
+
+        return mTextureView.getSurfaceTexture();
+    }
+
+    @WrapElementForJNI(allowMultithread = true, stubName = "RegisterCompositorWrapper")
+    public static GLController registerCxxCompositor() {
+        try {
+            LayerView layerView = GeckoAppShell.getLayerView();
+            GLController controller = layerView.getGLController();
+            controller.compositorCreated();
+            return controller;
+        } catch (Exception e) {
+            Log.e(LOGTAG, "Error registering compositor!", e);
+            return null;
+        }
+    }
+
+    public interface Listener {
+        void renderRequested();
+        void sizeChanged(int width, int height);
+        void surfaceChanged(int width, int height);
+    }
+
+    private class SurfaceListener implements SurfaceHolder.Callback {
+        @Override
+        public void surfaceChanged(SurfaceHolder holder, int format, int width,
+                                                int height) {
+            onSizeChanged(width, height);
+        }
+
+        @Override
+        public void surfaceCreated(SurfaceHolder holder) {
+        }
+
+        @Override
+        public void surfaceDestroyed(SurfaceHolder holder) {
+            onDestroyed();
+        }
+    }
+
+    /* A subclass of SurfaceView to listen to layout changes, as
+     * View.OnLayoutChangeListener requires API level 11.
+     */
+    private class LayerSurfaceView extends SurfaceView {
+        LayerView mParent;
+
+        public LayerSurfaceView(Context aContext, LayerView aParent) {
+            super(aContext);
+            mParent = aParent;
+        }
+
+        @Override
+        protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+            if (changed) {
+                mParent.surfaceChanged(right - left, bottom - top);
+            }
+        }
+    }
+
+    private class SurfaceTextureListener implements TextureView.SurfaceTextureListener {
+        @Override
+        public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
+            // We don't do this for surfaceCreated above because it is always followed by a surfaceChanged,
+            // but that is not the case here.
+            onSizeChanged(width, height);
+        }
+
+        @Override
+        public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
+            onDestroyed();
+            return true; // allow Android to call release() on the SurfaceTexture, we are done drawing to it
+        }
+
+        @Override
+        public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
+            onSizeChanged(width, height);
+        }
+
+        @Override
+        public void onSurfaceTextureUpdated(SurfaceTexture surface) {
+
+        }
+    }
+
+    @Override
+    public void setOverScrollMode(int overscrollMode) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
+            super.setOverScrollMode(overscrollMode);
+        }
+        if (mPanZoomController != null) {
+            mPanZoomController.setOverScrollMode(overscrollMode);
+        }
+    }
+
+    @Override
+    public int getOverScrollMode() {
+        if (mPanZoomController != null) {
+            return mPanZoomController.getOverScrollMode();
+        }
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
+            return super.getOverScrollMode();
+        }
+        return View.OVER_SCROLL_ALWAYS;
+    }
+
+    @Override
+    public void onFocusChanged (boolean gainFocus, int direction, Rect previouslyFocusedRect) {
+        super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
+	    Log.d("GeckoBrowser","28/3 gainFocus"+gainFocus);
+        GeckoAccessibility.onLayerViewFocusChanged(this, gainFocus);
+    }
+
+    public void setFullScreen(boolean fullScreen) {
+        mFullScreen = fullScreen;
+    }
+
+    public boolean isFullScreen() {
+        return mFullScreen;
+    }
+
+    @Override
+    public void onTabChanged(Tab tab, Tabs.TabEvents msg, Object data) {
+        if (msg == Tabs.TabEvents.VIEWPORT_CHANGE && Tabs.getInstance().isSelectedTab(tab) && mLayerClient != null) {
+            setZoomConstraints(tab.getZoomConstraints());
+            setIsRTL(tab.getIsRTL());
+        }
+    }
+}
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/gfx/PluginLayer.java.orig
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/gfx/PluginLayer.java.orig	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,170 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.gecko.gfx;
+
+import android.util.Log;
+import org.mozilla.gecko.GeckoAppShell;
+import org.mozilla.gecko.util.FloatUtils;
+import org.mozilla.gecko.util.ThreadUtils;
+
+import android.graphics.PointF;
+import android.graphics.Rect;
+import android.graphics.RectF;
+import android.view.SurfaceView;
+import android.view.View;
+import android.widget.AbsoluteLayout;
+
+public class PluginLayer extends TileLayer {
+    private static final String LOGTAG = "PluginLayer";
+
+    private View mView;
+    private SurfaceView mSurfaceView;
+    private PluginLayoutParams mLayoutParams;
+    private AbsoluteLayout mContainer;
+
+    private boolean mDestroyed;
+    private boolean mViewVisible;
+
+    private RectF mLastViewport;
+    private float mLastZoomFactor;
+
+    private static final float TEXTURE_MAP[] = {
+                0.0f, 1.0f, // top left
+                0.0f, 0.0f, // bottom left
+                1.0f, 1.0f, // top right
+                1.0f, 0.0f, // bottom right
+    };
+
+    public PluginLayer(View view, RectF rect, int maxDimension) {
+        super(new BufferedCairoImage(null, 0, 0, 0), TileLayer.PaintMode.NORMAL);
+	    Log.w(LOGTAG, "Cuong PluginLayer");
+        mView = view;
+        mContainer = GeckoAppShell.getGeckoInterface().getPluginContainer();
+
+        mView.setWillNotDraw(false);
+        if (mView instanceof SurfaceView) {
+            mSurfaceView = (SurfaceView)view;
+            mSurfaceView.setZOrderOnTop(false);
+            mSurfaceView.setZOrderMediaOverlay(true);
+        }
+
+        mLayoutParams = new PluginLayoutParams(rect, maxDimension);
+    }
+
+    public void setVisible(boolean visible) {
+        if (visible) {
+            showView();
+        } else {
+            hideView();
+        }
+    }
+
+    private void hideView() {
+        if (mViewVisible) {
+            ThreadUtils.postToUiThread(new Runnable() {
+                @Override
+                public void run() {
+                    mView.setVisibility(View.GONE);
+                    mViewVisible = false;
+                }
+            });
+        }
+    }
+
+    public void showView() {
+        ThreadUtils.postToUiThread(new Runnable() {
+            @Override
+            public void run() {
+                if (mContainer.indexOfChild(mView) < 0) {
+                    mContainer.addView(mView, mLayoutParams);
+                } else {
+                    mContainer.updateViewLayout(mView, mLayoutParams);
+                    mView.setVisibility(View.VISIBLE);
+                }
+                mViewVisible = true;
+            }
+        });
+    }
+
+    @Override
+    public void destroy() {
+        mDestroyed = true;
+
+        mContainer.removeView(mView);
+    }
+
+    public void reset(RectF rect) {
+        mLayoutParams.reset(rect);
+    }
+
+    @Override
+    protected void performUpdates(RenderContext context) {
+        if (mDestroyed)
+            return;
+
+        if (!RectUtils.fuzzyEquals(context.viewport, mLastViewport) ||
+            !FloatUtils.fuzzyEquals(context.zoomFactor, mLastZoomFactor)) {
+
+            mLastZoomFactor = context.zoomFactor;
+            mLastViewport = context.viewport;
+            mLayoutParams.reposition(context.viewport, context.offset, context.zoomFactor);
+
+            showView();
+        }
+    }
+
+    @Override
+    public void draw(RenderContext context) {
+    }
+
+    class PluginLayoutParams extends AbsoluteLayout.LayoutParams
+    {
+        private static final String LOGTAG = "GeckoApp.PluginLayoutParams";
+
+        private RectF mRect;
+        private int mMaxDimension;
+        private float mLastResolution;
+
+        public PluginLayoutParams(RectF rect, int maxDimension) {
+            super(0, 0, 0, 0);
+
+            mMaxDimension = maxDimension;
+            reset(rect);
+        }
+
+        private void clampToMaxSize() {
+            if (width > mMaxDimension || height > mMaxDimension) {
+                if (width > height) {
+                    height = Math.round(((float)height/(float)width) * mMaxDimension);
+                    width = mMaxDimension;
+                } else {
+                    width = Math.round(((float)width/(float)height) * mMaxDimension);
+                    height = mMaxDimension;
+                }
+            }
+        }
+
+        public void reset(RectF rect) {
+            mRect = rect;
+        }
+
+        public void reposition(RectF viewport, PointF offset, float zoomFactor) {
+
+            RectF scaled = RectUtils.scale(mRect, zoomFactor);
+            scaled.offset(offset.x, offset.y);
+
+            this.x = Math.round(scaled.left - viewport.left);
+            this.y = Math.round(scaled.top - viewport.top);
+
+            if (!FloatUtils.fuzzyEquals(mLastResolution, zoomFactor)) {
+                width = Math.round(mRect.width() * zoomFactor);
+                height = Math.round(mRect.height() * zoomFactor);
+                mLastResolution = zoomFactor;
+
+                clampToMaxSize();
+            }
+        }
+    }
+}
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/gfx/ScrollbarLayer.java
--- a/mobile/android/base/gfx/ScrollbarLayer.java	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/gfx/ScrollbarLayer.java	Mon Mar 31 16:57:28 2014 +0700
@@ -197,7 +197,9 @@
         FloatBuffer coordBuffer = context.coordBuffer;
         int positionHandle = mPositionHandle;
         int textureHandle = mTextureHandle;
-
+	     if(coordBuffer==null){
+		     return;
+	     }
         // Make sure we are at position zero in the buffer in case other draw methods did not
         // clean up after themselves
         coordBuffer.position(0);
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/gfx/SimpleScaleGestureDetector.java.orig
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/gfx/SimpleScaleGestureDetector.java.orig	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,324 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.gecko.gfx;
+
+import org.json.JSONException;
+
+import android.graphics.PointF;
+import android.util.Log;
+import android.view.MotionEvent;
+
+import java.util.LinkedList;
+import java.util.ListIterator;
+import java.util.Stack;
+
+/**
+ * A less buggy, and smoother, replacement for the built-in Android ScaleGestureDetector.
+ *
+ * This gesture detector is more reliable than the built-in ScaleGestureDetector because:
+ *
+ *   - It doesn't assume that pointer IDs are numbered 0 and 1.
+ *
+ *   - It doesn't attempt to correct for "slop" when resting one's hand on the device. On some
+ *     devices (e.g. the Droid X) this can cause the ScaleGestureDetector to lose track of how many
+ *     pointers are down, with disastrous results (bug 706684).
+ *
+ *   - Cancelling a zoom into a pan is handled correctly.
+ *
+ *   - Starting with three or more fingers down, releasing fingers so that only two are down, and
+ *     then performing a scale gesture is handled correctly.
+ *
+ *   - It doesn't take pressure into account, which results in smoother scaling.
+ */
+class SimpleScaleGestureDetector {
+    private static final String LOGTAG = "GeckoSimpleScaleGestureDetector";
+
+    private SimpleScaleGestureListener mListener;
+    private long mLastEventTime;
+    private boolean mScaleResult;
+
+    /* Information about all pointers that are down. */
+    private LinkedList<PointerInfo> mPointerInfo;
+
+    /** Creates a new gesture detector with the given listener. */
+    SimpleScaleGestureDetector(SimpleScaleGestureListener listener) {
+        mListener = listener;
+        mPointerInfo = new LinkedList<PointerInfo>();
+    }
+
+    /** Forward touch events to this function. */
+    public void onTouchEvent(MotionEvent event) {
+	    Log.d("GeckoBrowser","SimpleScaleGestureDetector TouchEventHandler onTouchEvent  "+(event.getAction() & MotionEvent.ACTION_MASK));
+
+	    switch (event.getAction() & MotionEvent.ACTION_MASK) {
+        case MotionEvent.ACTION_DOWN:
+            // If we get ACTION_DOWN while still tracking any pointers,
+            // something is wrong.  Cancel the current gesture and start over.
+            if (getPointersDown() > 0)
+                onTouchEnd(event);
+            onTouchStart(event);
+            break;
+        case MotionEvent.ACTION_POINTER_DOWN:
+            onTouchStart(event);
+            break;
+        case MotionEvent.ACTION_MOVE:
+            onTouchMove(event);
+            break;
+        case MotionEvent.ACTION_POINTER_UP:
+        case MotionEvent.ACTION_UP:
+        case MotionEvent.ACTION_CANCEL:
+            onTouchEnd(event);
+            break;
+        }
+    }
+
+    private int getPointersDown() {
+        return mPointerInfo.size();
+    }
+
+    private int getActionIndex(MotionEvent event) {
+        return (event.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK)
+            >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
+    }
+
+    private void onTouchStart(MotionEvent event) {
+        mLastEventTime = event.getEventTime();
+        mPointerInfo.addFirst(PointerInfo.create(event, getActionIndex(event)));
+        if (getPointersDown() == 2) {
+            sendScaleGesture(EventType.BEGIN);
+        }
+    }
+
+    private void onTouchMove(MotionEvent event) {
+        mLastEventTime = event.getEventTime();
+        for (int i = 0; i < event.getPointerCount(); i++) {
+            PointerInfo pointerInfo = pointerInfoForEventIndex(event, i);
+            if (pointerInfo != null) {
+                pointerInfo.populate(event, i);
+            }
+        }
+
+        if (getPointersDown() == 2) {
+            sendScaleGesture(EventType.CONTINUE);
+        }
+    }
+
+    private void onTouchEnd(MotionEvent event) {
+        mLastEventTime = event.getEventTime();
+
+        int action = event.getAction() & MotionEvent.ACTION_MASK;
+        boolean isCancel = (action == MotionEvent.ACTION_CANCEL ||
+                            action == MotionEvent.ACTION_DOWN);
+
+        int id = event.getPointerId(getActionIndex(event));
+        ListIterator<PointerInfo> iterator = mPointerInfo.listIterator();
+        while (iterator.hasNext()) {
+            PointerInfo pointerInfo = iterator.next();
+            if (!(isCancel || pointerInfo.getId() == id)) {
+                continue;
+            }
+
+            // One of the pointers we were tracking was lifted. Remove its info object from the
+            // list, recycle it to avoid GC pauses, and send an onScaleEnd() notification if this
+            // ended the gesture.
+            iterator.remove();
+            pointerInfo.recycle();
+            if (getPointersDown() == 1) {
+                sendScaleGesture(EventType.END);
+            }
+        }
+    }
+
+    /**
+     * Returns the X coordinate of the focus location (the midpoint of the two fingers). If only
+     * one finger is down, returns the location of that finger.
+     */
+    public float getFocusX() {
+        switch (getPointersDown()) {
+        case 1:
+            return mPointerInfo.getFirst().getCurrent().x;
+        case 2:
+            PointerInfo pointerA = mPointerInfo.getFirst(), pointerB = mPointerInfo.getLast();
+            return (pointerA.getCurrent().x + pointerB.getCurrent().x) / 2.0f;
+        }
+
+        Log.e(LOGTAG, "No gesture taking place in getFocusX()!");
+        return 0.0f;
+    }
+
+    /**
+     * Returns the Y coordinate of the focus location (the midpoint of the two fingers). If only
+     * one finger is down, returns the location of that finger.
+     */
+    public float getFocusY() {
+        switch (getPointersDown()) {
+        case 1:
+            return mPointerInfo.getFirst().getCurrent().y;
+        case 2:
+            PointerInfo pointerA = mPointerInfo.getFirst(), pointerB = mPointerInfo.getLast();
+            return (pointerA.getCurrent().y + pointerB.getCurrent().y) / 2.0f;
+        }
+
+        Log.e(LOGTAG, "No gesture taking place in getFocusY()!");
+        return 0.0f;
+    }
+
+    /** Returns the most recent distance between the two pointers. */
+    public float getCurrentSpan() {
+        if (getPointersDown() != 2) {
+            Log.e(LOGTAG, "No gesture taking place in getCurrentSpan()!");
+            return 0.0f;
+        }
+
+        PointerInfo pointerA = mPointerInfo.getFirst(), pointerB = mPointerInfo.getLast();
+        return PointUtils.distance(pointerA.getCurrent(), pointerB.getCurrent());
+    }
+
+    /** Returns the second most recent distance between the two pointers. */
+    public float getPreviousSpan() {
+        if (getPointersDown() != 2) {
+            Log.e(LOGTAG, "No gesture taking place in getPreviousSpan()!");
+            return 0.0f;
+        }
+
+        PointerInfo pointerA = mPointerInfo.getFirst(), pointerB = mPointerInfo.getLast();
+        PointF a = pointerA.getPrevious(), b = pointerB.getPrevious();
+        if (a == null || b == null) {
+            a = pointerA.getCurrent();
+            b = pointerB.getCurrent();
+        }
+
+        return PointUtils.distance(a, b);
+    }
+
+    /** Returns the time of the last event related to the gesture. */
+    public long getEventTime() {
+        return mLastEventTime;
+    }
+
+    /** Returns true if the scale gesture is in progress and false otherwise. */
+    public boolean isInProgress() {
+        return getPointersDown() == 2;
+    }
+
+    /* Sends the requested scale gesture notification to the listener. */
+    private void sendScaleGesture(EventType eventType) {
+        switch (eventType) {
+        case BEGIN:
+            mScaleResult = mListener.onScaleBegin(this);
+            break;
+        case CONTINUE:
+            if (mScaleResult) {
+                mListener.onScale(this);
+            }
+            break;
+        case END:
+            if (mScaleResult) {
+                mListener.onScaleEnd(this);
+            }
+            break;
+        }
+    }
+
+    /*
+     * Returns the pointer info corresponding to the given pointer index, or null if the pointer
+     * isn't one that's being tracked.
+     */
+    private PointerInfo pointerInfoForEventIndex(MotionEvent event, int index) {
+        int id = event.getPointerId(index);
+        for (PointerInfo pointerInfo : mPointerInfo) {
+            if (pointerInfo.getId() == id) {
+                return pointerInfo;
+            }
+        }
+        return null;
+    }
+
+    private enum EventType {
+        BEGIN,
+        CONTINUE,
+        END,
+    }
+
+    /* Encapsulates information about one of the two fingers involved in the gesture. */
+    private static class PointerInfo {
+        /* A free list that recycles pointer info objects, to reduce GC pauses. */
+        private static Stack<PointerInfo> sPointerInfoFreeList;
+
+        private int mId;
+        private PointF mCurrent, mPrevious;
+
+        private PointerInfo() {
+            // External users should use create() instead.
+        }
+
+        /* Creates or recycles a new PointerInfo instance from an event and a pointer index. */
+        public static PointerInfo create(MotionEvent event, int index) {
+            if (sPointerInfoFreeList == null) {
+                sPointerInfoFreeList = new Stack<PointerInfo>();
+            }
+
+            PointerInfo pointerInfo;
+            if (sPointerInfoFreeList.empty()) {
+                pointerInfo = new PointerInfo();
+            } else {
+                pointerInfo = sPointerInfoFreeList.pop();
+            }
+
+            pointerInfo.populate(event, index);
+            return pointerInfo;
+        }
+
+        /*
+         * Fills in the fields of this instance from the given motion event and pointer index
+         * within that event.
+         */
+        public void populate(MotionEvent event, int index) {
+            mId = event.getPointerId(index);
+            mPrevious = mCurrent;
+            mCurrent = new PointF(event.getX(index), event.getY(index));
+        }
+
+        public void recycle() {
+            mId = -1;
+            mPrevious = mCurrent = null;
+            sPointerInfoFreeList.push(this);
+        }
+
+        public int getId() { return mId; }
+        public PointF getCurrent() { return mCurrent; }
+        public PointF getPrevious() { return mPrevious; }
+
+        @Override
+        public String toString() {
+            if (mId == -1) {
+                return "(up)";
+            }
+
+            try {
+                String prevString;
+                if (mPrevious == null) {
+                    prevString = "n/a";
+                } else {
+                    prevString = PointUtils.toJSON(mPrevious).toString();
+                }
+
+                // The current position should always be non-null.
+                String currentString = PointUtils.toJSON(mCurrent).toString();
+                return "id=" + mId + " cur=" + currentString + " prev=" + prevString;
+            } catch (JSONException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    public static interface SimpleScaleGestureListener {
+        public boolean onScale(SimpleScaleGestureDetector detector);
+        public boolean onScaleBegin(SimpleScaleGestureDetector detector);
+        public void onScaleEnd(SimpleScaleGestureDetector detector);
+    }
+}
+
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/gfx/TouchEventHandler.java.orig
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/gfx/TouchEventHandler.java.orig	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,323 @@
+/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+package org.mozilla.gecko.gfx;
+
+import org.mozilla.gecko.Tab;
+import org.mozilla.gecko.Tabs;
+
+import android.content.Context;
+import android.os.SystemClock;
+import android.util.Log;
+import android.view.GestureDetector;
+import android.view.MotionEvent;
+import android.view.View;
+
+import java.util.LinkedList;
+import java.util.Queue;
+
+/**
+ * This class handles incoming touch events from the user and sends them to
+ * listeners in Gecko and/or performs the "default action" (asynchronous pan/zoom
+ * behaviour. EVERYTHING IN THIS CLASS MUST RUN ON THE UI THREAD.
+ *
+ * In the following code/comments, a "block" of events refers to a contiguous
+ * sequence of events that starts with a DOWN or POINTER_DOWN and goes up to
+ * but not including the next DOWN or POINTER_DOWN event.
+ *
+ * "Dispatching" an event refers to performing the default actions for the event,
+ * which at our level of abstraction just means sending it off to the gesture
+ * detectors and the pan/zoom controller.
+ *
+ * If an event is "default-prevented" that means one or more listeners in Gecko
+ * has called preventDefault() on the event, which means that the default action
+ * for that event should not occur. Usually we care about a "block" of events being
+ * default-prevented, which means that the DOWN/POINTER_DOWN event that started
+ * the block, or the first MOVE event following that, were prevent-defaulted.
+ *
+ * A "default-prevented notification" is when we here in Java-land receive a notification
+ * from gecko as to whether or not a block of events was default-prevented. This happens
+ * at some point after the first or second event in the block is processed in Gecko.
+ * This code assumes we get EXACTLY ONE default-prevented notification for each block
+ * of events.
+ *
+ * Note that even if all events are default-prevented, we still send specific types
+ * of notifications to the pan/zoom controller. The notifications are needed
+ * to respond to user actions a timely manner regardless of default-prevention,
+ * and fix issues like bug 749384.
+ */
+final class TouchEventHandler implements Tabs.OnTabsChangedListener {
+    private static final String LOGTAG = "GeckoTouchEventHandler";
+
+    // The time limit for listeners to respond with preventDefault on touchevents
+    // before we begin panning the page
+    private final int EVENT_LISTENER_TIMEOUT = 200;
+
+    private final View mView;
+    private final GestureDetector mGestureDetector;
+    private final SimpleScaleGestureDetector mScaleGestureDetector;
+    private final JavaPanZoomController mPanZoomController;
+
+    // the queue of events that we are holding on to while waiting for a preventDefault
+    // notification
+    private final Queue<MotionEvent> mEventQueue;
+    private final ListenerTimeoutProcessor mListenerTimeoutProcessor;
+
+    // whether or not we should wait for touch listeners to respond (this state is
+    // per-tab and is updated when we switch tabs).
+    private boolean mWaitForTouchListeners;
+
+    // true if we should hold incoming events in our queue. this is re-set for every
+    // block of events, this is cleared once we find out if the block has been
+    // default-prevented or not (or we time out waiting for that).
+    private boolean mHoldInQueue;
+
+    // false if the current event block has been default-prevented. In this case,
+    // we still pass the event to both Gecko and the pan/zoom controller, but the
+    // latter will not use it to scroll content. It may still use the events for
+    // other things, such as making the dynamic toolbar visible.
+    private boolean mAllowDefaultAction;
+
+    // this next variable requires some explanation. strap yourself in.
+    //
+    // for each block of events, we do two things: (1) send the events to gecko and expect
+    // exactly one default-prevented notification in return, and (2) kick off a delayed
+    // ListenerTimeoutProcessor that triggers in case we don't hear from the listener in
+    // a timely fashion.
+    // since events are constantly coming in, we need to be able to handle more than one
+    // block of events in the queue.
+    //
+    // this means that there are ordering restrictions on these that we can take advantage of,
+    // and need to abide by. blocks of events in the queue will always be in the order that
+    // the user generated them. default-prevented notifications we get from gecko will be in
+    // the same order as the blocks of events in the queue. the ListenerTimeoutProcessors that
+    // have been posted will also fire in the same order as the blocks of events in the queue.
+    // HOWEVER, we may get multiple default-prevented notifications interleaved with multiple
+    // ListenerTimeoutProcessor firings, and that interleaving is not predictable.
+    //
+    // therefore, we need to make sure that for each block of events, we process the queued
+    // events exactly once, either when we get the default-prevented notification, or when the
+    // timeout expires (whichever happens first). there is no way to associate the
+    // default-prevented notification with a particular block of events other than via ordering,
+    //
+    // so what we do to accomplish this is to track a "processing balance", which is the number
+    // of default-prevented notifications that we have received, minus the number of ListenerTimeoutProcessors
+    // that have fired. (think "balance" as in teeter-totter balance). this value is:
+    // - zero when we are in a state where the next default-prevented notification we expect
+    //   to receive and the next ListenerTimeoutProcessor we expect to fire both correspond to
+    //   the next block of events in the queue.
+    // - positive when we are in a state where we have received more default-prevented notifications
+    //   than ListenerTimeoutProcessors. This means that the next default-prevented notification
+    //   does correspond to the block at the head of the queue, but the next n ListenerTimeoutProcessors
+    //   need to be ignored as they are for blocks we have already processed. (n is the absolute value
+    //   of the balance.)
+    // - negative when we are in a state where we have received more ListenerTimeoutProcessors than
+    //   default-prevented notifications. This means that the next ListenerTimeoutProcessor that
+    //   we receive does correspond to the block at the head of the queue, but the next n
+    //   default-prevented notifications need to be ignored as they are for blocks we have already
+    //   processed. (n is the absolute value of the balance.)
+    private int mProcessingBalance;
+
+    TouchEventHandler(Context context, View view, JavaPanZoomController panZoomController) {
+        mView = view;
+
+        mEventQueue = new LinkedList<MotionEvent>();
+        mPanZoomController = panZoomController;
+        mGestureDetector = new GestureDetector(context, mPanZoomController);
+        mScaleGestureDetector = new SimpleScaleGestureDetector(mPanZoomController);
+        mListenerTimeoutProcessor = new ListenerTimeoutProcessor();
+        mAllowDefaultAction = true;
+
+        mGestureDetector.setOnDoubleTapListener(mPanZoomController);
+
+        Tabs.registerOnTabsChangedListener(this);
+    }
+
+    public void destroy() {
+        Tabs.unregisterOnTabsChangedListener(this);
+    }
+
+    /* This function MUST be called on the UI thread */
+    public boolean handleEvent(MotionEvent event) {
+
+	    if (isDownEvent(event)) {
+		    Log.d("GeckoBrowser","TouchEventHandler handleEvent isDownEvent(event) "+event+":"+mWaitForTouchListeners);
+
+		    // this is the start of a new block of events! whee!
+            mHoldInQueue = mWaitForTouchListeners;
+
+            // Set mAllowDefaultAction to true so that in the event we dispatch events, the
+            // PanZoomController doesn't treat them as if they've been prevent-defaulted
+            // when they haven't.
+            mAllowDefaultAction = true;
+            if (mHoldInQueue) {
+                // if the new block we are starting is the current block (i.e. there are no
+                // other blocks waiting in the queue, then we should let the pan/zoom controller
+                // know we are waiting for the touch listeners to run
+                if (mEventQueue.isEmpty()) {
+                    mPanZoomController.startingNewEventBlock(event, true);
+                }
+            } else {
+                // we're not going to be holding this block of events in the queue, but we need
+                // a marker of some sort so that the processEventBlock loop deals with the blocks
+                // in the right order as notifications come in. we use a single null event in
+                // the queue as a placeholder for a block of events that has already been dispatched.
+                mEventQueue.add(null);
+                mPanZoomController.startingNewEventBlock(event, false);
+            }
+
+            // set the timeout so that we dispatch these events and update mProcessingBalance
+            // if we don't get a default-prevented notification
+            mView.postDelayed(mListenerTimeoutProcessor, EVENT_LISTENER_TIMEOUT);
+        }
+	    Log.d("GeckoBrowser","TouchEventHandler handleEvent mHoldInQueue "+mHoldInQueue);
+
+	    // if we need to hold the events, add it to the queue, otherwise dispatch
+        // it directly.
+        if (mHoldInQueue) {
+            mEventQueue.add(MotionEvent.obtain(event));
+        } else {
+            dispatchEvent(event, mAllowDefaultAction);
+        }
+
+        return false;
+    }
+
+    /**
+     * This function is how gecko sends us a default-prevented notification. It is called
+     * once gecko knows definitively whether the block of events has had preventDefault
+     * called on it (either on the initial down event that starts the block, or on
+     * the first event following that down event).
+     *
+     * This function MUST be called on the UI thread.
+     */
+    public void handleEventListenerAction(boolean allowDefaultAction) {
+        if (mProcessingBalance > 0) {
+            // this event listener that triggered this took too long, and the corresponding
+            // ListenerTimeoutProcessor runnable already ran for the event in question. the
+            // block of events this is for has already been processed, so we don't need to
+            // do anything here.
+        } else {
+            processEventBlock(allowDefaultAction);
+        }
+        mProcessingBalance--;
+    }
+
+    /* This function MUST be called on the UI thread. */
+    public void setWaitForTouchListeners(boolean aValue) {
+        mWaitForTouchListeners = aValue;
+    }
+
+    private boolean isDownEvent(MotionEvent event) {
+        int action = (event.getAction() & MotionEvent.ACTION_MASK);
+        return (action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN);
+    }
+
+    private boolean touchFinished(MotionEvent event) {
+	    int action = (event.getAction() & MotionEvent.ACTION_MASK);
+	    Log.d("GeckoBrowser","TouchEventHandler touchFinished "+(action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL));
+	    return (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL);
+    }
+
+    /**
+     * Dispatch the event to the gesture detectors and the pan/zoom controller.
+     */
+    private void dispatchEvent(MotionEvent event, boolean allowDefaultAction) {
+	    Log.d("GeckoBrowser","TouchEventHandler dispatchEvent "+allowDefaultAction);
+
+	    if (allowDefaultAction) {
+            if (mGestureDetector.onTouchEvent(event)) {
+	            Log.d("GeckoBrowser","TouchEventHandler dispatchEvent mGestureDetector.onTouchEvent(event) ");
+	            return;
+            }
+            mScaleGestureDetector.onTouchEvent(event);
+            if (mScaleGestureDetector.isInProgress()) {
+                return;
+            }
+        }
+        mPanZoomController.handleEvent(event, !allowDefaultAction);
+    }
+
+    /**
+     * Process the block of events at the head of the queue now that we know
+     * whether it has been default-prevented or not.
+     */
+    private void processEventBlock(boolean allowDefaultAction) {
+	    Log.d("GeckoBrowser","TouchEventHandler processEventBlock "+mEventQueue.size()+": allowedDefaultAction "+allowDefaultAction);
+
+	    if (mEventQueue.isEmpty()) {
+            Log.e(LOGTAG, "Unexpected empty event queue in processEventBlock!", new Exception());
+            return;
+        }
+
+        // the odd loop condition is because the first event in the queue will
+        // always be a DOWN or POINTER_DOWN event, and we want to process all
+        // the events in the queue starting at that one, up to but not including
+        // the next DOWN or POINTER_DOWN event.
+
+        MotionEvent event = mEventQueue.poll();
+	    Log.d("GeckoBrowser","TouchEventHandler processEventBlock polling  "+event);
+
+	    while (true) {
+            // event being null here is valid and represents a block of events
+            // that has already been dispatched.
+		    Log.d("GeckoBrowser","TouchEventHandler inside while mEventQueue ="+mEventQueue.size());
+
+		    if (event != null) {
+                dispatchEvent(event, allowDefaultAction);
+            }
+            if (mEventQueue.isEmpty()) {
+                // we have processed the backlog of events, and are all caught up.
+                // now we can set clear the hold flag and set the dispatch flag so
+                // that the handleEvent() function can do the right thing for all
+                // remaining events in this block (which is still ongoing) without
+                // having to put them in the queue.
+                mHoldInQueue = false;
+                mAllowDefaultAction = allowDefaultAction;
+                break;
+            }
+            event = mEventQueue.peek();
+		    Log.d("GeckoBrowser","TouchEventHandler inside while peek event ="+event);
+
+		    if (event == null || isDownEvent(event)) {
+                // we have finished processing the block we were interested in.
+                // now we wait for the next call to processEventBlock
+                if (event != null) {
+	                mPanZoomController.startingNewEventBlock(event, true);
+                }
+			    Log.d("GeckoBrowser","TouchEventHandler inside while isDownEvent peek event ="+event);
+
+			    break;
+            }
+            // pop the event we peeked above, as it is still part of the block and
+            // we want to keep processing
+            mEventQueue.remove();
+        }
+    }
+
+    private class ListenerTimeoutProcessor implements Runnable {
+        /* This MUST be run on the UI thread */
+        @Override
+        public void run() {
+            if (mProcessingBalance < 0) {
+                // gecko already responded with default-prevented notification, and so
+                // the block of events this ListenerTimeoutProcessor corresponds to have
+                // already been removed from the queue.
+            } else {
+                processEventBlock(true);
+            }
+            mProcessingBalance++;
+        }
+    }
+
+    // Tabs.OnTabsChangedListener implementation
+
+    @Override
+    public void onTabChanged(Tab tab, Tabs.TabEvents msg, Object data) {
+        if ((Tabs.getInstance().isSelectedTab(tab) && msg == Tabs.TabEvents.STOP) || msg == Tabs.TabEvents.SELECTED) {
+            mWaitForTouchListeners = tab.getHasTouchListeners();
+        }
+    }
+}
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/moz.build~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/mobile/android/base/moz.build~	Mon Mar 31 16:57:28 2014 +0700
@@ -0,0 +1,574 @@
+# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+DIRS += ['locales']
+SPHINX_TREES['fennec'] = 'docs'
+
+include('android-services.mozbuild')
+
+thirdparty_source_dir = TOPSRCDIR + '/mobile/android/thirdparty/'
+
+resjar = add_java_jar('gecko-R')
+resjar.sources = []
+resjar.generated_sources += [
+    'org/mozilla/gecko/R.java',
+]
+resjar.javac_flags += ['-Xlint:all']
+
+mgjar = add_java_jar('gecko-mozglue')
+mgjar.sources += [
+    'mozglue/ByteBufferInputStream.java',
+    'mozglue/DirectBufferAllocator.java',
+    'mozglue/generatorannotations/GeneratorOptions.java',
+    'mozglue/generatorannotations/OptionalGeneratedParameter.java',
+    'mozglue/generatorannotations/WrapElementForJNI.java',
+    'mozglue/generatorannotations/WrapEntireClassForJNI.java',
+    'mozglue/JNITarget.java',
+    'mozglue/NativeReference.java',
+    'mozglue/NativeZip.java',
+    'mozglue/RobocopTarget.java',
+    'mozglue/WebRTCJNITarget.java',
+]
+mgjar.generated_sources += [
+    'org/mozilla/gecko/mozglue/GeckoLoader.java',
+]
+mgjar.javac_flags += ['-Xlint:all']
+
+wsjar = add_java_jar('websockets')
+wsjar.sources += [ thirdparty_source_dir + f for f in [
+    'com/codebutler/android_websockets/HybiParser.java',
+    'com/codebutler/android_websockets/WebSocketClient.java',
+] ]
+wsjar.javac_flags += ['-Xlint:all,-serial']
+
+gujar = add_java_jar('gecko-util')
+gujar.sources += [
+    'util/ActivityResultHandler.java',
+    'util/ActivityResultHandlerMap.java',
+    'util/Clipboard.java',
+    'util/FileUtils.java',
+    'util/FloatUtils.java',
+    'util/GamepadUtils.java',
+    'util/GeckoBackgroundThread.java',
+    'util/GeckoEventListener.java',
+    'util/GeckoJarReader.java',
+    'util/HardwareUtils.java',
+    'util/INIParser.java',
+    'util/INISection.java',
+    'util/JSONUtils.java',
+    'util/MenuUtils.java',
+    'util/NonEvictingLruCache.java',
+    'util/ProxySelector.java',
+    'util/StringUtils.java',
+    'util/ThreadUtils.java',
+    'util/UiAsyncTask.java',
+]
+gujar.extra_jars = [
+    'gecko-mozglue.jar'
+]
+gujar.javac_flags += ['-Xlint:all,-deprecation']
+
+stjar = add_java_jar('sync-thirdparty')
+stjar.sources += [ thirdparty_source_dir + f for f in sync_thirdparty_java_files ]
+stjar.javac_flags = ['-Xlint:none']
+
+if CONFIG['MOZ_WEBRTC']:
+    video_root = TOPSRCDIR + '/media/webrtc/trunk/webrtc/modules/video_capture/android/java/src/org/webrtc/videoengine/'
+    audio_root = TOPSRCDIR + '/media/webrtc/trunk/webrtc/modules/audio_device/android/java/src/org/webrtc/voiceengine/'
+    wrjar = add_java_jar('webrtc')
+    wrjar.sources += [
+        video_root + 'CaptureCapabilityAndroid.java',
+        video_root + 'VideoCaptureAndroid.java',
+        video_root + 'VideoCaptureDeviceInfoAndroid.java',
+    ]
+    wrjar.sources += [
+        audio_root + 'AudioManagerAndroid.java',
+        audio_root + 'WebRTCAudioDevice.java',
+    ]
+    wrjar.extra_jars = [
+        'gecko-R.jar',
+        'gecko-browser.jar',
+        'gecko-util.jar',
+        'gecko-mozglue.jar',
+    ]
+    wrjar.javac_flags += ['-Xlint:all,-deprecation,-cast']
+
+gbjar = add_java_jar('gecko-browser')
+gbjar.sources += [
+    'AboutPages.java',
+    'ActionModeCompat.java',
+    'ActionModeCompatView.java',
+    'ActivityHandlerHelper.java',
+    'AlertNotification.java',
+    'animation/AnimationUtils.java',
+    'animation/AnimatorProxy.java',
+    'animation/HeightChangeAnimation.java',
+    'animation/PropertyAnimator.java',
+    'animation/Rotate3DAnimation.java',
+    'animation/ViewHelper.java',
+    'ANRReporter.java',
+    'AppNotificationClient.java',
+    'BaseGeckoInterface.java',
+    'BrowserApp.java',
+    'ContactService.java',
+    'ContextGetter.java',
+    'CustomEditText.java',
+    'DataReportingNotification.java',
+    'db/BrowserContract.java',
+    'db/BrowserDatabaseHelper.java',
+    'db/BrowserDB.java',
+    'db/BrowserProvider.java',
+    'db/DBUtils.java',
+    'db/FormHistoryProvider.java',
+    'db/HomeProvider.java',
+    'db/LocalBrowserDB.java',
+    'db/PasswordsProvider.java',
+    'db/PerProfileDatabases.java',
+    'db/ReadingListProvider.java',
+    'db/SQLiteBridgeContentProvider.java',
+    'db/TabsProvider.java',
+    'db/TransactionalProvider.java',
+    'Distribution.java',
+    'DoorHangerPopup.java',
+    'DynamicToolbar.java',
+    'EditBookmarkDialog.java',
+    'EventDispatcher.java',
+    'favicons/cache/FaviconCache.java',
+    'favicons/cache/FaviconCacheElement.java',
+    'favicons/cache/FaviconsForURL.java',
+    'favicons/decoders/FaviconDecoder.java',
+    'favicons/decoders/ICODecoder.java',
+    'favicons/decoders/IconDirectoryEntry.java',
+    'favicons/decoders/LoadFaviconResult.java',
+    'favicons/Favicons.java',
+    'favicons/LoadFaviconTask.java',
+    'favicons/OnFaviconLoadedListener.java',
+    'FilePicker.java',
+    'FilePickerResultHandler.java',
+    'FindInPageBar.java',
+    'FlashKid.java',
+    'FormAssistPopup.java',
+    'GeckoAccessibility.java',
+    'GeckoActivity.java',
+    'GeckoActivityStatus.java',
+    'GeckoApp.java',
+    'GeckoApplication.java',
+    'GeckoAppShell.java',
+    'GeckoBatteryManager.java',
+    'GeckoConnectivityReceiver.java',
+    'GeckoEditable.java',
+    'GeckoEvent.java',
+    'GeckoHalDefines.java',
+    'GeckoInputConnection.java',
+    'GeckoJavaSampler.java',
+    'GeckoMessageReceiver.java',
+    'GeckoNetworkManager.java',
+    'GeckoProfile.java',
+    'GeckoProfileDirectories.java',
+    'GeckoProfilesProvider.java',
+    'GeckoScreenOrientation.java',
+    'GeckoSmsManager.java',
+    'GeckoThread.java',
+    'GeckoUpdateReceiver.java',
+    'GeckoView.java',
+    'GeckoViewChrome.java',
+    'GeckoViewContent.java',
+    'gfx/Axis.java',
+    'gfx/BitmapUtils.java',
+    'gfx/BufferedCairoImage.java',
+    'gfx/CairoGLInfo.java',
+    'gfx/CairoImage.java',
+    'gfx/CairoUtils.java',
+    'gfx/DisplayPortCalculator.java',
+    'gfx/DisplayPortMetrics.java',
+    'gfx/DrawTimingQueue.java',
+    'gfx/FloatSize.java',
+    'gfx/GeckoLayerClient.java',
+    'gfx/GLController.java',
+    'gfx/ImmutableViewportMetrics.java',
+    'gfx/InputConnectionHandler.java',
+    'gfx/IntSize.java',
+    'gfx/JavaPanZoomController.java',
+    'gfx/Layer.java',
+    'gfx/LayerMarginsAnimator.java',
+    'gfx/LayerRenderer.java',
+    'gfx/LayerView.java',
+    'gfx/NativePanZoomController.java',
+    'gfx/NinePatchTileLayer.java',
+    'gfx/Overscroll.java',
+    'gfx/OverscrollEdgeEffect.java',
+    'gfx/PanningPerfAPI.java',
+    'gfx/PanZoomController.java',
+    'gfx/PanZoomTarget.java',
+    'gfx/PluginLayer.java',
+    'gfx/PointUtils.java',
+    'gfx/ProgressiveUpdateData.java',
+    'gfx/RectUtils.java',
+    'gfx/RenderTask.java',
+    'gfx/ScrollbarLayer.java',
+    'gfx/SimpleScaleGestureDetector.java',
+    'gfx/SingleTileLayer.java',
+    'gfx/SubdocumentScrollHelper.java',
+    'gfx/TextLayer.java',
+    'gfx/TextureGenerator.java',
+    'gfx/TextureReaper.java',
+    'gfx/TileLayer.java',
+    'gfx/TouchEventHandler.java',
+    'gfx/ViewTransform.java',
+    'gfx/VirtualLayer.java',
+    'GlobalHistory.java',
+    'health/BrowserHealthRecorder.java',
+    'health/BrowserHealthReporter.java',
+    'health/HealthRecorder.java',
+    'health/SessionInformation.java',
+    'health/StubbedHealthRecorder.java',
+    'home/BookmarkFolderView.java',
+    'home/BookmarksListAdapter.java',
+    'home/BookmarksListView.java',
+    'home/BookmarksPanel.java',
+    'home/BrowserSearch.java',
+    'home/DynamicPanel.java',
+    'home/FadedTextView.java',
+    'home/FramePanelLayout.java',
+    'home/HistoryPanel.java',
+    'home/HomeAdapter.java',
+    'home/HomeBanner.java',
+    'home/HomeConfig.java',
+    'home/HomeConfigInvalidator.java',
+    'home/HomeConfigLoader.java',
+    'home/HomeConfigPrefsBackend.java',
+    'home/HomeContextMenuInfo.java',
+    'home/HomeFragment.java',
+    'home/HomeListView.java',
+    'home/HomePager.java',
+    'home/HomePagerTabStrip.java',
+    'home/HomePanelPicker.java',
+    'home/LastTabsPanel.java',
+    'home/MostRecentPanel.java',
+    'home/MultiTypeCursorAdapter.java',
+    'home/PanelAuthCache.java',
+    'home/PanelAuthLayout.java',
+    'home/PanelBackItemView.java',
+    'home/PanelGridView.java',
+    'home/PanelItemView.java',
+    'home/PanelLayout.java',
+    'home/PanelListView.java',
+    'home/PanelManager.java',
+    'home/PanelViewAdapter.java',
+    'home/PanelViewItemHandler.java',
+    'home/PinSiteDialog.java',
+    'home/ReadingListPanel.java',
+    'home/SearchEngine.java',
+    'home/SearchEngineRow.java',
+    'home/SearchLoader.java',
+    'home/SimpleCursorLoader.java',
+    'home/SuggestClient.java',
+    'home/TabMenuStrip.java',
+    'home/TopSitesGridItemView.java',
+    'home/TopSitesGridView.java',
+    'home/TopSitesPanel.java',
+    'home/TopSitesThumbnailView.java',
+    'home/TwoLinePageRow.java',
+    'InputMethods.java',
+    'JavaAddonManager.java',
+    'LightweightTheme.java',
+    'LightweightThemeDrawable.java',
+    'LocaleManager.java',
+    'MediaCastingBar.java',
+    'MemoryMonitor.java',
+    'menu/GeckoMenu.java',
+    'menu/GeckoMenuInflater.java',
+    'menu/GeckoMenuItem.java',
+    'menu/GeckoSubMenu.java',
+    'menu/MenuItemActionBar.java',
+    'menu/MenuItemActionView.java',
+    'menu/MenuItemDefault.java',
+    'menu/MenuPanel.java',
+    'menu/MenuPopup.java',
+    'MotionEventInterceptor.java',
+    'NotificationClient.java',
+    'NotificationHandler.java',
+    'NotificationHelper.java',
+    'NotificationService.java',
+    'NSSBridge.java',
+    'OrderedBroadcastHelper.java',
+    'preferences/AlignRightLinkPreference.java',
+    'preferences/AndroidImport.java',
+    'preferences/AndroidImportPreference.java',
+    'preferences/CustomListCategory.java',
+    'preferences/CustomListPreference.java',
+    'preferences/FontSizePreference.java',
+    'preferences/GeckoPreferenceFragment.java',
+    'preferences/GeckoPreferences.java',
+    'preferences/LinkPreference.java',
+    'preferences/ModifiableHintPreference.java',
+    'preferences/MultiChoicePreference.java',
+    'preferences/PanelsPreference.java',
+    'preferences/PanelsPreferenceCategory.java',
+    'preferences/PrivateDataPreference.java',
+    'preferences/SearchEnginePreference.java',
+    'preferences/SearchPreferenceCategory.java',
+    'preferences/SyncPreference.java',
+    'PrefsHelper.java',
+    'PrivateTab.java',
+    'prompts/ColorPickerInput.java',
+    'prompts/IconGridInput.java',
+    'prompts/IntentChooserPrompt.java',
+    'prompts/IntentHandler.java',
+    'prompts/Prompt.java',
+    'prompts/PromptInput.java',
+    'prompts/PromptListAdapter.java',
+    'prompts/PromptListItem.java',
+    'prompts/PromptService.java',
+    'prompts/TabInput.java',
+    'ReaderModeUtils.java',
+    'ReferrerReceiver.java',
+    'RemoteTabs.java',
+    'Restarter.java',
+    'ScrollAnimator.java',
+    'ServiceNotificationClient.java',
+    'SessionParser.java',
+    'SharedPreferencesHelper.java',
+    'SiteIdentity.java',
+    'SmsManager.java',
+    'sqlite/ByteBufferInputStream.java',
+    'sqlite/MatrixBlobCursor.java',
+    'sqlite/SQLiteBridge.java',
+    'sqlite/SQLiteBridgeException.java',
+    'SurfaceBits.java',
+    'Tab.java',
+    'Tabs.java',
+    'TabsAccessor.java',
+    'TabsPanel.java',
+    'TabsTray.java',
+    'Telemetry.java',
+    'TextSelection.java',
+    'TextSelectionHandle.java',
+    'ThumbnailHelper.java',
+    'toolbar/AutocompleteHandler.java',
+    'toolbar/BackButton.java',
+    'toolbar/BrowserToolbar.java',
+    'toolbar/CanvasDelegate.java',
+    'toolbar/ForwardButton.java',
+    'toolbar/PageActionLayout.java',
+    'toolbar/ShapedButton.java',
+    'toolbar/SiteIdentityPopup.java',
+    'toolbar/TabCounter.java',
+    'toolbar/ToolbarDisplayLayout.java',
+    'toolbar/ToolbarEditLayout.java',
+    'toolbar/ToolbarEditText.java',
+    'toolbar/ToolbarProgressView.java',
+    'toolbar/ToolbarTitlePrefs.java',
+    'TouchEventInterceptor.java',
+    'updater/UpdateService.java',
+    'updater/UpdateServiceHelper.java',
+    'VideoPlayer.java',
+    'webapp/Allocator.java',
+    'webapp/ApkResources.java',
+    'webapp/Dispatcher.java',
+    'webapp/EventListener.java',
+    'webapp/InstallHelper.java',
+    'webapp/InstallListener.java',
+    'webapp/TaskKiller.java',
+    'webapp/UninstallListener.java',
+    'webapp/WebappImpl.java',
+    'WebappAllocator.java',
+    'WebappImpl.java',
+    'widget/ActivityChooserModel.java',
+    'widget/AllCapsTextView.java',
+    'widget/AnimatedHeightLayout.java',
+    'widget/ArrowPopup.java',
+    'widget/BasicColorPicker.java',
+    'widget/ButtonToast.java',
+    'widget/CheckableLinearLayout.java',
+    'widget/ClickableWhenDisabledEditText.java',
+    'widget/DateTimePicker.java',
+    'widget/Divider.java',
+    'widget/DoorHanger.java',
+    'widget/EllipsisTextView.java',
+    'widget/FaviconView.java',
+    'widget/FlowLayout.java',
+    'widget/GeckoActionProvider.java',
+    'widget/GeckoPopupMenu.java',
+    'widget/GeckoViewFlipper.java',
+    'widget/IconTabWidget.java',
+    'widget/SquaredImageView.java',
+    'widget/TabRow.java',
+    'widget/ThumbnailView.java',
+    'widget/TwoWayView.java',
+    'ZoomConstraints.java',
+]
+gbjar.sources += [ thirdparty_source_dir + f for f in [
+    'com/googlecode/eyesfree/braille/selfbraille/ISelfBrailleService.java',
+    'com/googlecode/eyesfree/braille/selfbraille/SelfBrailleClient.java',
+    'com/googlecode/eyesfree/braille/selfbraille/WriteData.java',
+] ]
+android_package_dir = CONFIG['ANDROID_PACKAGE_NAME'].replace('.', '/')
+# All generated sources are handled specially in Makefile.in.  And
+# R.java is handled even more specially than the others!
+gbjar.generated_sources += [ android_package_dir + f for f in [
+    '/App.java',
+    '/Webapp.java',
+    '/WebApps.java',
+] ]
+gbjar.generated_sources += [
+    'org/mozilla/gecko/AppConstants.java',
+    'org/mozilla/gecko/SysInfo.java',
+    'org/mozilla/gecko/widget/GeckoEditText.java',
+    'org/mozilla/gecko/widget/GeckoImageButton.java',
+    'org/mozilla/gecko/widget/GeckoImageView.java',
+    'org/mozilla/gecko/widget/GeckoLinearLayout.java',
+    'org/mozilla/gecko/widget/GeckoRelativeLayout.java',
+    'org/mozilla/gecko/widget/GeckoTextSwitcher.java',
+    'org/mozilla/gecko/widget/GeckoTextView.java',
+]
+if CONFIG['MOZ_CRASHREPORTER']:
+    gbjar.sources += [ 'CrashReporter.java' ]
+    ANDROID_RES_DIRS += [ SRCDIR + '/crashreporter/res' ]
+
+gbjar.sources += sync_java_files
+gbjar.generated_sources += sync_generated_java_files
+gbjar.extra_jars = [
+    'gecko-R.jar',
+    'gecko-mozglue.jar',
+    'gecko-util.jar',
+    'squareup-picasso.jar',
+    'sync-thirdparty.jar',
+    'websockets.jar',
+]
+gbjar.javac_flags += ['-Xlint:all,-deprecation,-fallthrough']
+
+spjar = add_java_jar('squareup-picasso')
+spjar.sources += [ thirdparty_source_dir + f for f in [
+    'com/squareup/picasso/Action.java',
+    'com/squareup/picasso/AssetBitmapHunter.java',
+    'com/squareup/picasso/BitmapHunter.java',
+    'com/squareup/picasso/Cache.java',
+    'com/squareup/picasso/Callback.java',
+    'com/squareup/picasso/ContactsPhotoBitmapHunter.java',
+    'com/squareup/picasso/ContentStreamBitmapHunter.java',
+    'com/squareup/picasso/DeferredRequestCreator.java',
+    'com/squareup/picasso/Dispatcher.java',
+    'com/squareup/picasso/Downloader.java',
+    'com/squareup/picasso/FetchAction.java',
+    'com/squareup/picasso/FileBitmapHunter.java',
+    'com/squareup/picasso/GetAction.java',
+    'com/squareup/picasso/ImageViewAction.java',
+    'com/squareup/picasso/LruCache.java',
+    'com/squareup/picasso/MarkableInputStream.java',
+    'com/squareup/picasso/MediaStoreBitmapHunter.java',
+    'com/squareup/picasso/NetworkBitmapHunter.java',
+    'com/squareup/picasso/Picasso.java',
+    'com/squareup/picasso/PicassoDrawable.java',
+    'com/squareup/picasso/PicassoExecutorService.java',
+    'com/squareup/picasso/Request.java',
+    'com/squareup/picasso/RequestCreator.java',
+    'com/squareup/picasso/ResourceBitmapHunter.java',
+    'com/squareup/picasso/Stats.java',
+    'com/squareup/picasso/StatsSnapshot.java',
+    'com/squareup/picasso/Target.java',
+    'com/squareup/picasso/TargetAction.java',
+    'com/squareup/picasso/Transformation.java',
+    'com/squareup/picasso/UrlConnectionDownloader.java',
+    'com/squareup/picasso/Utils.java',
+] ]
+#spjar.javac_flags += ['-Xlint:all']
+
+ANDROID_RES_DIRS += [
+    SRCDIR + '/resources',
+    TOPSRCDIR + '/' + CONFIG['MOZ_BRANDING_DIRECTORY'] + '/res',
+    OBJDIR + '/res',
+]
+
+ANDROID_GENERATED_RESFILES += [
+    'res/values/strings.xml',
+]
+
+for var in ('MOZ_ANDROID_ANR_REPORTER', 'MOZ_LINKER_EXTRACT'):
+    if CONFIG[var]:
+        DEFINES[var] = 1
+
+for var in ('MOZ_UPDATER', 'MOZ_PKG_SPECIAL'):
+    if CONFIG[var]:
+        DEFINES[var] = CONFIG[var]
+
+for var in ('ANDROID_PACKAGE_NAME', 'ANDROID_CPU_ARCH', 'CPU_ARCH',
+            'GRE_MILESTONE', 'MOZILLA_OFFICIAL', 'MOZ_APP_BASENAME',
+            'MOZ_APP_DISPLAYNAME', 'MOZ_APP_ID', 'MOZ_APP_NAME',
+            'MOZ_APP_VENDOR', 'MOZ_APP_VERSION', 'MOZ_CHILD_PROCESS_NAME',
+            'MOZ_CRASHREPORTER', 'MOZ_UPDATE_CHANNEL', 'OMNIJAR_NAME',
+            'OS_TARGET', 'TARGET_XPCOM_ABI'):
+    DEFINES[var] = CONFIG[var]
+
+# Mangle our package name to avoid Bug 750548.
+DEFINES['MANGLED_ANDROID_PACKAGE_NAME'] = CONFIG['ANDROID_PACKAGE_NAME'].replace('fennec', 'f3nn3c')
+DEFINES['MOZ_APP_ABI'] = CONFIG['TARGET_XPCOM_ABI']
+
+if '-march=armv7' in CONFIG['OS_CFLAGS']:
+    DEFINES['MOZ_MIN_CPU_VERSION'] = 7
+else:
+    DEFINES['MOZ_MIN_CPU_VERSION'] = 5
+
+generated = add_android_eclipse_library_project('FennecResourcesGenerated')
+generated.package_name = 'org.mozilla.fennec.resources.generated'
+generated.res = OBJDIR + '/res'
+
+branding = add_android_eclipse_library_project('FennecResourcesBranding')
+branding.package_name = 'org.mozilla.fennec.resources.branding'
+branding.res = TOPSRCDIR + '/' + CONFIG['MOZ_BRANDING_DIRECTORY'] + '/res'
+
+main = add_android_eclipse_project('Fennec', OBJDIR + '/AndroidManifest.xml')
+main.package_name = 'org.mozilla.gecko'
+
+# These values were extracted from an existing Eclipse project.  Use
+# Project > Resource > Resource Filters and inspect the resulting
+# .project file to modify this list.
+main.filtered_resources += [
+    '1.0-projectRelativePath-matches-false-false-*org/mozilla/gecko/resources/**',
+    '1.0-projectRelativePath-matches-false-false-*org/mozilla/gecko/tests/**',
+]
+
+main.recursive_make_targets += ['.aapt.deps'] # Captures dependencies on Android manifest and all resources.
+main.recursive_make_targets += [OBJDIR + '/generated/' + f for f in mgjar.generated_sources]
+main.recursive_make_targets += [OBJDIR + '/generated/' + f for f in gbjar.generated_sources]
+
+main.included_projects += ['../' + generated.name, '../' + branding.name]
+main.referenced_projects += [generated.name, branding.name]
+main.extra_jars += [CONFIG['ANDROID_COMPAT_LIB']]
+main.assets = TOPOBJDIR + '/dist/fennec/assets'
+main.libs = TOPOBJDIR + '/dist/fennec/lib'
+main.res = None
+
+cpe = main.add_classpathentry('src', SRCDIR,
+    dstdir='src/org/mozilla/gecko',
+    exclude_patterns=['org/mozilla/gecko/tests/**',
+        'org/mozilla/gecko/resources/**'])
+if not CONFIG['MOZ_CRASHREPORTER']:
+    cpe.exclude_patterns += ['org/mozilla/gecko/CrashReporter.java']
+main.add_classpathentry('generated', OBJDIR + '/generated',
+    dstdir='generated')
+main.add_classpathentry('thirdparty', TOPSRCDIR + '/mobile/android/thirdparty',
+    dstdir='thirdparty',
+    ignore_warnings=True)
+
+resources = add_android_eclipse_library_project('FennecResources')
+resources.package_name = 'org.mozilla.fennec.resources'
+resources.res = SRCDIR + '/resources'
+resources.included_projects += ['../' + generated.name, '../' + branding.name]
+resources.referenced_projects += [generated.name, branding.name]
+
+main.included_projects += ['../' + resources.name]
+main.referenced_projects += [resources.name]
+
+if CONFIG['MOZ_CRASHREPORTER']:
+    crashreporter = add_android_eclipse_library_project('FennecResourcesCrashReporter')
+    crashreporter.package_name = 'org.mozilla.fennec.resources.crashreporter'
+    crashreporter.res = SRCDIR + '/crashreporter/res'
+    crashreporter.included_projects += ['../' + resources.name]
+    crashreporter.referenced_projects += [resources.name]
+
+    main.included_projects += ['../' + crashreporter.name]
+    main.referenced_projects += [crashreporter.name]
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/resources/values-large-v11/dimens.xml
--- a/mobile/android/base/resources/values-large-v11/dimens.xml	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/resources/values-large-v11/dimens.xml	Mon Mar 31 16:57:28 2014 +0700
@@ -5,7 +5,7 @@
 
 <resources>
 
-    <dimen name="browser_toolbar_height">56dp</dimen>
+    <dimen name="browser_toolbar_height">0dp</dimen>
     <dimen name="browser_toolbar_button_padding">16dp</dimen>
     <dimen name="menu_popup_arrow_margin">8dip</dimen>
     <dimen name="tabs_counter_size">26sp</dimen>
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/resources/values-xlarge-v11/dimens.xml
--- a/mobile/android/base/resources/values-xlarge-v11/dimens.xml	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/resources/values-xlarge-v11/dimens.xml	Mon Mar 31 16:57:28 2014 +0700
@@ -5,7 +5,7 @@
 
 <resources>
 
-    <dimen name="browser_toolbar_height">56dp</dimen>
+    <dimen name="browser_toolbar_height">0dp</dimen>
     <dimen name="remote_tab_child_row_height">56dp</dimen>
     <dimen name="remote_tab_group_row_height">34dp</dimen>
     <dimen name="tabs_counter_size">26sp</dimen>
diff -r 6fa163ff81a3 -r 8912580d52d5 mobile/android/base/resources/values/dimens.xml
--- a/mobile/android/base/resources/values/dimens.xml	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/resources/values/dimens.xml	Mon Mar 31 16:57:28 2014 +0700
@@ -8,7 +8,7 @@
     <dimen name="autocomplete_min_width">200dp</dimen>
     <dimen name="autocomplete_row_height">32dp</dimen>
 
-    <dimen name="browser_toolbar_height">48dp</dimen>
+    <dimen name="browser_toolbar_height">0dp</dimen>
     <dimen name="browser_toolbar_button_padding">12dp</dimen>
     <dimen name="browser_toolbar_icon_width">48dp</dimen>
     <dimen name="browser_toolbar_lock_width">20dp</dimen>
# HG changeset patch
# User Cuong Thai <thailycuong1202@gmail.com>
# Date 1396263119 -25200
#      Mon Mar 31 17:51:59 2014 +0700
# Branch better_hide_status_menu
# Node ID e13b74c1f87eabdea238412e775c6e57aa029bae
# Parent  6fa163ff81a310fa4f30d11aa7a5ec8e4ff3e1bf
Save

diff -r 6fa163ff81a3 -r e13b74c1f87e mobile/android/base/BrowserApp.java
--- a/mobile/android/base/BrowserApp.java	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/BrowserApp.java	Mon Mar 31 17:51:59 2014 +0700
@@ -2082,30 +2082,30 @@
             share.setActionProvider(provider);
         }
 
-        return true;
+        return false;
     }
 
     @Override
     public void openOptionsMenu() {
-        if (!hasTabsSideBar() && areTabsShown())
-            return;
-
-        // Scroll custom menu to the top
-        if (mMenuPanel != null)
-            mMenuPanel.scrollTo(0, 0);
-
-        if (!mBrowserToolbar.openOptionsMenu())
-            super.openOptionsMenu();
-
-        if (mDynamicToolbar.isEnabled()) {
-            mDynamicToolbar.setVisible(true, VisibilityTransition.ANIMATE);
-        }
+//        if (!hasTabsSideBar() && areTabsShown())
+//            return;
+//
+//        // Scroll custom menu to the top
+//        if (mMenuPanel != null)
+//            mMenuPanel.scrollTo(0, 0);
+//
+//        if (!mBrowserToolbar.openOptionsMenu())
+//            super.openOptionsMenu();
+//
+//        if (mDynamicToolbar.isEnabled()) {
+//            mDynamicToolbar.setVisible(true, VisibilityTransition.ANIMATE);
+//        }
     }
 
     @Override
     public void closeOptionsMenu() {
-        if (!mBrowserToolbar.closeOptionsMenu())
-            super.closeOptionsMenu();
+//        if (!mBrowserToolbar.closeOptionsMenu())
+//            super.closeOptionsMenu();
     }
 
     @Override
@@ -2135,142 +2135,143 @@
 
     @Override
     public boolean onPrepareOptionsMenu(Menu aMenu) {
-        if (aMenu == null)
-            return false;
-
-        if (!GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoRunning))
-            aMenu.findItem(R.id.settings).setEnabled(false);
-
-        Tab tab = Tabs.getInstance().getSelectedTab();
-        MenuItem bookmark = aMenu.findItem(R.id.bookmark);
-        MenuItem back = aMenu.findItem(R.id.back);
-        MenuItem forward = aMenu.findItem(R.id.forward);
-        MenuItem share = aMenu.findItem(R.id.share);
-        MenuItem saveAsPDF = aMenu.findItem(R.id.save_as_pdf);
-        MenuItem charEncoding = aMenu.findItem(R.id.char_encoding);
-        MenuItem findInPage = aMenu.findItem(R.id.find_in_page);
-        MenuItem desktopMode = aMenu.findItem(R.id.desktop_mode);
-        MenuItem enterGuestMode = aMenu.findItem(R.id.new_guest_session);
-        MenuItem exitGuestMode = aMenu.findItem(R.id.exit_guest_session);
-
-        // Only show the "Quit" menu item on pre-ICS or television devices.
-        // In ICS+, it's easy to kill an app through the task switcher.
-        aMenu.findItem(R.id.quit).setVisible(Build.VERSION.SDK_INT < 14 || HardwareUtils.isTelevision());
-
-        if (tab == null || tab.getURL() == null) {
-            bookmark.setEnabled(false);
-            back.setEnabled(false);
-            forward.setEnabled(false);
-            share.setEnabled(false);
-            saveAsPDF.setEnabled(false);
-            findInPage.setEnabled(false);
-
-            // NOTE: Use MenuUtils.safeSetEnabled because some actions might
-            // be on the BrowserToolbar context menu
-            MenuUtils.safeSetEnabled(aMenu, R.id.page, false);
-            MenuUtils.safeSetEnabled(aMenu, R.id.subscribe, false);
-            MenuUtils.safeSetEnabled(aMenu, R.id.add_search_engine, false);
-            MenuUtils.safeSetEnabled(aMenu, R.id.site_settings, false);
-            MenuUtils.safeSetEnabled(aMenu, R.id.add_to_launcher, false);
-
-            return true;
-        }
-
-        bookmark.setEnabled(!AboutPages.isAboutReader(tab.getURL()));
-        bookmark.setVisible(!GeckoProfile.get(this).inGuestMode());
-        bookmark.setCheckable(true);
-        bookmark.setChecked(tab.isBookmark());
-        bookmark.setIcon(tab.isBookmark() ? R.drawable.ic_menu_bookmark_remove : R.drawable.ic_menu_bookmark_add);
-
-        back.setEnabled(tab.canDoBack());
-        forward.setEnabled(tab.canDoForward());
-        desktopMode.setChecked(tab.getDesktopMode());
-        desktopMode.setIcon(tab.getDesktopMode() ? R.drawable.ic_menu_desktop_mode_on : R.drawable.ic_menu_desktop_mode_off);
-
-        String url = tab.getURL();
-        if (AboutPages.isAboutReader(url)) {
-            String urlFromReader = ReaderModeUtils.getUrlFromAboutReader(url);
-            if (urlFromReader != null) {
-                url = urlFromReader;
-            }
-        }
-
-        // Disable share menuitem for about:, chrome:, file:, and resource: URIs
-        String scheme = Uri.parse(url).getScheme();
-        share.setVisible(!GeckoProfile.get(this).inGuestMode());
-        share.setEnabled(!(scheme.equals("about") || scheme.equals("chrome") ||
-                           scheme.equals("file") || scheme.equals("resource")));
-
-        // NOTE: Use MenuUtils.safeSetEnabled because some actions might
-        // be on the BrowserToolbar context menu
-        MenuUtils.safeSetEnabled(aMenu, R.id.page, !isAboutHome(tab));
-        MenuUtils.safeSetEnabled(aMenu, R.id.subscribe, tab.hasFeeds());
-        MenuUtils.safeSetEnabled(aMenu, R.id.add_search_engine, tab.hasOpenSearch());
-        MenuUtils.safeSetEnabled(aMenu, R.id.site_settings, !isAboutHome(tab));
-        MenuUtils.safeSetEnabled(aMenu, R.id.add_to_launcher, !isAboutHome(tab));
-
-        // Action providers are available only ICS+.
-        if (Build.VERSION.SDK_INT >= 14) {
-            final GeckoActionProvider provider = ((GeckoMenuItem) share).getGeckoActionProvider();
-            if (provider != null) {
-                Intent shareIntent = provider.getIntent();
-
-                // For efficiency, the provider's intent is only set once
-                if (shareIntent == null) {
-                    shareIntent = new Intent(Intent.ACTION_SEND);
-                    shareIntent.setType("text/plain");
-                    provider.setIntent(shareIntent);
-                }
-
-                // Replace the existing intent's extras
-                shareIntent.putExtra(Intent.EXTRA_TEXT, url);
-                shareIntent.putExtra(Intent.EXTRA_SUBJECT, tab.getDisplayTitle());
-                shareIntent.putExtra(Intent.EXTRA_TITLE, tab.getDisplayTitle());
-
-                // Clear the existing thumbnail extras so we don't share an old thumbnail.
-                shareIntent.removeExtra("share_screenshot_uri");
-
-                // Include the thumbnail of the page being shared.
-                BitmapDrawable drawable = tab.getThumbnail();
-                if (drawable != null) {
-                    Bitmap thumbnail = drawable.getBitmap();
-
-                    // Kobo uses a custom intent extra for sharing thumbnails.
-                    if (Build.MANUFACTURER.equals("Kobo") && thumbnail != null) {
-                        File cacheDir = getExternalCacheDir();
-
-                        if (cacheDir != null) {
-                            File outFile = new File(cacheDir, "thumbnail.png");
-
-                            try {
-                                java.io.FileOutputStream out = new java.io.FileOutputStream(outFile);
-                                thumbnail.compress(Bitmap.CompressFormat.PNG, 90, out);
-                            } catch (FileNotFoundException e) {
-                                Log.e(LOGTAG, "File not found", e);
-                            }
-
-                            shareIntent.putExtra("share_screenshot_uri", Uri.parse(outFile.getPath()));
-                        }
-                    }
-                }
-            }
-        }
-
-        // Disable save as PDF for about:home and xul pages.
-        saveAsPDF.setEnabled(!(isAboutHome(tab) ||
-                               tab.getContentType().equals("application/vnd.mozilla.xul+xml")));
-
-        // Disable find in page for about:home, since it won't work on Java content.
-        findInPage.setEnabled(!isAboutHome(tab));
-
-        charEncoding.setVisible(GeckoPreferences.getCharEncodingState());
-
-        if (mProfile.inGuestMode())
-            exitGuestMode.setVisible(true);
-        else
-            enterGuestMode.setVisible(true);
-
-        return true;
+	    return false;
+//        if (aMenu == null)
+//            return false;
+//
+//        if (!GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoRunning))
+//            aMenu.findItem(R.id.settings).setEnabled(false);
+//
+//        Tab tab = Tabs.getInstance().getSelectedTab();
+//        MenuItem bookmark = aMenu.findItem(R.id.bookmark);
+//        MenuItem back = aMenu.findItem(R.id.back);
+//        MenuItem forward = aMenu.findItem(R.id.forward);
+//        MenuItem share = aMenu.findItem(R.id.share);
+//        MenuItem saveAsPDF = aMenu.findItem(R.id.save_as_pdf);
+//        MenuItem charEncoding = aMenu.findItem(R.id.char_encoding);
+//        MenuItem findInPage = aMenu.findItem(R.id.find_in_page);
+//        MenuItem desktopMode = aMenu.findItem(R.id.desktop_mode);
+//        MenuItem enterGuestMode = aMenu.findItem(R.id.new_guest_session);
+//        MenuItem exitGuestMode = aMenu.findItem(R.id.exit_guest_session);
+//
+//        // Only show the "Quit" menu item on pre-ICS or television devices.
+//        // In ICS+, it's easy to kill an app through the task switcher.
+//        aMenu.findItem(R.id.quit).setVisible(Build.VERSION.SDK_INT < 14 || HardwareUtils.isTelevision());
+//
+//        if (tab == null || tab.getURL() == null) {
+//            bookmark.setEnabled(false);
+//            back.setEnabled(false);
+//            forward.setEnabled(false);
+//            share.setEnabled(false);
+//            saveAsPDF.setEnabled(false);
+//            findInPage.setEnabled(false);
+//
+//            // NOTE: Use MenuUtils.safeSetEnabled because some actions might
+//            // be on the BrowserToolbar context menu
+//            MenuUtils.safeSetEnabled(aMenu, R.id.page, false);
+//            MenuUtils.safeSetEnabled(aMenu, R.id.subscribe, false);
+//            MenuUtils.safeSetEnabled(aMenu, R.id.add_search_engine, false);
+//            MenuUtils.safeSetEnabled(aMenu, R.id.site_settings, false);
+//            MenuUtils.safeSetEnabled(aMenu, R.id.add_to_launcher, false);
+//
+//            return true;
+//        }
+//
+//        bookmark.setEnabled(!AboutPages.isAboutReader(tab.getURL()));
+//        bookmark.setVisible(!GeckoProfile.get(this).inGuestMode());
+//        bookmark.setCheckable(true);
+//        bookmark.setChecked(tab.isBookmark());
+//        bookmark.setIcon(tab.isBookmark() ? R.drawable.ic_menu_bookmark_remove : R.drawable.ic_menu_bookmark_add);
+//
+//        back.setEnabled(tab.canDoBack());
+//        forward.setEnabled(tab.canDoForward());
+//        desktopMode.setChecked(tab.getDesktopMode());
+//        desktopMode.setIcon(tab.getDesktopMode() ? R.drawable.ic_menu_desktop_mode_on : R.drawable.ic_menu_desktop_mode_off);
+//
+//        String url = tab.getURL();
+//        if (AboutPages.isAboutReader(url)) {
+//            String urlFromReader = ReaderModeUtils.getUrlFromAboutReader(url);
+//            if (urlFromReader != null) {
+//                url = urlFromReader;
+//            }
+//        }
+//
+//        // Disable share menuitem for about:, chrome:, file:, and resource: URIs
+//        String scheme = Uri.parse(url).getScheme();
+//        share.setVisible(!GeckoProfile.get(this).inGuestMode());
+//        share.setEnabled(!(scheme.equals("about") || scheme.equals("chrome") ||
+//                           scheme.equals("file") || scheme.equals("resource")));
+//
+//        // NOTE: Use MenuUtils.safeSetEnabled because some actions might
+//        // be on the BrowserToolbar context menu
+//        MenuUtils.safeSetEnabled(aMenu, R.id.page, !isAboutHome(tab));
+//        MenuUtils.safeSetEnabled(aMenu, R.id.subscribe, tab.hasFeeds());
+//        MenuUtils.safeSetEnabled(aMenu, R.id.add_search_engine, tab.hasOpenSearch());
+//        MenuUtils.safeSetEnabled(aMenu, R.id.site_settings, !isAboutHome(tab));
+//        MenuUtils.safeSetEnabled(aMenu, R.id.add_to_launcher, !isAboutHome(tab));
+//
+//        // Action providers are available only ICS+.
+//        if (Build.VERSION.SDK_INT >= 14) {
+//            final GeckoActionProvider provider = ((GeckoMenuItem) share).getGeckoActionProvider();
+//            if (provider != null) {
+//                Intent shareIntent = provider.getIntent();
+//
+//                // For efficiency, the provider's intent is only set once
+//                if (shareIntent == null) {
+//                    shareIntent = new Intent(Intent.ACTION_SEND);
+//                    shareIntent.setType("text/plain");
+//                    provider.setIntent(shareIntent);
+//                }
+//
+//                // Replace the existing intent's extras
+//                shareIntent.putExtra(Intent.EXTRA_TEXT, url);
+//                shareIntent.putExtra(Intent.EXTRA_SUBJECT, tab.getDisplayTitle());
+//                shareIntent.putExtra(Intent.EXTRA_TITLE, tab.getDisplayTitle());
+//
+//                // Clear the existing thumbnail extras so we don't share an old thumbnail.
+//                shareIntent.removeExtra("share_screenshot_uri");
+//
+//                // Include the thumbnail of the page being shared.
+//                BitmapDrawable drawable = tab.getThumbnail();
+//                if (drawable != null) {
+//                    Bitmap thumbnail = drawable.getBitmap();
+//
+//                    // Kobo uses a custom intent extra for sharing thumbnails.
+//                    if (Build.MANUFACTURER.equals("Kobo") && thumbnail != null) {
+//                        File cacheDir = getExternalCacheDir();
+//
+//                        if (cacheDir != null) {
+//                            File outFile = new File(cacheDir, "thumbnail.png");
+//
+//                            try {
+//                                java.io.FileOutputStream out = new java.io.FileOutputStream(outFile);
+//                                thumbnail.compress(Bitmap.CompressFormat.PNG, 90, out);
+//                            } catch (FileNotFoundException e) {
+//                                Log.e(LOGTAG, "File not found", e);
+//                            }
+//
+//                            shareIntent.putExtra("share_screenshot_uri", Uri.parse(outFile.getPath()));
+//                        }
+//                    }
+//                }
+//            }
+//        }
+//
+//        // Disable save as PDF for about:home and xul pages.
+//        saveAsPDF.setEnabled(!(isAboutHome(tab) ||
+//                               tab.getContentType().equals("application/vnd.mozilla.xul+xml")));
+//
+//        // Disable find in page for about:home, since it won't work on Java content.
+//        findInPage.setEnabled(!isAboutHome(tab));
+//
+//        charEncoding.setVisible(GeckoPreferences.getCharEncodingState());
+//
+//        if (mProfile.inGuestMode())
+//            exitGuestMode.setVisible(true);
+//        else
+//            enterGuestMode.setVisible(true);
+//
+//        return true;
     }
 
     @Override
diff -r 6fa163ff81a3 -r e13b74c1f87e mobile/android/base/GeckoApp.java
--- a/mobile/android/base/GeckoApp.java	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/GeckoApp.java	Mon Mar 31 17:51:59 2014 +0700
@@ -339,7 +339,8 @@
 
         MenuInflater inflater = getMenuInflater();
         inflater.inflate(R.menu.gecko_app_menu, mMenu);
-        return true;
+
+        return false;
     }
 
     @Override
@@ -395,9 +396,9 @@
                 onPreparePanel(featureId, mMenuPanel, mMenu);
             }
 
-            return mMenuPanel; 
+            return mMenuPanel;
         }
-  
+
         return super.onCreatePanelView(featureId);
     }
 
@@ -1425,6 +1426,7 @@
             // bind the GeckoEditable instance to the new LayerView
             GeckoAppShell.notifyIMEContext(GeckoEditableListener.IME_STATE_DISABLED, "", "", "");
         }
+	    setFullScreen(true);
     }
 
     /**
diff -r 6fa163ff81a3 -r e13b74c1f87e mobile/android/base/resources/values-large-v11/dimens.xml
--- a/mobile/android/base/resources/values-large-v11/dimens.xml	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/resources/values-large-v11/dimens.xml	Mon Mar 31 17:51:59 2014 +0700
@@ -5,7 +5,7 @@
 
 <resources>
 
-    <dimen name="browser_toolbar_height">56dp</dimen>
+    <dimen name="browser_toolbar_height">0dp</dimen>
     <dimen name="browser_toolbar_button_padding">16dp</dimen>
     <dimen name="menu_popup_arrow_margin">8dip</dimen>
     <dimen name="tabs_counter_size">26sp</dimen>
diff -r 6fa163ff81a3 -r e13b74c1f87e mobile/android/base/resources/values-xlarge-v11/dimens.xml
--- a/mobile/android/base/resources/values-xlarge-v11/dimens.xml	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/resources/values-xlarge-v11/dimens.xml	Mon Mar 31 17:51:59 2014 +0700
@@ -5,7 +5,7 @@
 
 <resources>
 
-    <dimen name="browser_toolbar_height">56dp</dimen>
+    <dimen name="browser_toolbar_height">0dp</dimen>
     <dimen name="remote_tab_child_row_height">56dp</dimen>
     <dimen name="remote_tab_group_row_height">34dp</dimen>
     <dimen name="tabs_counter_size">26sp</dimen>
diff -r 6fa163ff81a3 -r e13b74c1f87e mobile/android/base/resources/values/dimens.xml
--- a/mobile/android/base/resources/values/dimens.xml	Thu Mar 27 20:07:56 2014 -0700
+++ b/mobile/android/base/resources/values/dimens.xml	Mon Mar 31 17:51:59 2014 +0700
@@ -8,7 +8,7 @@
     <dimen name="autocomplete_min_width">200dp</dimen>
     <dimen name="autocomplete_row_height">32dp</dimen>
 
-    <dimen name="browser_toolbar_height">48dp</dimen>
+    <dimen name="browser_toolbar_height">0dp</dimen>
     <dimen name="browser_toolbar_button_padding">12dp</dimen>
     <dimen name="browser_toolbar_icon_width">48dp</dimen>
     <dimen name="browser_toolbar_lock_width">20dp</dimen>
# HG changeset patch
# User Cuong Thai <thailycuong1202@gmail.com>
# Date 1396264392 -25200
#      Mon Mar 31 18:13:12 2014 +0700
# Branch better_hide_status_menu
# Node ID c6c9d3676be533670b8b06e56e3c299859d53b52
# Parent  e13b74c1f87eabdea238412e775c6e57aa029bae
Add intent filter

diff -r e13b74c1f87e -r c6c9d3676be5 mobile/android/base/AndroidManifest.xml.in
--- a/mobile/android/base/AndroidManifest.xml.in	Mon Mar 31 17:51:59 2014 +0700
+++ b/mobile/android/base/AndroidManifest.xml.in	Mon Mar 31 18:13:12 2014 +0700
@@ -93,6 +93,13 @@
                   android:windowSoftInputMode="stateUnspecified|adjustResize"
                   android:launchMode="singleTask"
                   android:theme="@style/Gecko.App">
+            <!-- Allow KidMode to start FlashKid to play flash -->
+            <intent-filter>
+                <action android:name="com.zoodles.action.VIEW_FLASH"/>
+                <category android:name="android.intent.category.DEFAULT"/>
+                <data android:scheme="http" />
+                <data android:scheme="https" />
+            </intent-filter>
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
                 <category android:name="android.intent.category.LAUNCHER" />
diff -r e13b74c1f87e -r c6c9d3676be5 mobile/android/base/BrowserApp.java
--- a/mobile/android/base/BrowserApp.java	Mon Mar 31 17:51:59 2014 +0700
+++ b/mobile/android/base/BrowserApp.java	Mon Mar 31 18:13:12 2014 +0700
@@ -608,20 +608,21 @@
 
     @Override
     public void onBackPressed() {
-        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
-            super.onBackPressed();
-            return;
-        }
 
-        if (mBrowserToolbar.onBackPressed()) {
-            return;
-        }
-
-        if (mActionMode != null) {
-            endActionModeCompat();
-            return;
-        }
-
+//        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
+//            super.onBackPressed();
+//            return;
+//        }
+//
+//        if (mBrowserToolbar.onBackPressed()) {
+//            return;
+//        }
+//
+//        if (mActionMode != null) {
+//            endActionModeCompat();
+//            return;
+//        }
+//
         super.onBackPressed();
     }
 
diff -r e13b74c1f87e -r c6c9d3676be5 mobile/android/base/GeckoApp.java
--- a/mobile/android/base/GeckoApp.java	Mon Mar 31 17:51:59 2014 +0700
+++ b/mobile/android/base/GeckoApp.java	Mon Mar 31 18:13:12 2014 +0700
@@ -2335,56 +2335,56 @@
 
     @Override
     public void onBackPressed() {
-        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
-            super.onBackPressed();
-            return;
-        }
-
-        if (autoHideTabs()) {
-            return;
-        }
-
-        if (mDoorHangerPopup != null && mDoorHangerPopup.isShowing()) {
-            mDoorHangerPopup.dismiss();
-            return;
-        }
-
-        if (mFullScreenPluginView != null) {
-            GeckoAppShell.onFullScreenPluginHidden(mFullScreenPluginView);
-            removeFullScreenPluginView(mFullScreenPluginView);
-            return;
-        }
-
-        if (mLayerView != null && mLayerView.isFullScreen()) {
-            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
-            return;
-        }
-
-        Tabs tabs = Tabs.getInstance();
-        Tab tab = tabs.getSelectedTab();
-        if (tab == null) {
-            moveTaskToBack(true);
-            return;
-        }
-
-        if (tab.doBack())
-            return;
-
-        if (tab.isExternal()) {
-            moveTaskToBack(true);
-            tabs.closeTab(tab);
-            return;
-        }
-
-        int parentId = tab.getParentId();
-        Tab parent = tabs.getTab(parentId);
-        if (parent != null) {
-            // The back button should always return to the parent (not a sibling).
-            tabs.closeTab(tab, parent);
-            return;
-        }
-
-        moveTaskToBack(true);
+//        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
+//            super.onBackPressed();
+//            return;
+//        }
+//
+//        if (autoHideTabs()) {
+//            return;
+//        }
+//
+//        if (mDoorHangerPopup != null && mDoorHangerPopup.isShowing()) {
+//            mDoorHangerPopup.dismiss();
+//            return;
+//        }
+//
+//        if (mFullScreenPluginView != null) {
+//            GeckoAppShell.onFullScreenPluginHidden(mFullScreenPluginView);
+//            removeFullScreenPluginView(mFullScreenPluginView);
+//            return;
+//        }
+//
+//        if (mLayerView != null && mLayerView.isFullScreen()) {
+//            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
+//            return;
+//        }
+//
+//        Tabs tabs = Tabs.getInstance();
+//        Tab tab = tabs.getSelectedTab();
+//        if (tab == null) {
+//            moveTaskToBack(true);
+//            return;
+//        }
+//
+//        if (tab.doBack())
+//            return;
+//
+//        if (tab.isExternal()) {
+//            moveTaskToBack(true);
+//            tabs.closeTab(tab);
+//            return;
+//        }
+//
+//        int parentId = tab.getParentId();
+//        Tab parent = tabs.getTab(parentId);
+//        if (parent != null) {
+//            // The back button should always return to the parent (not a sibling).
+//            tabs.closeTab(tab, parent);
+//            return;
+//        }
+//
+//        moveTaskToBack(true);
     }
 
     @Override
# HG changeset patch
# User Cuong Thai <thailycuong1202@gmail.com>
# Date 1396264884 -25200
#      Mon Mar 31 18:21:24 2014 +0700
# Branch better_hide_status_menu
# Node ID 7f5ef5ff0c59122f8113343c51a96e749ee93709
# Parent  c6c9d3676be533670b8b06e56e3c299859d53b52
Quit system on Back

diff -r c6c9d3676be5 -r 7f5ef5ff0c59 mobile/android/base/BrowserApp.java
--- a/mobile/android/base/BrowserApp.java	Mon Mar 31 18:13:12 2014 +0700
+++ b/mobile/android/base/BrowserApp.java	Mon Mar 31 18:21:24 2014 +0700
@@ -608,7 +608,7 @@
 
     @Override
     public void onBackPressed() {
-
+//	    GeckoAppShell.systemExit();
 //        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
 //            super.onBackPressed();
 //            return;
diff -r c6c9d3676be5 -r 7f5ef5ff0c59 mobile/android/base/GeckoApp.java
--- a/mobile/android/base/GeckoApp.java	Mon Mar 31 18:13:12 2014 +0700
+++ b/mobile/android/base/GeckoApp.java	Mon Mar 31 18:21:24 2014 +0700
@@ -2335,6 +2335,7 @@
 
     @Override
     public void onBackPressed() {
+	    GeckoAppShell.systemExit();
 //        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
 //            super.onBackPressed();
 //            return;
# HG changeset patch
# User Cuong Thai <thailycuong1202@gmail.com>
# Date 1396968153 -25200
#      Tue Apr 08 21:42:33 2014 +0700
# Branch better_hide_status_menu
# Node ID 76920633b7622a390e3e7dd92e0f26a58d5bf7bb
# Parent  7f5ef5ff0c59122f8113343c51a96e749ee93709
Use official build, add new bar, remove intent-filder

diff -r 7f5ef5ff0c59 -r 76920633b762 configure.in
--- a/configure.in	Mon Mar 31 18:21:24 2014 +0700
+++ b/configure.in	Tue Apr 08 21:42:33 2014 +0700
@@ -312,7 +312,7 @@
     case "$target" in
     *-android*|*-linuxandroid*)
         if test -z "$ANDROID_PACKAGE_NAME" ; then
-            ANDROID_PACKAGE_NAME='org.mozilla.$(MOZ_APP_NAME)'
+            ANDROID_PACKAGE_NAME='com.zoodles.flashkid'
         fi
         MOZ_CHROME_FILE_FORMAT=omni
         ZLIB_DIR=yes
@@ -8648,6 +8648,7 @@
 dnl If we have any service that uploads data (and requires data submission
 dnl policy alert), set MOZ_DATA_REPORTING.
 dnl We need SUBST for build system and DEFINE for xul preprocessor.
+dnl KidBrowser: We never report data
 if test -n "$MOZ_TELEMETRY_REPORTING" || test -n "$MOZ_SERVICES_HEALTHREPORT" || test -n "$MOZ_CRASHREPORTER"; then
   MOZ_DATA_REPORTING=1
   AC_DEFINE(MOZ_DATA_REPORTING)
@@ -9258,7 +9259,6 @@
 export JS_STANDALONE=no
 export MOZ_LINKER
 export ZLIB_IN_MOZGLUE
-
 if ! test -e js; then
     mkdir js
 fi
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/base/AndroidManifest.xml.in
--- a/mobile/android/base/AndroidManifest.xml.in	Mon Mar 31 18:21:24 2014 +0700
+++ b/mobile/android/base/AndroidManifest.xml.in	Tue Apr 08 21:42:33 2014 +0700
@@ -113,59 +113,6 @@
                 <category android:name="android.intent.category.DEFAULT" />
             </intent-filter>
 
-            <!-- Default browser intents -->
-            <intent-filter>
-                <action android:name="android.intent.action.VIEW" />
-                <category android:name="android.intent.category.DEFAULT" />
-                <category android:name="android.intent.category.BROWSABLE" />
-                <data android:scheme="http" />
-                <data android:scheme="https" />
-                <data android:scheme="about" />
-                <data android:scheme="javascript" />
-            </intent-filter>
-            <intent-filter>
-                <action android:name="android.intent.action.VIEW" />
-                <category android:name="android.intent.category.BROWSABLE" />
-                <category android:name="android.intent.category.DEFAULT" />
-                <data android:scheme="file" />
-                <data android:scheme="http" />
-                <data android:scheme="https" />
-                <data android:mimeType="text/html"/>
-                <data android:mimeType="text/plain"/>
-                <data android:mimeType="application/xhtml+xml"/>
-            </intent-filter>
-
-            <intent-filter>
-                <action android:name="android.intent.action.WEB_SEARCH" />
-                <category android:name="android.intent.category.DEFAULT" />
-                <category android:name="android.intent.category.BROWSABLE" />
-                <data android:scheme="" />
-                <data android:scheme="http" />
-                <data android:scheme="https" />
-            </intent-filter>
-
-            <intent-filter>
-                <action android:name="android.intent.action.SEARCH" />
-            </intent-filter>
-
-            <!-- For XPI installs from websites and the download manager. -->
-            <intent-filter>
-                <action android:name="android.intent.action.VIEW" />
-                <category android:name="android.intent.category.DEFAULT" />
-                <data android:scheme="file" />
-                <data android:scheme="http" />
-                <data android:scheme="https" />
-                <data android:mimeType="application/x-xpinstall" />
-            </intent-filter>
-
-            <!-- For XPI installs from file: URLs. -->
-            <intent-filter>
-                <action android:name="android.intent.action.VIEW" />
-                <category android:name="android.intent.category.DEFAULT" />
-                <data android:host="" />
-                <data android:scheme="file" />
-                <data android:pathPattern=".*\\.xpi" />
-            </intent-filter>
 
 #ifdef MOZ_ANDROID_BEAM
             <intent-filter>
@@ -274,7 +221,7 @@
 
 #include ../services/manifests/AnnouncementsAndroidManifest_activities.xml.in
 #include ../services/manifests/FxAccountAndroidManifest_activities.xml.in
-#include ../services/manifests/SyncAndroidManifest_activities.xml.in
+<!-- ###include# ../services/manifests/SyncAndroidManifest_activities.xml.in -->
 #include ../services/manifests/HealthReportAndroidManifest_activities.xml.in
 
 #if MOZ_CRASHREPORTER
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/base/GeckoApp.java
--- a/mobile/android/base/GeckoApp.java	Mon Mar 31 18:21:24 2014 +0700
+++ b/mobile/android/base/GeckoApp.java	Tue Apr 08 21:42:33 2014 +0700
@@ -124,2218 +124,2252 @@
 import android.widget.Toast;
 
 public abstract class GeckoApp
-    extends GeckoActivity
-    implements
-    ContextGetter,
-    GeckoAppShell.GeckoInterface,
-    GeckoEventListener,
-    GeckoMenu.Callback,
-    GeckoMenu.MenuPresenter,
-    LocationListener,
-    SensorEventListener,
-    Tabs.OnTabsChangedListener
-{
-    private static final String LOGTAG = "GeckoApp";
-    private static final int ONE_DAY_MS = 1000*60*60*24;
-
-    private static enum StartupAction {
-        NORMAL,     /* normal application start */
-        URL,        /* launched with a passed URL */
-        PREFETCH    /* launched with a passed URL that we prefetch */
-    }
-
-    public static final String ACTION_ALERT_CALLBACK       = "org.mozilla.gecko.ACTION_ALERT_CALLBACK";
-    public static final String ACTION_BOOKMARK             = "org.mozilla.gecko.BOOKMARK";
-    public static final String ACTION_DEBUG                = "org.mozilla.gecko.DEBUG";
-    public static final String ACTION_LAUNCH_SETTINGS      = "org.mozilla.gecko.SETTINGS";
-    public static final String ACTION_LOAD                 = "org.mozilla.gecko.LOAD";
-    public static final String ACTION_INIT_PW              = "org.mozilla.gecko.INIT_PW";
-    public static final String ACTION_WEBAPP_PREFIX        = "org.mozilla.gecko.WEBAPP";
-
-    public static final String EXTRA_STATE_BUNDLE          = "stateBundle";
-
-    public static final String PREFS_ALLOW_STATE_BUNDLE    = "allowStateBundle";
-    public static final String PREFS_CRASHED               = "crashed";
-    public static final String PREFS_NAME                  = "GeckoApp";
-    public static final String PREFS_OOM_EXCEPTION         = "OOMException";
-    public static final String PREFS_VERSION_CODE          = "versionCode";
-    public static final String PREFS_WAS_STOPPED           = "wasStopped";
-    public static final String PREFS_CLEANUP_TEMP_FILES    = "cleanupTempFiles";
-
-    public static final String SAVED_STATE_IN_BACKGROUND   = "inBackground";
-    public static final String SAVED_STATE_PRIVATE_SESSION = "privateSession";
-
-    static private final String LOCATION_URL = "https://location.services.mozilla.com/v1/submit";
-
-    // Delay before running one-time "cleanup" tasks that may be needed
-    // after a version upgrade.
-    private static final int CLEANUP_DEFERRAL_SECONDS = 15;
-
-    protected RelativeLayout mMainLayout;
-    protected RelativeLayout mGeckoLayout;
-    public View getView() { return mGeckoLayout; }
-    private View mCameraView;
-    private OrientationEventListener mCameraOrientationEventListener;
-    public List<GeckoAppShell.AppStateListener> mAppStateListeners;
-    private static GeckoApp sAppContext;
-    protected MenuPanel mMenuPanel;
-    protected Menu mMenu;
-    protected GeckoProfile mProfile;
-    protected boolean mIsRestoringActivity;
-
-    private ContactService mContactService;
-    private PromptService mPromptService;
-    private TextSelection mTextSelection;
-
-    protected DoorHangerPopup mDoorHangerPopup;
-    protected FormAssistPopup mFormAssistPopup;
-    protected ButtonToast mToast;
-
-    protected LayerView mLayerView;
-    private AbsoluteLayout mPluginContainer;
-
-    private FullScreenHolder mFullScreenPluginContainer;
-    private View mFullScreenPluginView;
-
-    private HashMap<String, PowerManager.WakeLock> mWakeLocks = new HashMap<String, PowerManager.WakeLock>();
-
-    protected boolean mShouldRestore;
-    protected boolean mInitialized = false;
-    private Telemetry.Timer mJavaUiStartupTimer;
-    private Telemetry.Timer mGeckoReadyStartupTimer;
-
-    private String mPrivateBrowsingSession;
-
-    private volatile HealthRecorder mHealthRecorder = null;
-
-    private int mSignalStrenth;
-    private PhoneStateListener mPhoneStateListener = null;
-    private boolean mShouldReportGeoData;
-
-    abstract public int getLayout();
-    abstract public boolean hasTabsSideBar();
-    abstract protected String getDefaultProfileName() throws NoMozillaDirectoryException;
-
-    private static final String RESTARTER_ACTION = "org.mozilla.gecko.restart";
-    private static final String RESTARTER_CLASS = "org.mozilla.gecko.Restarter";
-
-    @SuppressWarnings("serial")
-    class SessionRestoreException extends Exception {
-        public SessionRestoreException(Exception e) {
-            super(e);
-        }
-
-        public SessionRestoreException(String message) {
-            super(message);
-        }
-    }
-
-    void toggleChrome(final boolean aShow) { }
-
-    void focusChrome() { }
-
-    @Override
-    public Context getContext() {
-        return sAppContext;
-    }
-
-    @Override
-    public SharedPreferences getSharedPreferences() {
-        return GeckoApp.getAppSharedPreferences();
-    }
-
-    public static SharedPreferences getAppSharedPreferences() {
-        return GeckoApp.sAppContext.getSharedPreferences(GeckoApp.PREFS_NAME, 0);
-    }
-
-    public Activity getActivity() {
-        return this;
-    }
-
-    public LocationListener getLocationListener() {
-        if (mShouldReportGeoData && mPhoneStateListener == null) {
-            mPhoneStateListener = new PhoneStateListener() {
-                public void onSignalStrengthsChanged(SignalStrength signalStrength) {
-                    setCurrentSignalStrenth(signalStrength);
-                }
-            };
-            TelephonyManager tm = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
-            tm.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SIGNAL_STRENGTHS);
-        }
-        return this;
-    }
-
-    public SensorEventListener getSensorEventListener() {
-        return this;
-    }
-
-    public View getCameraView() {
-        return mCameraView;
-    }
-
-    public void addAppStateListener(GeckoAppShell.AppStateListener listener) {
-        mAppStateListeners.add(listener);
-    }
-
-    public void removeAppStateListener(GeckoAppShell.AppStateListener listener) {
-        mAppStateListeners.remove(listener);
-    }
-
-    public FormAssistPopup getFormAssistPopup() {
-        return mFormAssistPopup;
-    }
-
-    @Override
-    public void onTabChanged(Tab tab, Tabs.TabEvents msg, Object data) {
-        // When a tab is closed, it is always unselected first.
-        // When a tab is unselected, another tab is always selected first.
-        switch(msg) {
-            case UNSELECTED:
-                hidePlugins(tab);
-                break;
-
-            case LOCATION_CHANGE:
-                // We only care about location change for the selected tab.
-                if (!Tabs.getInstance().isSelectedTab(tab))
-                    break;
-                // Fall through...
-            case SELECTED:
-                invalidateOptionsMenu();
-                if (mFormAssistPopup != null)
-                    mFormAssistPopup.hide();
-                break;
-
-            case LOADED:
-                // Sync up the layer view and the tab if the tab is
-                // currently displayed.
-                LayerView layerView = mLayerView;
-                if (layerView != null && Tabs.getInstance().isSelectedTab(tab))
-                    layerView.setBackgroundColor(tab.getBackgroundColor());
-                break;
-
-            case DESKTOP_MODE_CHANGE:
-                if (Tabs.getInstance().isSelectedTab(tab))
-                    invalidateOptionsMenu();
-                break;
-        }
-    }
-
-    public void refreshChrome() { }
-
-    @Override
-    public void invalidateOptionsMenu() {
-        if (mMenu == null)
-            return;
-
-        onPrepareOptionsMenu(mMenu);
-
-        if (Build.VERSION.SDK_INT >= 11)
-            super.invalidateOptionsMenu();
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        mMenu = menu;
-
-        MenuInflater inflater = getMenuInflater();
-        inflater.inflate(R.menu.gecko_app_menu, mMenu);
-
-        return false;
-    }
-
-    @Override
-    public MenuInflater getMenuInflater() {
-        if (Build.VERSION.SDK_INT >= 11)
-            return new GeckoMenuInflater(this);
-        else
-            return super.getMenuInflater();
-    }
-
-    public MenuPanel getMenuPanel() {
-        if (mMenuPanel == null) {
-            onCreatePanelMenu(Window.FEATURE_OPTIONS_PANEL, null);
-            invalidateOptionsMenu();
-        }
-        return mMenuPanel;
-    }
-
-    @Override
-    public boolean onMenuItemSelected(MenuItem item) {
-        return onOptionsItemSelected(item);
-    }
-
-    @Override
-    public void openMenu() {
-        openOptionsMenu();
-    }
-
-    @Override
-    public void showMenu(View menu) {
-        // Hide the menu before we reshow it to avoid platform specific bugs like
-        // bug 794581 and bug 968182.
-        closeMenu();
-
-        mMenuPanel.removeAllViews();
-        mMenuPanel.addView(menu);
-
-        openOptionsMenu();
-    }
-
-    @Override
-    public void closeMenu() {
-        closeOptionsMenu();
-    }
-
-    @Override
-    public View onCreatePanelView(int featureId) {
-        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
-            if (mMenuPanel == null) {
-                mMenuPanel = new MenuPanel(this, null);
-            } else {
-                // Prepare the panel everytime before showing the menu.
-                onPreparePanel(featureId, mMenuPanel, mMenu);
-            }
-
-            return mMenuPanel;
-        }
-
-        return super.onCreatePanelView(featureId);
-    }
-
-    @Override
-    public boolean onCreatePanelMenu(int featureId, Menu menu) {
-        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
-            if (mMenuPanel == null) {
-                mMenuPanel = (MenuPanel) onCreatePanelView(featureId);
-            }
-
-            GeckoMenu gMenu = new GeckoMenu(this, null);
-            gMenu.setCallback(this);
-            gMenu.setMenuPresenter(this);
-            menu = gMenu;
-            mMenuPanel.addView(gMenu);
-
-            return onCreateOptionsMenu(menu);
-        }
-
-        return super.onCreatePanelMenu(featureId, menu);
-    }
-
-    @Override
-    public boolean onPreparePanel(int featureId, View view, Menu menu) {
-        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL)
-            return onPrepareOptionsMenu(menu);
-
-        return super.onPreparePanel(featureId, view, menu);
-    }
-
-    @Override
-    public boolean onMenuOpened(int featureId, Menu menu) {
-        // exit full-screen mode whenever the menu is opened
-        if (mLayerView != null && mLayerView.isFullScreen()) {
-            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
-        }
-
-        if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
-            if (mMenu == null) {
-                // getMenuPanel() will force the creation of the menu as well
-                MenuPanel panel = getMenuPanel();
-                onPreparePanel(featureId, panel, mMenu);
-            }
-
-            // Scroll custom menu to the top
-            if (mMenuPanel != null)
-                mMenuPanel.scrollTo(0, 0);
-
-            return true;
-        }
-
-        return super.onMenuOpened(featureId, menu);
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        if (item.getItemId() == R.id.quit) {
-            if (GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.GeckoRunning, GeckoThread.LaunchState.GeckoExiting)) {
-                GeckoAppShell.notifyGeckoOfEvent(GeckoEvent.createBroadcastEvent("Browser:Quit", null));
-            } else {
-                GeckoAppShell.systemExit();
-            }
-            return true;
-        }
-
-        return super.onOptionsItemSelected(item);
-    }
-
-    @Override
-    public void onOptionsMenuClosed(Menu menu) {
-        if (Build.VERSION.SDK_INT >= 11) {
-            mMenuPanel.removeAllViews();
-            mMenuPanel.addView((GeckoMenu) mMenu);
-        }
-    }
- 
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        // Handle hardware menu key presses separately so that we can show a custom menu in some cases.
-        if (keyCode == KeyEvent.KEYCODE_MENU) {
-            openOptionsMenu();
-            return true;
-        }
-
-        return super.onKeyDown(keyCode, event);
-    }
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-
-        if (mToast != null) {
-            mToast.onSaveInstanceState(outState);
-        }
-
-        outState.putBoolean(SAVED_STATE_IN_BACKGROUND, isApplicationInBackground());
-        outState.putString(SAVED_STATE_PRIVATE_SESSION, mPrivateBrowsingSession);
-    }
-
-    void handleFaviconRequest(final String url) {
-        (new UiAsyncTask<Void, Void, String>(ThreadUtils.getBackgroundHandler()) {
-            @Override
-            public String doInBackground(Void... params) {
-                return Favicons.getFaviconURLForPageURL(url);
-            }
-
-            @Override
-            public void onPostExecute(String faviconUrl) {
-                JSONObject args = new JSONObject();
-
-                if (faviconUrl != null) {
-                    try {
-                        args.put("url", url);
-                        args.put("faviconUrl", faviconUrl);
-                    } catch (JSONException e) {
-                        Log.w(LOGTAG, "Error building JSON favicon arguments.", e);
-                    }
-                }
-
-                GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Reader:FaviconReturn", args.toString()));
-            }
-        }).execute();
-    }
-
-    void handleClearHistory() {
-        BrowserDB.clearHistory(getContentResolver());
-    }
-
-    public void addTab() { }
-
-    public void addPrivateTab() { }
-
-    public void showNormalTabs() { }
-
-    public void showPrivateTabs() { }
-
-    public void showRemoteTabs() { }
-
-    private void showTabs(TabsPanel.Panel panel) { }
-
-    public void hideTabs() { }
-
-    /**
-     * Close the tab UI indirectly (not as the result of a direct user
-     * action).  This does not force the UI to close; for example in Firefox
-     * tablet mode it will remain open unless the user explicitly closes it.
-     *
-     * @return True if the tab UI was hidden.
-     */
-    public boolean autoHideTabs() { return false; }
-
-    public boolean areTabsShown() { return false; }
-
-    @Override
-    public void handleMessage(String event, JSONObject message) {
-        try {
-            if (event.equals("Toast:Show")) {
-                final String msg = message.getString("message");
-                final JSONObject button = message.optJSONObject("button");
-                if (button != null) {
-                    final String label = button.optString("label");
-                    final String icon = button.optString("icon");
-                    final String id = button.optString("id");
-                    showButtonToast(msg, label, icon, id);
-                } else {
-                    final String duration = message.getString("duration");
-                    showNormalToast(msg, duration);
-                }
-            } else if (event.equals("log")) {
-                // generic log listener
-                final String msg = message.getString("msg");
-                Log.d(LOGTAG, "Log: " + msg);
-            } else if (event.equals("Reader:FaviconRequest")) {
-                final String url = message.getString("url");
-                handleFaviconRequest(url);
-            } else if (event.equals("Gecko:DelayedStartup")) {
-                ThreadUtils.postToBackgroundThread(new UninstallListener.DelayedStartupTask(this));
-            } else if (event.equals("Gecko:Ready")) {
-                mGeckoReadyStartupTimer.stop();
-                geckoConnected();
-
-                // This method is already running on the background thread, so we
-                // know that mHealthRecorder will exist. That doesn't stop us being
-                // paranoid.
-                // This method is cheap, so don't spawn a new runnable.
-                final HealthRecorder rec = mHealthRecorder;
-                if (rec != null) {
-                  rec.recordGeckoStartupTime(mGeckoReadyStartupTimer.getElapsed());
-                }
-            } else if (event.equals("ToggleChrome:Hide")) {
-                toggleChrome(false);
-            } else if (event.equals("ToggleChrome:Show")) {
-                toggleChrome(true);
-            } else if (event.equals("ToggleChrome:Focus")) {
-                focusChrome();
-            } else if (event.equals("DOMFullScreen:Start")) {
-                // Local ref to layerView for thread safety
-                LayerView layerView = mLayerView;
-                if (layerView != null) {
-                    layerView.setFullScreen(true);
-                }
-            } else if (event.equals("DOMFullScreen:Stop")) {
-                // Local ref to layerView for thread safety
-                LayerView layerView = mLayerView;
-                if (layerView != null) {
-                    layerView.setFullScreen(false);
-                }
-            } else if (event.equals("Permissions:Data")) {
-                String host = message.getString("host");
-                JSONArray permissions = message.getJSONArray("permissions");
-                showSiteSettingsDialog(host, permissions);
-            } else if (event.equals("Session:StatePurged")) {
-                onStatePurged();
-            } else if (event.equals("Bookmark:Insert")) {
-                final String url = message.getString("url");
-                final String title = message.getString("title");
-                final Context context = this;
-                ThreadUtils.postToUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        Toast.makeText(context, R.string.bookmark_added, Toast.LENGTH_SHORT).show();
-                        ThreadUtils.postToBackgroundThread(new Runnable() {
-                            @Override
-                            public void run() {
-                                BrowserDB.addBookmark(getContentResolver(), title, url);
-                            }
-                        });
-                    }
-                });
-            } else if (event.equals("Accessibility:Event")) {
-                GeckoAccessibility.sendAccessibilityEvent(message);
-            } else if (event.equals("Accessibility:Ready")) {
-                GeckoAccessibility.updateAccessibilitySettings(this);
-            } else if (event.equals("Shortcut:Remove")) {
-                final String url = message.getString("url");
-                final String origin = message.getString("origin");
-                final String title = message.getString("title");
-                final String type = message.getString("shortcutType");
-                GeckoAppShell.removeShortcut(title, url, origin, type);
-            } else if (event.equals("Share:Text")) {
-                String text = message.getString("text");
-                GeckoAppShell.openUriExternal(text, "text/plain", "", "", Intent.ACTION_SEND, "");
-            } else if (event.equals("Image:SetAs")) {
-                String src = message.getString("url");
-                setImageAs(src);
-            } else if (event.equals("Sanitize:ClearHistory")) {
-                handleClearHistory();
-            } else if (event.equals("Update:Check")) {
-                startService(new Intent(UpdateServiceHelper.ACTION_CHECK_FOR_UPDATE, null, this, UpdateService.class));
-            } else if (event.equals("Update:Download")) {
-                startService(new Intent(UpdateServiceHelper.ACTION_DOWNLOAD_UPDATE, null, this, UpdateService.class));
-            } else if (event.equals("Update:Install")) {
-                startService(new Intent(UpdateServiceHelper.ACTION_APPLY_UPDATE, null, this, UpdateService.class));
-            } else if (event.equals("PrivateBrowsing:Data")) {
-                // null strings return "null" (http://code.google.com/p/android/issues/detail?id=13830)
-                if (message.isNull("session")) {
-                    mPrivateBrowsingSession = null;
-                } else {
-                    mPrivateBrowsingSession = message.getString("session");
-                }
-            } else if (event.equals("Contact:Add")) {                
-                if (!message.isNull("email")) {
-                    Uri contactUri = Uri.parse(message.getString("email"));       
-                    Intent i = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT, contactUri);
-                    startActivity(i);
-                } else if (!message.isNull("phone")) {
-                    Uri contactUri = Uri.parse(message.getString("phone"));       
-                    Intent i = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT, contactUri);
-                    startActivity(i);
-                } else {
-                    // something went wrong.
-                    Log.e(LOGTAG, "Received Contact:Add message with no email nor phone number");
-                }                
-            } else if (event.equals("Intent:GetHandlers")) {
-                Intent intent = GeckoAppShell.getOpenURIIntent(sAppContext, message.optString("url"),
-                    message.optString("mime"), message.optString("action"), message.optString("title"));
-                String[] handlers = GeckoAppShell.getHandlersForIntent(intent);
-                List<String> appList = Arrays.asList(handlers);
-                JSONObject handlersJSON = new JSONObject();
-                handlersJSON.put("apps", new JSONArray(appList));
-                EventDispatcher.sendResponse(message, handlersJSON);
-            } else if (event.equals("Intent:Open")) {
-                GeckoAppShell.openUriExternal(message.optString("url"),
-                    message.optString("mime"), message.optString("packageName"),
-                    message.optString("className"), message.optString("action"), message.optString("title"));
-            } else if (event.equals("Intent:OpenForResult")) {
-                Intent intent = GeckoAppShell.getOpenURIIntent(this,
-                                                               message.optString("url"),
-                                                               message.optString("mime"),
-                                                               message.optString("action"),
-                                                               message.optString("title"));
-                intent.setClassName(message.optString("packageName"), message.optString("className"));
-
-                intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
-
-                final JSONObject originalMessage = message;
-                ActivityHandlerHelper.startIntentForActivity(this,
-                                                             intent,
-                        new ActivityResultHandler() {
-                            @Override
-                            public void onActivityResult (int resultCode, Intent data) {
-                                JSONObject response = new JSONObject();
-
-                                try {
-                                    if (data != null) {
-                                        response.put("extras", bundleToJSON(data.getExtras()));
-                                    }
-                                    response.put("resultCode", resultCode);
-                                } catch (JSONException e) {
-                                    Log.w(LOGTAG, "Error building JSON response.", e);
-                                }
-
-                                EventDispatcher.sendResponse(originalMessage, response);
-                            }
-                        });
-            } else if (event.equals("Locale:Set")) {
-                setLocale(message.getString("locale"));
-            } else if (event.equals("NativeApp:IsDebuggable")) {
-                JSONObject ret = new JSONObject();
-                ret.put("isDebuggable", getIsDebuggable() ? "true" : "false");
-                EventDispatcher.sendResponse(message, ret);
-            } else if (event.equals("SystemUI:Visibility")) {
-                setSystemUiVisible(message.getBoolean("visible"));
-            }
-        } catch (Exception e) {
-            Log.e(LOGTAG, "Exception handling message \"" + event + "\":", e);
-        }
-    }
-
-    void onStatePurged() { }
-
-    /**
-     * @param aPermissions
-     *        Array of JSON objects to represent site permissions.
-     *        Example: { type: "offline-app", setting: "Store Offline Data", value: "Allow" }
-     */
-    private void showSiteSettingsDialog(String aHost, JSONArray aPermissions) {
-        final AlertDialog.Builder builder = new AlertDialog.Builder(this);
-
-        View customTitleView = getLayoutInflater().inflate(R.layout.site_setting_title, null);
-        ((TextView) customTitleView.findViewById(R.id.title)).setText(R.string.site_settings_title);
-        ((TextView) customTitleView.findViewById(R.id.host)).setText(aHost);
-        builder.setCustomTitle(customTitleView);
-
-        // If there are no permissions to clear, show the user a message about that.
-        // In the future, we want to disable the menu item if there are no permissions to clear.
-        if (aPermissions.length() == 0) {
-            builder.setMessage(R.string.site_settings_no_settings);
-        } else {
-
-            ArrayList <HashMap<String, String>> itemList = new ArrayList <HashMap<String, String>>();
-            for (int i = 0; i < aPermissions.length(); i++) {
-                try {
-                    JSONObject permObj = aPermissions.getJSONObject(i);
-                    HashMap<String, String> map = new HashMap<String, String>();
-                    map.put("setting", permObj.getString("setting"));
-                    map.put("value", permObj.getString("value"));
-                    itemList.add(map);
-                } catch (JSONException e) {
-                    Log.w(LOGTAG, "Exception populating settings items.", e);
-                }
-            }
-
-            // setMultiChoiceItems doesn't support using an adapter, so we're creating a hack with
-            // setSingleChoiceItems and changing the choiceMode below when we create the dialog
-            builder.setSingleChoiceItems(new SimpleAdapter(
-                GeckoApp.this,
-                itemList,
-                R.layout.site_setting_item,
-                new String[] { "setting", "value" },
-                new int[] { R.id.setting, R.id.value }
-                ), -1, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int id) { }
-                });
-
-            builder.setPositiveButton(R.string.site_settings_clear, new DialogInterface.OnClickListener() {
-                @Override
-                public void onClick(DialogInterface dialog, int id) {
-                    ListView listView = ((AlertDialog) dialog).getListView();
-                    SparseBooleanArray checkedItemPositions = listView.getCheckedItemPositions();
-
-                    // An array of the indices of the permissions we want to clear
-                    JSONArray permissionsToClear = new JSONArray();
-                    for (int i = 0; i < checkedItemPositions.size(); i++)
-                        if (checkedItemPositions.get(i))
-                            permissionsToClear.put(i);
-
-                    GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent(
-                        "Permissions:Clear", permissionsToClear.toString()));
-                }
-            });
-        }
-
-        builder.setNegativeButton(R.string.site_settings_cancel, new DialogInterface.OnClickListener(){
-            @Override
-            public void onClick(DialogInterface dialog, int id) {
-                dialog.cancel();
-            }
-        });
-
-        ThreadUtils.postToUiThread(new Runnable() {
-            @Override
-            public void run() {
-                Dialog dialog = builder.create();
-                dialog.show();
-
-                ListView listView = ((AlertDialog) dialog).getListView();
-                if (listView != null) {
-                    listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
-                    int listSize = listView.getAdapter().getCount();
-                    for (int i = 0; i < listSize; i++)
-                        listView.setItemChecked(i, true);
-                }
-            }
-        });
-    }
-
-    public void showToast(final int resId, final int duration) {
-        ThreadUtils.postToUiThread(new Runnable() {
-            @Override
-            public void run() {
-                Toast.makeText(GeckoApp.this, resId, duration).show();
-            }
-        });
-    }
-
-    public void showNormalToast(final String message, final String duration) {
-        ThreadUtils.postToUiThread(new Runnable() {
-            @Override
-            public void run() {
-                Toast toast;
-                if (duration.equals("long")) {
-                    toast = Toast.makeText(GeckoApp.this, message, Toast.LENGTH_LONG);
-                } else {
-                    toast = Toast.makeText(GeckoApp.this, message, Toast.LENGTH_SHORT);
-                }
-                toast.show();
-            }
-        });
-    }
-
-    protected ButtonToast getButtonToast() {
-        if (mToast != null) {
-            return mToast;
-        }
-
-        ViewStub toastStub = (ViewStub) findViewById(R.id.toast_stub);
-        mToast = new ButtonToast(toastStub.inflate());
-
-        return mToast;
-    }
-
-    void showButtonToast(final String message, final String buttonText,
-                         final String buttonIcon, final String buttonId) {
-        BitmapUtils.getDrawable(GeckoApp.this, buttonIcon, new BitmapUtils.BitmapLoader() {
-            @Override
-            public void onBitmapFound(final Drawable d) {
-                getButtonToast().show(false, message, buttonText, d, new ButtonToast.ToastListener() {
-                    @Override
-                    public void onButtonClicked() {
-                        GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Toast:Click", buttonId));
-                    }
-
-                    @Override
-                    public void onToastHidden(ButtonToast.ReasonHidden reason) {
-                        if (reason == ButtonToast.ReasonHidden.TIMEOUT) {
-                            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Toast:Hidden", buttonId));
-                        }
-                    }
-                });
-            }
-        });
-    }
-
-    private JSONObject bundleToJSON(Bundle bundle) {
-        JSONObject json = new JSONObject();
-        if (bundle == null) {
-            return json;
-        }
-
-        for (String key : bundle.keySet()) {
-            try {
-                json.put(key, bundle.get(key));
-            } catch (JSONException e) {
-                Log.w(LOGTAG, "Error building JSON response.", e);
-            }
-        }
-
-        return json;
-    }
-
-    private void addFullScreenPluginView(View view) {
-        if (mFullScreenPluginView != null) {
-            Log.w(LOGTAG, "Already have a fullscreen plugin view");
-            return;
-        }
-
-        setFullScreen(true);
-
-        view.setWillNotDraw(false);
-        if (view instanceof SurfaceView) {
-            ((SurfaceView) view).setZOrderOnTop(true);
-        }
-
-        mFullScreenPluginContainer = new FullScreenHolder(this);
-
-        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(
-                            ViewGroup.LayoutParams.FILL_PARENT,
-                            ViewGroup.LayoutParams.FILL_PARENT,
-                            Gravity.CENTER);
-        mFullScreenPluginContainer.addView(view, layoutParams);
-
-
-        FrameLayout decor = (FrameLayout)getWindow().getDecorView();
-        decor.addView(mFullScreenPluginContainer, layoutParams);
-
-        mFullScreenPluginView = view;
-    }
-
-    public void addPluginView(final View view, final RectF rect, final boolean isFullScreen) {
-        ThreadUtils.postToUiThread(new Runnable() {
-            @Override
-            public void run() {
-                Tabs tabs = Tabs.getInstance();
-                Tab tab = tabs.getSelectedTab();
-
-                if (isFullScreen) {
-                    addFullScreenPluginView(view);
-                    return;
-                }
-
-                PluginLayer layer = (PluginLayer) tab.getPluginLayer(view);
-                if (layer == null) {
-                    layer = new PluginLayer(view, rect, mLayerView.getRenderer().getMaxTextureSize());
-                    tab.addPluginLayer(view, layer);
-                } else {
-                    layer.reset(rect);
-                    layer.setVisible(true);
-                }
-
-                mLayerView.addLayer(layer);
-            }
-        });
-    }
-
-    private void removeFullScreenPluginView(View view) {
-        if (mFullScreenPluginView == null) {
-            Log.w(LOGTAG, "Don't have a fullscreen plugin view");
-            return;
-        }
-
-        if (mFullScreenPluginView != view) {
-            Log.w(LOGTAG, "Passed view is not the current full screen view");
-            return;
-        }
-
-        mFullScreenPluginContainer.removeView(mFullScreenPluginView);
-
-        // We need do do this on the next iteration in order to avoid
-        // a deadlock, see comment below in FullScreenHolder
-        ThreadUtils.postToUiThread(new Runnable() {
-            @Override
-            public void run() {
-                mLayerView.showSurface();
-            }
-        });
-
-        FrameLayout decor = (FrameLayout)getWindow().getDecorView();
-        decor.removeView(mFullScreenPluginContainer);
-
-        mFullScreenPluginView = null;
-
-        GeckoScreenOrientation.getInstance().unlock();
-        setFullScreen(false);
-    }
-
-    public void removePluginView(final View view, final boolean isFullScreen) {
-        ThreadUtils.postToUiThread(new Runnable() {
-            @Override
-            public void run() {
-                Tabs tabs = Tabs.getInstance();
-                Tab tab = tabs.getSelectedTab();
-
-                if (isFullScreen) {
-                    removeFullScreenPluginView(view);
-                    return;
-                }
-
-                PluginLayer layer = (PluginLayer) tab.removePluginLayer(view);
-                if (layer != null) {
-                    layer.destroy();
-                }
-            }
-        });
-    }
-
-    // This method starts downloading an image synchronously and displays the Chooser activity to set the image as wallpaper.
-    private void setImageAs(final String aSrc) {
-        boolean isDataURI = aSrc.startsWith("data:");
-        Bitmap image = null;
-        InputStream is = null;
-        ByteArrayOutputStream os = null;
-        try {
-            if (isDataURI) {
-                int dataStart = aSrc.indexOf(",");
-                byte[] buf = Base64.decode(aSrc.substring(dataStart+1), Base64.DEFAULT);
-                image = BitmapUtils.decodeByteArray(buf);
-            } else {
-                int byteRead;
-                byte[] buf = new byte[4192];
-                os = new ByteArrayOutputStream();
-                URL url = new URL(aSrc);
-                is = url.openStream();
-
-                // Cannot read from same stream twice. Also, InputStream from
-                // URL does not support reset. So converting to byte array.
-
-                while((byteRead = is.read(buf)) != -1) {
-                    os.write(buf, 0, byteRead);
-                }
-                byte[] imgBuffer = os.toByteArray();
-                image = BitmapUtils.decodeByteArray(imgBuffer);
-            }
-            if (image != null) {
-                String path = Media.insertImage(getContentResolver(),image, null, null);
-                final Intent intent = new Intent(Intent.ACTION_ATTACH_DATA);
-                intent.addCategory(Intent.CATEGORY_DEFAULT);
-                intent.setData(Uri.parse(path));
-
-                // Removes the image from storage once the chooser activity ends.
-                ActivityHandlerHelper.startIntentForActivity(this,
-                                                            Intent.createChooser(intent, sAppContext.getString(R.string.set_image_chooser_title)),
-                                                            new ActivityResultHandler() {
-                                                                @Override
-                                                                public void onActivityResult (int resultCode, Intent data) {
-                                                                    getContentResolver().delete(intent.getData(), null, null);
-                                                                }
-                                                            });
-            } else {
-                Toast.makeText(sAppContext, R.string.set_image_fail, Toast.LENGTH_SHORT).show();
-            }
-        } catch(OutOfMemoryError ome) {
-            Log.e(LOGTAG, "Out of Memory when converting to byte array", ome);
-        } catch(IOException ioe) {
-            Log.e(LOGTAG, "I/O Exception while setting wallpaper", ioe);
-        } finally {
-            if (is != null) {
-                try {
-                    is.close();
-                } catch(IOException ioe) {
-                    Log.w(LOGTAG, "I/O Exception while closing stream", ioe);
-                }
-            }
-            if (os != null) {
-                try {
-                    os.close();
-                } catch(IOException ioe) {
-                    Log.w(LOGTAG, "I/O Exception while closing stream", ioe);
-                }
-            }
-        }
-    }
-
-    private int getBitmapSampleSize(BitmapFactory.Options options, int idealWidth, int idealHeight) {
-        int width = options.outWidth;
-        int height = options.outHeight;
-        int inSampleSize = 1;
-        if (height > idealHeight || width > idealWidth) {
-            if (width > height) {
-                inSampleSize = Math.round((float)height / (float)idealHeight);
-            } else {
-                inSampleSize = Math.round((float)width / (float)idealWidth);
-            }
-        }
-        return inSampleSize;
-    }
-
-    private void hidePluginLayer(Layer layer) {
-        LayerView layerView = mLayerView;
-        layerView.removeLayer(layer);
-        layerView.requestRender();
-    }
-
-    private void showPluginLayer(Layer layer) {
-        LayerView layerView = mLayerView;
-        layerView.addLayer(layer);
-        layerView.requestRender();
-    }
-
-    public void requestRender() {
-        mLayerView.requestRender();
-    }
-    
-    public void hidePlugins(Tab tab) {
-        for (Layer layer : tab.getPluginLayers()) {
-            if (layer instanceof PluginLayer) {
-                ((PluginLayer) layer).setVisible(false);
-            }
-
-            hidePluginLayer(layer);
-        }
-
-        requestRender();
-    }
-
-    public void showPlugins() {
-        Tabs tabs = Tabs.getInstance();
-        Tab tab = tabs.getSelectedTab();
-
-        showPlugins(tab);
-    }
-
-    public void showPlugins(Tab tab) {
-        for (Layer layer : tab.getPluginLayers()) {
-            showPluginLayer(layer);
-
-            if (layer instanceof PluginLayer) {
-                ((PluginLayer) layer).setVisible(true);
-            }
-        }
-
-        requestRender();
-    }
-
-    public void setFullScreen(final boolean fullscreen) {
-        ThreadUtils.postToUiThread(new Runnable() {
-            @Override
-            public void run() {
-                // Hide/show the system notification bar
-                Window window = getWindow();
-                window.setFlags(fullscreen ?
-                                WindowManager.LayoutParams.FLAG_FULLSCREEN : 0,
-                                WindowManager.LayoutParams.FLAG_FULLSCREEN);
-
-                if (Build.VERSION.SDK_INT >= 11)
-                    window.getDecorView().setSystemUiVisibility(fullscreen ? 1 : 0);
-            }
-        });
-    }
-
-    /**
-     * Check and start the Java profiler if MOZ_PROFILER_STARTUP env var is specified
-     **/
-    protected void earlyStartJavaSampler(Intent intent)
-    {
-        String env = intent.getStringExtra("env0");
-        for (int i = 1; env != null; i++) {
-            if (env.startsWith("MOZ_PROFILER_STARTUP=")) {
-                if (!env.endsWith("=")) {
-                    GeckoJavaSampler.start(10, 1000);
-                    Log.d(LOGTAG, "Profiling Java on startup");
-                }
-                break;
-            }
-            env = intent.getStringExtra("env" + i);
-        }
-    }
-
-    /**
-     * Called when the activity is first created.
-     *
-     * Here we initialize all of our profile settings, Firefox Health Report,
-     * and other one-shot constructions.
-     **/
-    @Override
-    public void onCreate(Bundle savedInstanceState)
-    {
-        GeckoAppShell.registerGlobalExceptionHandler();
-
-        // Enable Android Strict Mode for developers' local builds (the "default" channel).
-        if ("default".equals(AppConstants.MOZ_UPDATE_CHANNEL)) {
-            enableStrictMode();
-        }
-
-        // The clock starts...now. Better hurry!
-        mJavaUiStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_JAVAUI");
-        mGeckoReadyStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_GECKOREADY");
-
-        Intent intent = getIntent();
-        String args = intent.getStringExtra("args");
-        earlyStartJavaSampler(intent);
-
-        if (mProfile == null) {
-            String profileName = null;
-            String profilePath = null;
-            if (args != null) {
-                if (args.contains("-P")) {
-                    Pattern p = Pattern.compile("(?:-P\\s*)(\\w*)(\\s*)");
-                    Matcher m = p.matcher(args);
-                    if (m.find()) {
-                        profileName = m.group(1);
-                    }
-                }
-
-                if (args.contains("-profile")) {
-                    Pattern p = Pattern.compile("(?:-profile\\s*)(\\S*)(\\s*)");
-                    Matcher m = p.matcher(args);
-                    if (m.find()) {
-                        profilePath =  m.group(1);
-                    }
-                    if (profileName == null) {
-                        try {
-                            profileName = getDefaultProfileName();
-                        } catch (NoMozillaDirectoryException e) {
-                            Log.wtf(LOGTAG, "Unable to fetch default profile name!", e);
-                            // There's nothing at all we can do now. If the Mozilla directory
-                            // didn't exist, then we're screwed.
-                            // Crash here so we can fix the bug.
-                            throw new RuntimeException(e);
-                        }
-                        if (profileName == null)
-                            profileName = GeckoProfile.DEFAULT_PROFILE;
-                    }
-                    GeckoProfile.sIsUsingCustomProfile = true;
-                }
-
-                if (profileName != null || profilePath != null) {
-                    mProfile = GeckoProfile.get(this, profileName, profilePath);
-                }
-            }
-        }
-
-        BrowserDB.initialize(getProfile().getName());
-
-        // Workaround for <http://code.google.com/p/android/issues/detail?id=20915>.
-        try {
-            Class.forName("android.os.AsyncTask");
-        } catch (ClassNotFoundException e) {}
-
-        MemoryMonitor.getInstance().init(getApplicationContext());
-
-        sAppContext = this;
-        GeckoAppShell.setContextGetter(this);
-        GeckoAppShell.setGeckoInterface(this);
-        ThreadUtils.setUiThread(Thread.currentThread(), new Handler());
-
-        Tabs.getInstance().attachToContext(this);
-        try {
-            Favicons.attachToContext(this);
-        } catch (Exception e) {
-            Log.e(LOGTAG, "Exception starting favicon cache. Corrupt resources?", e);
-        }
-
-        // Did the OS locale change while we were backgrounded? If so,
-        // we need to die so that Gecko will re-init add-ons that touch
-        // the UI.
-        // This is using a sledgehammer to crack a nut, but it'll do for
-        // now.
-        if (LocaleManager.systemLocaleDidChange()) {
-            Log.i(LOGTAG, "System locale changed. Restarting.");
-            doRestart();
-            GeckoAppShell.systemExit();
-            return;
-        }
-
-        if (GeckoThread.isCreated()) {
-            // This happens when the GeckoApp activity is destroyed by Android
-            // without killing the entire application (see Bug 769269).
-            mIsRestoringActivity = true;
-            Telemetry.HistogramAdd("FENNEC_RESTORING_ACTIVITY", 1);
-        }
-
-        // Fix for Bug 830557 on Tegra boards running Froyo.
-        // This fix must be done before doing layout.
-        // Assume the bug is fixed in Gingerbread and up.
-        if (Build.VERSION.SDK_INT < 9) {
-            try {
-                Class<?> inputBindResultClass =
-                    Class.forName("com.android.internal.view.InputBindResult");
-                java.lang.reflect.Field creatorField =
-                    inputBindResultClass.getField("CREATOR");
-                Log.i(LOGTAG, "froyo startup fix: " + String.valueOf(creatorField.get(null)));
-            } catch (Exception e) {
-                Log.w(LOGTAG, "froyo startup fix failed", e);
-            }
-        }
-
-        Bundle stateBundle = getIntent().getBundleExtra(EXTRA_STATE_BUNDLE);
-        if (stateBundle != null) {
-            // Use the state bundle if it was given as an intent extra. This is
-            // only intended to be used internally via Robocop, so a boolean
-            // is read from a private shared pref to prevent other apps from
-            // injecting states.
-            SharedPreferences prefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
-            if (prefs.getBoolean(PREFS_ALLOW_STATE_BUNDLE, false)) {
-                Log.i(LOGTAG, "Restoring state from intent bundle");
-                prefs.edit().remove(PREFS_ALLOW_STATE_BUNDLE).commit();
-                savedInstanceState = stateBundle;
-            }
-        } else if (savedInstanceState != null) {
-            // Bug 896992 - This intent has already been handled; reset the intent.
-            setIntent(new Intent(Intent.ACTION_MAIN));
-        }
-
-        super.onCreate(savedInstanceState);
-
-        GeckoScreenOrientation.getInstance().update(getResources().getConfiguration().orientation);
-
-        setContentView(getLayout());
-
-        // Set up Gecko layout.
-        mGeckoLayout = (RelativeLayout) findViewById(R.id.gecko_layout);
-        mMainLayout = (RelativeLayout) findViewById(R.id.main_layout);
-
-        // Determine whether we should restore tabs.
-        mShouldRestore = getSessionRestoreState(savedInstanceState);
-        if (mShouldRestore && savedInstanceState != null) {
-            boolean wasInBackground =
-                savedInstanceState.getBoolean(SAVED_STATE_IN_BACKGROUND, false);
-
-            // Don't log OOM-kills if only one activity was destroyed. (For example
-            // from "Don't keep activities" on ICS)
-            if (!wasInBackground && !mIsRestoringActivity) {
-                Telemetry.HistogramAdd("FENNEC_WAS_KILLED", 1);
-            }
-
-            mPrivateBrowsingSession = savedInstanceState.getString(SAVED_STATE_PRIVATE_SESSION);
-        }
-
-        // Perform background initialization.
-        ThreadUtils.postToBackgroundThread(new Runnable() {
-            @Override
-            public void run() {
-                final SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
-
-                // Wait until now to set this, because we'd rather throw an exception than 
-                // have a caller of LocaleManager regress startup.
-                LocaleManager.setContextGetter(GeckoApp.this);
-                LocaleManager.initialize();
-
-                SessionInformation previousSession = SessionInformation.fromSharedPrefs(prefs);
-                if (previousSession.wasKilled()) {
-                    Telemetry.HistogramAdd("FENNEC_WAS_KILLED", 1);
-                }
-
-                SharedPreferences.Editor editor = prefs.edit();
-                editor.putBoolean(GeckoApp.PREFS_OOM_EXCEPTION, false);
-
-                // Put a flag to check if we got a normal `onSaveInstanceState`
-                // on exit, or if we were suddenly killed (crash or native OOM).
-                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
-
-                editor.commit();
-
-                // The lifecycle of mHealthRecorder is "shortly after onCreate"
-                // through "onDestroy" -- essentially the same as the lifecycle
-                // of the activity itself.
-                final String profilePath = getProfile().getDir().getAbsolutePath();
-                final EventDispatcher dispatcher = GeckoAppShell.getEventDispatcher();
-                Log.i(LOGTAG, "Creating HealthRecorder.");
-
-                final String osLocale = Locale.getDefault().toString();
-                String appLocale = LocaleManager.getAndApplyPersistedLocale();
-                Log.d(LOGTAG, "OS locale is " + osLocale + ", app locale is " + appLocale);
-
-                if (appLocale == null) {
-                    appLocale = osLocale;
-                }
-
-                mHealthRecorder = GeckoApp.this.createHealthRecorder(GeckoApp.this,
-                                                                     profilePath,
-                                                                     dispatcher,
-                                                                     osLocale,
-                                                                     appLocale,
-                                                                     previousSession);
-
-                final String uiLocale = appLocale;
-                ThreadUtils.postToUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        GeckoApp.this.onLocaleReady(uiLocale);
-                    }
-                });
-            }
-        });
-
-        GeckoAppShell.setNotificationClient(makeNotificationClient());
-        NotificationHelper.init(getApplicationContext());
-    }
-
-    /**
-     * At this point, the resource system and the rest of the browser are
-     * aware of the locale.
-     *
-     * Now we can display strings!
-     */
-    @Override
-    public void onLocaleReady(final String locale) {
-        if (!ThreadUtils.isOnUiThread()) {
-            throw new RuntimeException("onLocaleReady must always be called from the UI thread.");
-        }
-
-        // The URL bar hint needs to be populated.
-        TextView urlBar = (TextView) findViewById(R.id.url_bar_title);
-        if (urlBar == null) {
-            return;
-        }
-        final String hint = getResources().getString(R.string.url_bar_default_text);
-        urlBar.setHint(hint);
-
-        // Allow onConfigurationChanged to take care of the rest.
-        onConfigurationChanged(getResources().getConfiguration());
-    }
-
-    protected void initializeChrome() {
-        mDoorHangerPopup = new DoorHangerPopup(this);
-        mPluginContainer = (AbsoluteLayout) findViewById(R.id.plugin_container);
-        mFormAssistPopup = (FormAssistPopup) findViewById(R.id.form_assist_popup);
-
-        if (mCameraView == null) {
-            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
-                mCameraView = new SurfaceView(this);
-                ((SurfaceView)mCameraView).getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
-            } else {
-                mCameraView = new TextureView(this);
-            }
-        }
-
-        if (mLayerView == null) {
-            LayerView layerView = (LayerView) findViewById(R.id.layer_view);
-            layerView.initializeView(GeckoAppShell.getEventDispatcher());
-            mLayerView = layerView;
-            GeckoAppShell.setLayerView(layerView);
-            // bind the GeckoEditable instance to the new LayerView
-            GeckoAppShell.notifyIMEContext(GeckoEditableListener.IME_STATE_DISABLED, "", "", "");
-        }
-	    setFullScreen(true);
-    }
-
-    /**
-     * Loads the initial tab at Fennec startup.
-     *
-     * If Fennec was opened with an external URL, that URL will be loaded.
-     * Otherwise, unless there was a session restore, the default URL
-     * (about:home) be loaded.
-     *
-     * @param url External URL to load, or null to load the default URL
-     */
-    protected void loadStartupTab(String url) {
-        if (url == null) {
-            if (!mShouldRestore) {
-                // Show about:home if we aren't restoring previous session and
-                // there's no external URL.
-                Tabs.getInstance().loadUrl(AboutPages.HOME, Tabs.LOADURL_NEW_TAB);
-            }
-        } else {
-            // If given an external URL, load it
-            int flags = Tabs.LOADURL_NEW_TAB | Tabs.LOADURL_USER_ENTERED | Tabs.LOADURL_EXTERNAL;
-            Tabs.getInstance().loadUrl(url, flags);
-        }
-    }
-
-    private void initialize() {
-        mInitialized = true;
-
-        Intent intent = getIntent();
-        String action = intent.getAction();
-
-        String passedUri = null;
-        final String uri = getURIFromIntent(intent);
-        if (!TextUtils.isEmpty(uri)) {
-            passedUri = uri;
-        }
-
-        final boolean isExternalURL = passedUri != null &&
-                                      !AboutPages.isAboutHome(passedUri);
-        StartupAction startupAction;
-        if (isExternalURL) {
-            startupAction = StartupAction.URL;
-        } else {
-            startupAction = StartupAction.NORMAL;
-        }
-
-        // Start migrating as early as possible, can do this in
-        // parallel with Gecko load.
-        checkMigrateProfile();
-
-        Uri data = intent.getData();
-        if (data != null && "http".equals(data.getScheme())) {
-            startupAction = StartupAction.PREFETCH;
-            ThreadUtils.postToBackgroundThread(new PrefetchRunnable(data.toString()));
-        }
-
-        Tabs.registerOnTabsChangedListener(this);
-
-        initializeChrome();
-
-        // If we are doing a restore, read the session data and send it to Gecko
-        if (!mIsRestoringActivity) {
-            String restoreMessage = null;
-            if (mShouldRestore) {
-                try {
-                    // restoreSessionTabs() will create simple tab stubs with the
-                    // URL and title for each page, but we also need to restore
-                    // session history. restoreSessionTabs() will inject the IDs
-                    // of the tab stubs into the JSON data (which holds the session
-                    // history). This JSON data is then sent to Gecko so session
-                    // history can be restored for each tab.
-                    restoreMessage = restoreSessionTabs(isExternalURL);
-                } catch (SessionRestoreException e) {
-                    // If restore failed, do a normal startup
-                    Log.e(LOGTAG, "An error occurred during restore", e);
-                    mShouldRestore = false;
-                }
-            }
-
-            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Session:Restore", restoreMessage));
-        }
-
-        // External URLs should always be loaded regardless of whether Gecko is
-        // already running.
-        if (isExternalURL) {
-            loadStartupTab(passedUri);
-        } else if (!mIsRestoringActivity) {
-            loadStartupTab(null);
-        }
-
-        // We now have tab stubs from the last session. Any future tabs should
-        // be animated.
-        Tabs.getInstance().notifyListeners(null, Tabs.TabEvents.RESTORED);
-
-        // If we're not restoring, move the session file so it can be read for
-        // the last tabs section.
-        if (!mShouldRestore) {
-            getProfile().moveSessionFile();
-        }
-
-        Telemetry.HistogramAdd("FENNEC_STARTUP_GECKOAPP_ACTION", startupAction.ordinal());
-
-        if (!mIsRestoringActivity) {
-            GeckoThread.setArgs(intent.getStringExtra("args"));
-            GeckoThread.setAction(intent.getAction());
-            GeckoThread.setUri(passedUri);
-        }
-        if (!ACTION_DEBUG.equals(action) &&
-            GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.Launching, GeckoThread.LaunchState.Launched)) {
-            GeckoThread.createAndStart();
-        } else if (ACTION_DEBUG.equals(action) &&
-            GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.Launching, GeckoThread.LaunchState.WaitForDebugger)) {
-            ThreadUtils.getUiHandler().postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    GeckoThread.setLaunchState(GeckoThread.LaunchState.Launching);
-                    GeckoThread.createAndStart();
-                }
-            }, 1000 * 5 /* 5 seconds */);
-        }
-
-        // Check if launched from data reporting notification.
-        if (ACTION_LAUNCH_SETTINGS.equals(action)) {
-            Intent settingsIntent = new Intent(GeckoApp.this, GeckoPreferences.class);
-            // Copy extras.
-            settingsIntent.putExtras(intent);
-            startActivity(settingsIntent);
-        }
-
-        //app state callbacks
-        mAppStateListeners = new LinkedList<GeckoAppShell.AppStateListener>();
-
-        //register for events
-        registerEventListener("log");
-        registerEventListener("Reader:ListCountRequest");
-        registerEventListener("Reader:ListStatusRequest");
-        registerEventListener("Reader:Added");
-        registerEventListener("Reader:Removed");
-        registerEventListener("Reader:Share");
-        registerEventListener("Reader:FaviconRequest");
-        registerEventListener("onCameraCapture");
-        registerEventListener("Gecko:Ready");
-        registerEventListener("Gecko:DelayedStartup");
-        registerEventListener("Toast:Show");
-        registerEventListener("DOMFullScreen:Start");
-        registerEventListener("DOMFullScreen:Stop");
-        registerEventListener("ToggleChrome:Hide");
-        registerEventListener("ToggleChrome:Show");
-        registerEventListener("ToggleChrome:Focus");
-        registerEventListener("Permissions:Data");
-        registerEventListener("Session:StatePurged");
-        registerEventListener("Bookmark:Insert");
-        registerEventListener("Accessibility:Event");
-        registerEventListener("Accessibility:Ready");
-        registerEventListener("Shortcut:Remove");
-        registerEventListener("Share:Text");
-        registerEventListener("Image:SetAs");
-        registerEventListener("Sanitize:ClearHistory");
-        registerEventListener("Update:Check");
-        registerEventListener("Update:Download");
-        registerEventListener("Update:Install");
-        registerEventListener("PrivateBrowsing:Data");
-        registerEventListener("Contact:Add");
-        registerEventListener("Intent:Open");
-        registerEventListener("Intent:OpenForResult");
-        registerEventListener("Intent:GetHandlers");
-        registerEventListener("Locale:Set");
-        registerEventListener("NativeApp:IsDebuggable");
-        registerEventListener("SystemUI:Visibility");
-
-        EventListener.registerEvents();
-
-        if (SmsManager.getInstance() != null) {
-          SmsManager.getInstance().start();
-        }
-
-        mContactService = new ContactService(GeckoAppShell.getEventDispatcher(), this);
-
-        mPromptService = new PromptService(this);
-
-        mTextSelection = new TextSelection((TextSelectionHandle) findViewById(R.id.start_handle),
-                                           (TextSelectionHandle) findViewById(R.id.middle_handle),
-                                           (TextSelectionHandle) findViewById(R.id.end_handle),
-                                           GeckoAppShell.getEventDispatcher(),
-                                           this);
-
-        PrefsHelper.getPref("app.update.autodownload", new PrefsHelper.PrefHandlerBase() {
-            @Override public void prefValue(String pref, String value) {
-                UpdateServiceHelper.registerForUpdates(GeckoApp.this, value);
-            }
-        });
-
-        PrefsHelper.getPref("app.geo.reportdata", new PrefsHelper.PrefHandlerBase() {
-            @Override public void prefValue(String pref, int value) {
-                if (value == 1)
-                    mShouldReportGeoData = true;
-                else
-                    mShouldReportGeoData = false;
-            }
-        });
-
-        // Trigger the completion of the telemetry timer that wraps activity startup,
-        // then grab the duration to give to FHR.
-        mJavaUiStartupTimer.stop();
-        final long javaDuration = mJavaUiStartupTimer.getElapsed();
-
-        ThreadUtils.getBackgroundHandler().postDelayed(new Runnable() {
-            @Override
-            public void run() {
-                final HealthRecorder rec = mHealthRecorder;
-                if (rec != null) {
-                    rec.recordJavaStartupTime(javaDuration);
-                }
-
-                // Record our launch time for the announcements service
-                // to use in assessing inactivity.
-                final Context context = GeckoApp.this;
-                AnnouncementsBroadcastService.recordLastLaunch(context);
-
-                // Kick off our background services. We do this by invoking the broadcast
-                // receiver, which uses the system alarm infrastructure to perform tasks at
-                // intervals.
-                GeckoPreferences.broadcastAnnouncementsPref(context);
-                GeckoPreferences.broadcastHealthReportUploadPref(context);
-                if (!GeckoThread.checkLaunchState(GeckoThread.LaunchState.Launched)) {
-                    return;
-                }
-            }
-        }, 50);
-
-        if (mIsRestoringActivity) {
-            GeckoThread.setLaunchState(GeckoThread.LaunchState.GeckoRunning);
-            Tab selectedTab = Tabs.getInstance().getSelectedTab();
-            if (selectedTab != null)
-                Tabs.getInstance().notifyListeners(selectedTab, Tabs.TabEvents.SELECTED);
-            geckoConnected();
-            GeckoAppShell.setLayerClient(mLayerView.getLayerClient());
-            GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Viewport:Flush", null));
-        }
-
-        if (ACTION_ALERT_CALLBACK.equals(action)) {
-            processAlertCallback(intent);
-        }
-    }
-
-    private String restoreSessionTabs(final boolean isExternalURL) throws SessionRestoreException {
-        try {
-            String sessionString = getProfile().readSessionFile(false);
-            if (sessionString == null) {
-                throw new SessionRestoreException("Could not read from session file");
-            }
-
-            // If we are doing an OOM restore, parse the session data and
-            // stub the restored tabs immediately. This allows the UI to be
-            // updated before Gecko has restored.
-            if (mShouldRestore) {
-                final JSONArray tabs = new JSONArray();
-                SessionParser parser = new SessionParser() {
-                    @Override
-                    public void onTabRead(SessionTab sessionTab) {
-                        JSONObject tabObject = sessionTab.getTabObject();
-
-                        int flags = Tabs.LOADURL_NEW_TAB;
-                        flags |= ((isExternalURL || !sessionTab.isSelected()) ? Tabs.LOADURL_DELAY_LOAD : 0);
-                        flags |= (tabObject.optBoolean("desktopMode") ? Tabs.LOADURL_DESKTOP : 0);
-                        flags |= (tabObject.optBoolean("isPrivate") ? Tabs.LOADURL_PRIVATE : 0);
-
-                        Tab tab = Tabs.getInstance().loadUrl(sessionTab.getUrl(), flags);
-                        tab.updateTitle(sessionTab.getTitle());
-
-                        try {
-                            tabObject.put("tabId", tab.getId());
-                        } catch (JSONException e) {
-                            Log.e(LOGTAG, "JSON error", e);
-                        }
-                        tabs.put(tabObject);
-                    }
-                };
-
-                if (mPrivateBrowsingSession == null) {
-                    parser.parse(sessionString);
-                } else {
-                    parser.parse(sessionString, mPrivateBrowsingSession);
-                }
-
-                if (tabs.length() > 0) {
-                    sessionString = new JSONObject().put("windows", new JSONArray().put(new JSONObject().put("tabs", tabs))).toString();
-                } else {
-                    throw new SessionRestoreException("No tabs could be read from session file");
-                }
-            }
-
-            JSONObject restoreData = new JSONObject();
-            restoreData.put("sessionString", sessionString);
-            return restoreData.toString();
-
-        } catch (JSONException e) {
-            throw new SessionRestoreException(e);
-        }
-    }
-
-    public GeckoProfile getProfile() {
-        // fall back to default profile if we didn't load a specific one
-        if (mProfile == null) {
-            mProfile = GeckoProfile.get(this);
-        }
-        return mProfile;
-    }
-
-    /**
-     * Determine whether the session should be restored.
-     *
-     * @param savedInstanceState Saved instance state given to the activity
-     * @return                   Whether to restore
-     */
-    protected boolean getSessionRestoreState(Bundle savedInstanceState) {
-        final SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
-        boolean shouldRestore = false;
-
-        final int versionCode = getVersionCode();
-        if (prefs.getInt(PREFS_VERSION_CODE, 0) != versionCode) {
-            // If the version has changed, the user has done an upgrade, so restore
-            // previous tabs.
-            ThreadUtils.postToBackgroundThread(new Runnable() {
-                @Override
-                public void run() {
-                    prefs.edit()
-                         .putInt(PREFS_VERSION_CODE, versionCode)
-                         .commit();
-                }
-            });
-
-            shouldRestore = true;
-        } else if (savedInstanceState != null || getSessionRestorePreference().equals("always") || getRestartFromIntent()) {
-            // We're coming back from a background kill by the OS, the user
-            // has chosen to always restore, or we just restarted.
-            shouldRestore = true;
-        }
-
-        return shouldRestore;
-    }
-
-    private String getSessionRestorePreference() {
-        return PreferenceManager.getDefaultSharedPreferences(this)
-                                .getString(GeckoPreferences.PREFS_RESTORE_SESSION, "quit");
-    }
-
-    private boolean getRestartFromIntent() {
-        return getIntent().getBooleanExtra("didRestart", false);
-    }
-
-    /**
-     * Enable Android StrictMode checks (for supported OS versions).
-     * http://developer.android.com/reference/android/os/StrictMode.html
-     */
-    private void enableStrictMode() {
-        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
-            return;
-        }
-
-        Log.d(LOGTAG, "Enabling Android StrictMode");
-
-        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
-                                  .detectAll()
-                                  .penaltyLog()
-                                  .build());
-
-        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
-                               .detectAll()
-                               .penaltyLog()
-                               .build());
-    }
-
-    public void enableCameraView() {
-        // Start listening for orientation events
-        mCameraOrientationEventListener = new OrientationEventListener(this) {
-            @Override
-            public void onOrientationChanged(int orientation) {
-                if (mAppStateListeners != null) {
-                    for (GeckoAppShell.AppStateListener listener: mAppStateListeners) {
-                        listener.onOrientationChanged();
-                    }
-                }
-            }
-        };
-        mCameraOrientationEventListener.enable();
-
-        // Try to make it fully transparent.
-        if (mCameraView instanceof SurfaceView) {
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
-                mCameraView.setAlpha(0.0f);
-            }
-        } else if (mCameraView instanceof TextureView) {
-            mCameraView.setAlpha(0.0f);
-        }
-        RelativeLayout mCameraLayout = (RelativeLayout) findViewById(R.id.camera_layout);
-        // Some phones (eg. nexus S) need at least a 8x16 preview size
-        mCameraLayout.addView(mCameraView,
-                              new AbsoluteLayout.LayoutParams(8, 16, 0, 0));
-    }
-
-    public void disableCameraView() {
-        if (mCameraOrientationEventListener != null) {
-            mCameraOrientationEventListener.disable();
-            mCameraOrientationEventListener = null;
-        }
-        RelativeLayout mCameraLayout = (RelativeLayout) findViewById(R.id.camera_layout);
-        mCameraLayout.removeView(mCameraView);
-    }
-
-    public String getDefaultUAString() {
-        return HardwareUtils.isTablet() ? AppConstants.USER_AGENT_FENNEC_TABLET :
-                                          AppConstants.USER_AGENT_FENNEC_MOBILE;
-    }
-
-    public String getUAStringForHost(String host) {
-        // With our standard UA String, we get a 200 response code and
-        // client-side redirect from t.co. This bot-like UA gives us a
-        // 301 response code
-        if ("t.co".equals(host)) {
-            return AppConstants.USER_AGENT_BOT_LIKE;
-        }
-        return getDefaultUAString();
-    }
-
-    class PrefetchRunnable implements Runnable {
-        private String mPrefetchUrl;
-
-        PrefetchRunnable(String prefetchUrl) {
-            mPrefetchUrl = prefetchUrl;
-        }
-
-        @Override
-        public void run() {
-            HttpURLConnection connection = null;
-            try {
-                URL url = new URL(mPrefetchUrl);
-                // data url should have an http scheme
-                connection = (HttpURLConnection) url.openConnection();
-                connection.setRequestProperty("User-Agent", getUAStringForHost(url.getHost()));
-                connection.setInstanceFollowRedirects(false);
-                connection.setRequestMethod("GET");
-                connection.connect();
-            } catch (Exception e) {
-                Log.e(LOGTAG, "Exception prefetching URL", e);
-            } finally {
-                if (connection != null)
-                    connection.disconnect();
-            }
-        }
-    }
-
-    private void processAlertCallback(Intent intent) {
-        String alertName = "";
-        String alertCookie = "";
-        Uri data = intent.getData();
-        if (data != null) {
-            alertName = data.getQueryParameter("name");
-            if (alertName == null)
-                alertName = "";
-            alertCookie = data.getQueryParameter("cookie");
-            if (alertCookie == null)
-                alertCookie = "";
-        }
-        handleNotification(ACTION_ALERT_CALLBACK, alertName, alertCookie);
-    }
-
-    @Override
-    protected void onNewIntent(Intent intent) {
-        if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoExiting)) {
-            // We're exiting and shouldn't try to do anything else. In the case
-            // where we are hung while exiting, we should force the process to exit.
-            GeckoAppShell.systemExit();
-            return;
-        }
-
-        // if we were previously OOM killed, we can end up here when launching
-        // from external shortcuts, so set this as the intent for initialization
-        if (!mInitialized) {
-            setIntent(intent);
-            return;
-        }
-
-        final String action = intent.getAction();
-
-        if (ACTION_LOAD.equals(action)) {
-            String uri = intent.getDataString();
-            Tabs.getInstance().loadUrl(uri);
-        } else if (Intent.ACTION_VIEW.equals(action)) {
-            String uri = intent.getDataString();
-            Tabs.getInstance().loadUrl(uri, Tabs.LOADURL_NEW_TAB |
-                                            Tabs.LOADURL_USER_ENTERED |
-                                            Tabs.LOADURL_EXTERNAL);
-        } else if (action != null && action.startsWith(ACTION_WEBAPP_PREFIX)) {
-            // A lightweight mechanism for loading a web page as a webapp
-            // without installing the app natively nor registering it in the DOM
-            // application registry.
-            String uri = getURIFromIntent(intent);
-            GeckoAppShell.sendEventToGecko(GeckoEvent.createWebappLoadEvent(uri));
-        } else if (ACTION_BOOKMARK.equals(action)) {
-            String uri = getURIFromIntent(intent);
-            GeckoAppShell.sendEventToGecko(GeckoEvent.createBookmarkLoadEvent(uri));
-        } else if (Intent.ACTION_SEARCH.equals(action)) {
-            String uri = getURIFromIntent(intent);
-            GeckoAppShell.sendEventToGecko(GeckoEvent.createURILoadEvent(uri));
-        } else if (ACTION_ALERT_CALLBACK.equals(action)) {
-            processAlertCallback(intent);
-        } else if (ACTION_LAUNCH_SETTINGS.equals(action)) {
-            // Check if launched from data reporting notification.
-            Intent settingsIntent = new Intent(GeckoApp.this, GeckoPreferences.class);
-            // Copy extras.
-            settingsIntent.putExtras(intent);
-            startActivity(settingsIntent);
-        }
-    }
-
-    /*
-     * Handles getting a uri from and intent in a way that is backwards
-     * compatable with our previous implementations
-     */
-    protected String getURIFromIntent(Intent intent) {
-        final String action = intent.getAction();
-        if (ACTION_ALERT_CALLBACK.equals(action))
-            return null;
-
-        String uri = intent.getDataString();
-        if (uri != null)
-            return uri;
-
-        if ((action != null && action.startsWith(ACTION_WEBAPP_PREFIX)) || ACTION_BOOKMARK.equals(action)) {
-            uri = intent.getStringExtra("args");
-            if (uri != null && uri.startsWith("--url=")) {
-                uri.replace("--url=", "");
-            }
-        }
-        return uri;
-    }
-
-    protected int getOrientation() {
-        return GeckoScreenOrientation.getInstance().getAndroidOrientation();
-    }
-
-    @Override
-    public void onResume()
-    {
-        // After an onPause, the activity is back in the foreground.
-        // Undo whatever we did in onPause.
-        super.onResume();
-
-        int newOrientation = getResources().getConfiguration().orientation;
-        if (GeckoScreenOrientation.getInstance().update(newOrientation)) {
-            refreshChrome();
-        }
-
-        // User may have enabled/disabled accessibility.
-        GeckoAccessibility.updateAccessibilitySettings(this);
-
-        if (mAppStateListeners != null) {
-            for (GeckoAppShell.AppStateListener listener: mAppStateListeners) {
-                listener.onResume();
-            }
-        }
-
-        // We use two times: a pseudo-unique wall-clock time to identify the
-        // current session across power cycles, and the elapsed realtime to
-        // track the duration of the session.
-        final long now = System.currentTimeMillis();
-        final long realTime = android.os.SystemClock.elapsedRealtime();
-
-        ThreadUtils.postToBackgroundThread(new Runnable() {
-            @Override
-            public void run() {
-                // Now construct the new session on HealthRecorder's behalf. We do this here
-                // so it can benefit from a single near-startup prefs commit.
-                SessionInformation currentSession = new SessionInformation(now, realTime);
-
-                SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
-                SharedPreferences.Editor editor = prefs.edit();
-                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
-                currentSession.recordBegin(editor);
-                editor.commit();
-
-                final HealthRecorder rec = mHealthRecorder;
-                if (rec != null) {
-                    rec.setCurrentSession(currentSession);
-                } else {
-                    Log.w(LOGTAG, "Can't record session: rec is null.");
-                }
-            }
-         });
-    }
-
-    @Override
-    public void onWindowFocusChanged(boolean hasFocus) {
-        super.onWindowFocusChanged(hasFocus);
-
-        if (!mInitialized && hasFocus) {
-            initialize();
-            getWindow().setBackgroundDrawable(null);
-        }
-    }
-
-    @Override
-    public void onPause()
-    {
-        final HealthRecorder rec = mHealthRecorder;
-        final Context context = this;
-
-        // In some way it's sad that Android will trigger StrictMode warnings
-        // here as the whole point is to save to disk while the activity is not
-        // interacting with the user.
-        ThreadUtils.postToBackgroundThread(new Runnable() {
-            @Override
-            public void run() {
-                SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
-                SharedPreferences.Editor editor = prefs.edit();
-                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, true);
-                if (rec != null) {
-                    rec.recordSessionEnd("P", editor);
-                }
-
-                // If we haven't done it before, cleanup any old files in our old temp dir
-                if (prefs.getBoolean(GeckoApp.PREFS_CLEANUP_TEMP_FILES, true)) {
-                    File tempDir = GeckoLoader.getGREDir(GeckoApp.this);
-                    FileUtils.delTree(tempDir, new FileUtils.NameAndAgeFilter(null, ONE_DAY_MS), false);
-
-                    editor.putBoolean(GeckoApp.PREFS_CLEANUP_TEMP_FILES, false);
-                }
-
-                editor.commit();
-
-                // In theory, the first browser session will not run long enough that we need to
-                // prune during it and we'd rather run it when the browser is inactive so we wait
-                // until here to register the prune service.
-                GeckoPreferences.broadcastHealthReportPrune(context);
-            }
-        });
-
-        if (mAppStateListeners != null) {
-            for(GeckoAppShell.AppStateListener listener: mAppStateListeners) {
-                listener.onPause();
-            }
-        }
-
-        super.onPause();
-    }
-
-    @Override
-    public void onRestart()
-    {
-        ThreadUtils.postToBackgroundThread(new Runnable() {
-            @Override
-            public void run() {
-                SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
-                SharedPreferences.Editor editor = prefs.edit();
-                editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
-                editor.commit();
-            }
-        });
-
-        super.onRestart();
-    }
-
-    @Override
-    public void onDestroy()
-    {
-        unregisterEventListener("log");
-        unregisterEventListener("Reader:ListCountRequest");
-        unregisterEventListener("Reader:ListStatusRequest");
-        unregisterEventListener("Reader:Added");
-        unregisterEventListener("Reader:Removed");
-        unregisterEventListener("Reader:Share");
-        unregisterEventListener("Reader:FaviconRequest");
-        unregisterEventListener("onCameraCapture");
-        unregisterEventListener("Gecko:Ready");
-        unregisterEventListener("Gecko:DelayedStartup");
-        unregisterEventListener("Toast:Show");
-        unregisterEventListener("DOMFullScreen:Start");
-        unregisterEventListener("DOMFullScreen:Stop");
-        unregisterEventListener("ToggleChrome:Hide");
-        unregisterEventListener("ToggleChrome:Show");
-        unregisterEventListener("ToggleChrome:Focus");
-        unregisterEventListener("Permissions:Data");
-        unregisterEventListener("Session:StatePurged");
-        unregisterEventListener("Bookmark:Insert");
-        unregisterEventListener("Accessibility:Event");
-        unregisterEventListener("Accessibility:Ready");
-        unregisterEventListener("Shortcut:Remove");
-        unregisterEventListener("Share:Text");
-        unregisterEventListener("Image:SetAs");
-        unregisterEventListener("Sanitize:ClearHistory");
-        unregisterEventListener("Update:Check");
-        unregisterEventListener("Update:Download");
-        unregisterEventListener("Update:Install");
-        unregisterEventListener("PrivateBrowsing:Data");
-        unregisterEventListener("Contact:Add");
-        unregisterEventListener("Intent:Open");
-        unregisterEventListener("Intent:GetHandlers");
-        unregisterEventListener("Locale:Set");
-        unregisterEventListener("NativeApp:IsDebuggable");
-        unregisterEventListener("SystemUI:Visibility");
-
-        EventListener.unregisterEvents();
-
-        deleteTempFiles();
-
-        if (mLayerView != null)
-            mLayerView.destroy();
-        if (mDoorHangerPopup != null)
-            mDoorHangerPopup.destroy();
-        if (mFormAssistPopup != null)
-            mFormAssistPopup.destroy();
-        if (mContactService != null)
-            mContactService.destroy();
-        if (mPromptService != null)
-            mPromptService.destroy();
-        if (mTextSelection != null)
-            mTextSelection.destroy();
-        NotificationHelper.destroy();
-
-        if (SmsManager.getInstance() != null) {
-            SmsManager.getInstance().stop();
-            if (isFinishing())
-                SmsManager.getInstance().shutdown();
-        }
-
-        final HealthRecorder rec = mHealthRecorder;
-        mHealthRecorder = null;
-        if (rec != null && rec.isEnabled()) {
-            // Closing a BrowserHealthRecorder could incur a write.
-            ThreadUtils.postToBackgroundThread(new Runnable() {
-                @Override
-                public void run() {
-                    rec.close();
-                }
-            });
-        }
-
-        Favicons.close();
-
-        super.onDestroy();
-
-        Tabs.unregisterOnTabsChangedListener(this);
-    }
-
-    protected void registerEventListener(String event) {
-        GeckoAppShell.getEventDispatcher().registerEventListener(event, this);
-    }
-
-    protected void unregisterEventListener(String event) {
-        GeckoAppShell.getEventDispatcher().unregisterEventListener(event, this);
-    }
-
-    // Get a temporary directory, may return null
-    public static File getTempDirectory() {
-        File dir = sAppContext.getExternalFilesDir("temp");
-        return dir;
-    }
-
-    // Delete any files in our temporary directory
-    public static void deleteTempFiles() {
-        File dir = getTempDirectory();
-        if (dir == null)
-            return;
-        File[] files = dir.listFiles();
-        if (files == null)
-            return;
-        for (File file : files) {
-            file.delete();
-        }
-    }
-
-    @Override
-    public void onConfigurationChanged(Configuration newConfig) {
-        Log.d(LOGTAG, "onConfigurationChanged: " + newConfig.locale);
-        LocaleManager.correctLocale(getResources(), newConfig);
-
-        // onConfigurationChanged is not called for 180 degree orientation changes,
-        // we will miss such rotations and the screen orientation will not be
-        // updated.
-        if (GeckoScreenOrientation.getInstance().update(newConfig.orientation)) {
-            if (mFormAssistPopup != null)
-                mFormAssistPopup.hide();
-            refreshChrome();
-        }
-        super.onConfigurationChanged(newConfig);
-    }
-
-    public String getContentProcessName() {
-        return AppConstants.MOZ_CHILD_PROCESS_NAME;
-    }
-
-    public void addEnvToIntent(Intent intent) {
-        Map<String,String> envMap = System.getenv();
-        Set<Map.Entry<String,String>> envSet = envMap.entrySet();
-        Iterator<Map.Entry<String,String>> envIter = envSet.iterator();
-        int c = 0;
-        while (envIter.hasNext()) {
-            Map.Entry<String,String> entry = envIter.next();
-            intent.putExtra("env" + c, entry.getKey() + "="
-                            + entry.getValue());
-            c++;
-        }
-    }
-
-    public void doRestart() {
-        doRestart(RESTARTER_ACTION, null);
-    }
-
-    public void doRestart(String args) {
-        doRestart(RESTARTER_ACTION, args);
-    }
-
-    public void doRestart(String action, String args) {
-        Log.d(LOGTAG, "doRestart(\"" + action + "\")");
-        try {
-            Intent intent = new Intent(action);
-            intent.setClassName(AppConstants.ANDROID_PACKAGE_NAME, RESTARTER_CLASS);
-            /* TODO: addEnvToIntent(intent); */
-            if (args != null)
-                intent.putExtra("args", args);
-            intent.putExtra("didRestart", true);
-            Log.d(LOGTAG, "Restart intent: " + intent.toString());
-            GeckoAppShell.killAnyZombies();
-            startActivity(intent);
-        } catch (Exception e) {
-            Log.e(LOGTAG, "Error effecting restart.", e);
-        }
-
-        finish();
-        // Give the restart process time to start before we die
-        GeckoAppShell.waitForAnotherGeckoProc();
-    }
-
-    public void handleNotification(String action, String alertName, String alertCookie) {
-        // If Gecko isn't running yet, we ignore the notification. Note that
-        // even if Gecko is running but it was restarted since the notification
-        // was created, the notification won't be handled (bug 849653).
-        if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoRunning)) {
-            GeckoAppShell.handleNotification(action, alertName, alertCookie);
-        }
-    }
-
-    private void checkMigrateProfile() {
-        final File profileDir = getProfile().getDir();
-
-        if (profileDir != null) {
-            final GeckoApp app = GeckoApp.sAppContext;
-
-            ThreadUtils.postToBackgroundThread(new Runnable() {
-                @Override
-                public void run() {
-                    Handler handler = new Handler();
-                    handler.postDelayed(new DeferredCleanupTask(), CLEANUP_DEFERRAL_SECONDS * 1000);
-                }
-            });
-        }
-    }
-
-    private class DeferredCleanupTask implements Runnable {
-        // The cleanup-version setting is recorded to avoid repeating the same
-        // tasks on subsequent startups; CURRENT_CLEANUP_VERSION may be updated
-        // if we need to do additional cleanup for future Gecko versions.
-
-        private static final String CLEANUP_VERSION = "cleanup-version";
-        private static final int CURRENT_CLEANUP_VERSION = 1;
-
-        @Override
-        public void run() {
-            long cleanupVersion = getAppSharedPreferences().getInt(CLEANUP_VERSION, 0);
-
-            if (cleanupVersion < 1) {
-                // Reduce device storage footprint by removing .ttf files from
-                // the res/fonts directory: we no longer need to copy our
-                // bundled fonts out of the APK in order to use them.
-                // See https://bugzilla.mozilla.org/show_bug.cgi?id=878674.
-                File dir = new File("res/fonts");
-                if (dir.exists() && dir.isDirectory()) {
-                    for (File file : dir.listFiles()) {
-                        if (file.isFile() && file.getName().endsWith(".ttf")) {
-                            Log.i(LOGTAG, "deleting " + file.toString());
-                            file.delete();
-                        }
-                    }
-                    if (!dir.delete()) {
-                        Log.w(LOGTAG, "unable to delete res/fonts directory (not empty?)");
-                    } else {
-                        Log.i(LOGTAG, "res/fonts directory deleted");
-                    }
-                }
-            }
-
-            // Additional cleanup needed for future versions would go here
-
-            if (cleanupVersion != CURRENT_CLEANUP_VERSION) {
-                SharedPreferences.Editor editor = getAppSharedPreferences().edit();
-                editor.putInt(CLEANUP_VERSION, CURRENT_CLEANUP_VERSION);
-                editor.commit();
-            }
-        }
-    }
-
-    public PromptService getPromptService() {
-        return mPromptService;
-    }
-
-    @Override
-    public void onBackPressed() {
-	    GeckoAppShell.systemExit();
+		extends GeckoActivity
+		implements
+		ContextGetter,
+		GeckoAppShell.GeckoInterface,
+		GeckoEventListener,
+		GeckoMenu.Callback,
+		GeckoMenu.MenuPresenter,
+		LocationListener,
+		SensorEventListener,
+		Tabs.OnTabsChangedListener {
+	private static final String LOGTAG = "GeckoApp";
+	private static final int ONE_DAY_MS = 1000 * 60 * 60 * 24;
+	private View z_back_bar;
+
+	private static enum StartupAction {
+		NORMAL,     /* normal application start */
+		URL,        /* launched with a passed URL */
+		PREFETCH    /* launched with a passed URL that we prefetch */
+	}
+
+	public static final String ACTION_ALERT_CALLBACK = "org.mozilla.gecko.ACTION_ALERT_CALLBACK";
+	public static final String ACTION_BOOKMARK = "org.mozilla.gecko.BOOKMARK";
+	public static final String ACTION_DEBUG = "org.mozilla.gecko.DEBUG";
+	public static final String ACTION_LAUNCH_SETTINGS = "org.mozilla.gecko.SETTINGS";
+	public static final String ACTION_LOAD = "org.mozilla.gecko.LOAD";
+	public static final String ACTION_INIT_PW = "org.mozilla.gecko.INIT_PW";
+	public static final String ACTION_WEBAPP_PREFIX = "org.mozilla.gecko.WEBAPP";
+
+	public static final String EXTRA_STATE_BUNDLE = "stateBundle";
+
+	public static final String PREFS_ALLOW_STATE_BUNDLE = "allowStateBundle";
+	public static final String PREFS_CRASHED = "crashed";
+	public static final String PREFS_NAME = "GeckoApp";
+	public static final String PREFS_OOM_EXCEPTION = "OOMException";
+	public static final String PREFS_VERSION_CODE = "versionCode";
+	public static final String PREFS_WAS_STOPPED = "wasStopped";
+	public static final String PREFS_CLEANUP_TEMP_FILES = "cleanupTempFiles";
+
+	public static final String SAVED_STATE_IN_BACKGROUND = "inBackground";
+	public static final String SAVED_STATE_PRIVATE_SESSION = "privateSession";
+
+	static private final String LOCATION_URL = "https://location.services.mozilla.com/v1/submit";
+
+	// Delay before running one-time "cleanup" tasks that may be needed
+	// after a version upgrade.
+	private static final int CLEANUP_DEFERRAL_SECONDS = 15;
+
+	protected RelativeLayout mMainLayout;
+	protected RelativeLayout mGeckoLayout;
+
+	public View getView() {
+		return mGeckoLayout;
+	}
+
+	private View mCameraView;
+	private OrientationEventListener mCameraOrientationEventListener;
+	public List<GeckoAppShell.AppStateListener> mAppStateListeners;
+	private static GeckoApp sAppContext;
+	protected MenuPanel mMenuPanel;
+	protected Menu mMenu;
+	protected GeckoProfile mProfile;
+	protected boolean mIsRestoringActivity;
+
+	private ContactService mContactService;
+	private PromptService mPromptService;
+	private TextSelection mTextSelection;
+
+	protected DoorHangerPopup mDoorHangerPopup;
+	protected FormAssistPopup mFormAssistPopup;
+	protected ButtonToast mToast;
+
+	protected LayerView mLayerView;
+	private AbsoluteLayout mPluginContainer;
+
+	private FullScreenHolder mFullScreenPluginContainer;
+	private View mFullScreenPluginView;
+
+	private HashMap<String, PowerManager.WakeLock> mWakeLocks = new HashMap<String, PowerManager.WakeLock>();
+
+	protected boolean mShouldRestore;
+	protected boolean mInitialized = false;
+	private Telemetry.Timer mJavaUiStartupTimer;
+	private Telemetry.Timer mGeckoReadyStartupTimer;
+
+	private String mPrivateBrowsingSession;
+
+	private volatile HealthRecorder mHealthRecorder = null;
+
+	private int mSignalStrenth;
+	private PhoneStateListener mPhoneStateListener = null;
+	private boolean mShouldReportGeoData;
+
+	abstract public int getLayout();
+
+	abstract public boolean hasTabsSideBar();
+
+	abstract protected String getDefaultProfileName() throws NoMozillaDirectoryException;
+
+	private static final String RESTARTER_ACTION = "org.mozilla.gecko.restart";
+	private static final String RESTARTER_CLASS = "org.mozilla.gecko.Restarter";
+
+	@SuppressWarnings("serial")
+	class SessionRestoreException extends Exception {
+		public SessionRestoreException(Exception e) {
+			super(e);
+		}
+
+		public SessionRestoreException(String message) {
+			super(message);
+		}
+	}
+
+	void toggleChrome(final boolean aShow) {
+	}
+
+	void focusChrome() {
+	}
+
+	@Override
+	public Context getContext() {
+		return sAppContext;
+	}
+
+	@Override
+	public SharedPreferences getSharedPreferences() {
+		return GeckoApp.getAppSharedPreferences();
+	}
+
+	public static SharedPreferences getAppSharedPreferences() {
+		return GeckoApp.sAppContext.getSharedPreferences(GeckoApp.PREFS_NAME, 0);
+	}
+
+	public Activity getActivity() {
+		return this;
+	}
+
+	public LocationListener getLocationListener() {
+		if (mShouldReportGeoData && mPhoneStateListener == null) {
+			mPhoneStateListener = new PhoneStateListener() {
+				public void onSignalStrengthsChanged(SignalStrength signalStrength) {
+					setCurrentSignalStrenth(signalStrength);
+				}
+			};
+			TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
+			tm.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SIGNAL_STRENGTHS);
+		}
+		return this;
+	}
+
+	public SensorEventListener getSensorEventListener() {
+		return this;
+	}
+
+	public View getCameraView() {
+		return mCameraView;
+	}
+
+	public void addAppStateListener(GeckoAppShell.AppStateListener listener) {
+		mAppStateListeners.add(listener);
+	}
+
+	public void removeAppStateListener(GeckoAppShell.AppStateListener listener) {
+		mAppStateListeners.remove(listener);
+	}
+
+	public FormAssistPopup getFormAssistPopup() {
+		return mFormAssistPopup;
+	}
+
+	@Override
+	public void onTabChanged(Tab tab, Tabs.TabEvents msg, Object data) {
+		// When a tab is closed, it is always unselected first.
+		// When a tab is unselected, another tab is always selected first.
+		switch (msg) {
+			case UNSELECTED:
+				hidePlugins(tab);
+				break;
+
+			case LOCATION_CHANGE:
+				// We only care about location change for the selected tab.
+				if (!Tabs.getInstance().isSelectedTab(tab))
+					break;
+				// Fall through...
+			case SELECTED:
+				invalidateOptionsMenu();
+				if (mFormAssistPopup != null)
+					mFormAssistPopup.hide();
+				break;
+
+			case LOADED:
+				// Sync up the layer view and the tab if the tab is
+				// currently displayed.
+				LayerView layerView = mLayerView;
+				if (layerView != null && Tabs.getInstance().isSelectedTab(tab))
+					layerView.setBackgroundColor(tab.getBackgroundColor());
+				break;
+
+			case DESKTOP_MODE_CHANGE:
+				if (Tabs.getInstance().isSelectedTab(tab))
+					invalidateOptionsMenu();
+				break;
+		}
+	}
+
+	public void refreshChrome() {
+	}
+
+	@Override
+	public void invalidateOptionsMenu() {
+		if (mMenu == null)
+			return;
+
+		onPrepareOptionsMenu(mMenu);
+
+		if (Build.VERSION.SDK_INT >= 11)
+			super.invalidateOptionsMenu();
+	}
+
+	@Override
+	public boolean onCreateOptionsMenu(Menu menu) {
+		mMenu = menu;
+
+		MenuInflater inflater = getMenuInflater();
+		inflater.inflate(R.menu.gecko_app_menu, mMenu);
+
+		return false;
+	}
+
+	@Override
+	public MenuInflater getMenuInflater() {
+		if (Build.VERSION.SDK_INT >= 11)
+			return new GeckoMenuInflater(this);
+		else
+			return super.getMenuInflater();
+	}
+
+	public MenuPanel getMenuPanel() {
+		if (mMenuPanel == null) {
+			onCreatePanelMenu(Window.FEATURE_OPTIONS_PANEL, null);
+			invalidateOptionsMenu();
+		}
+		return mMenuPanel;
+	}
+
+	@Override
+	public boolean onMenuItemSelected(MenuItem item) {
+		return onOptionsItemSelected(item);
+	}
+
+	@Override
+	public void openMenu() {
+		openOptionsMenu();
+	}
+
+	@Override
+	public void showMenu(View menu) {
+		// Hide the menu before we reshow it to avoid platform specific bugs like
+		// bug 794581 and bug 968182.
+		closeMenu();
+
+		mMenuPanel.removeAllViews();
+		mMenuPanel.addView(menu);
+
+		openOptionsMenu();
+	}
+
+	@Override
+	public void closeMenu() {
+		closeOptionsMenu();
+	}
+
+	@Override
+	public View onCreatePanelView(int featureId) {
+		if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+			if (mMenuPanel == null) {
+				mMenuPanel = new MenuPanel(this, null);
+			} else {
+				// Prepare the panel everytime before showing the menu.
+				onPreparePanel(featureId, mMenuPanel, mMenu);
+			}
+
+			return mMenuPanel;
+		}
+
+		return super.onCreatePanelView(featureId);
+	}
+
+	@Override
+	public boolean onCreatePanelMenu(int featureId, Menu menu) {
+		if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+			if (mMenuPanel == null) {
+				mMenuPanel = (MenuPanel) onCreatePanelView(featureId);
+			}
+
+			GeckoMenu gMenu = new GeckoMenu(this, null);
+			gMenu.setCallback(this);
+			gMenu.setMenuPresenter(this);
+			menu = gMenu;
+			mMenuPanel.addView(gMenu);
+
+			return onCreateOptionsMenu(menu);
+		}
+
+		return super.onCreatePanelMenu(featureId, menu);
+	}
+
+	@Override
+	public boolean onPreparePanel(int featureId, View view, Menu menu) {
+		if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL)
+			return onPrepareOptionsMenu(menu);
+
+		return super.onPreparePanel(featureId, view, menu);
+	}
+
+	@Override
+	public boolean onMenuOpened(int featureId, Menu menu) {
+		// exit full-screen mode whenever the menu is opened
+		if (mLayerView != null && mLayerView.isFullScreen()) {
+			GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("FullScreen:Exit", null));
+		}
+
+		if (Build.VERSION.SDK_INT >= 11 && featureId == Window.FEATURE_OPTIONS_PANEL) {
+			if (mMenu == null) {
+				// getMenuPanel() will force the creation of the menu as well
+				MenuPanel panel = getMenuPanel();
+				onPreparePanel(featureId, panel, mMenu);
+			}
+
+			// Scroll custom menu to the top
+			if (mMenuPanel != null)
+				mMenuPanel.scrollTo(0, 0);
+
+			return true;
+		}
+
+		return super.onMenuOpened(featureId, menu);
+	}
+
+	@Override
+	public boolean onOptionsItemSelected(MenuItem item) {
+		if (item.getItemId() == R.id.quit) {
+			if (GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.GeckoRunning, GeckoThread.LaunchState.GeckoExiting)) {
+				GeckoAppShell.notifyGeckoOfEvent(GeckoEvent.createBroadcastEvent("Browser:Quit", null));
+			} else {
+				GeckoAppShell.systemExit();
+			}
+			return true;
+		}
+
+		return super.onOptionsItemSelected(item);
+	}
+
+	@Override
+	public void onOptionsMenuClosed(Menu menu) {
+		if (Build.VERSION.SDK_INT >= 11) {
+			mMenuPanel.removeAllViews();
+			mMenuPanel.addView((GeckoMenu) mMenu);
+		}
+	}
+
+	@Override
+	public boolean onKeyDown(int keyCode, KeyEvent event) {
+		// Handle hardware menu key presses separately so that we can show a custom menu in some cases.
+		if (keyCode == KeyEvent.KEYCODE_MENU) {
+			openOptionsMenu();
+			return true;
+		}
+
+		return super.onKeyDown(keyCode, event);
+	}
+
+	@Override
+	protected void onSaveInstanceState(Bundle outState) {
+		super.onSaveInstanceState(outState);
+
+		if (mToast != null) {
+			mToast.onSaveInstanceState(outState);
+		}
+
+		outState.putBoolean(SAVED_STATE_IN_BACKGROUND, isApplicationInBackground());
+		outState.putString(SAVED_STATE_PRIVATE_SESSION, mPrivateBrowsingSession);
+	}
+
+	void handleFaviconRequest(final String url) {
+		(new UiAsyncTask<Void, Void, String>(ThreadUtils.getBackgroundHandler()) {
+			@Override
+			public String doInBackground(Void... params) {
+				return Favicons.getFaviconURLForPageURL(url);
+			}
+
+			@Override
+			public void onPostExecute(String faviconUrl) {
+				JSONObject args = new JSONObject();
+
+				if (faviconUrl != null) {
+					try {
+						args.put("url", url);
+						args.put("faviconUrl", faviconUrl);
+					} catch (JSONException e) {
+						Log.w(LOGTAG, "Error building JSON favicon arguments.", e);
+					}
+				}
+
+				GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Reader:FaviconReturn", args.toString()));
+			}
+		}).execute();
+	}
+
+	void handleClearHistory() {
+		BrowserDB.clearHistory(getContentResolver());
+	}
+
+	public void addTab() {
+	}
+
+	public void addPrivateTab() {
+	}
+
+	public void showNormalTabs() {
+	}
+
+	public void showPrivateTabs() {
+	}
+
+	public void showRemoteTabs() {
+	}
+
+	private void showTabs(TabsPanel.Panel panel) {
+	}
+
+	public void hideTabs() {
+	}
+
+	/**
+	 * Close the tab UI indirectly (not as the result of a direct user
+	 * action).  This does not force the UI to close; for example in Firefox
+	 * tablet mode it will remain open unless the user explicitly closes it.
+	 *
+	 * @return True if the tab UI was hidden.
+	 */
+	public boolean autoHideTabs() {
+		return false;
+	}
+
+	public boolean areTabsShown() {
+		return false;
+	}
+
+	@Override
+	public void handleMessage(String event, JSONObject message) {
+		try {
+			if (event.equals("Toast:Show")) {
+				final String msg = message.getString("message");
+				final JSONObject button = message.optJSONObject("button");
+				if (button != null) {
+					final String label = button.optString("label");
+					final String icon = button.optString("icon");
+					final String id = button.optString("id");
+					showButtonToast(msg, label, icon, id);
+				} else {
+					final String duration = message.getString("duration");
+					showNormalToast(msg, duration);
+				}
+			} else if (event.equals("log")) {
+				// generic log listener
+				final String msg = message.getString("msg");
+				Log.d(LOGTAG, "Log: " + msg);
+			} else if (event.equals("Reader:FaviconRequest")) {
+				final String url = message.getString("url");
+				handleFaviconRequest(url);
+			} else if (event.equals("Gecko:DelayedStartup")) {
+				ThreadUtils.postToBackgroundThread(new UninstallListener.DelayedStartupTask(this));
+			} else if (event.equals("Gecko:Ready")) {
+				mGeckoReadyStartupTimer.stop();
+				geckoConnected();
+
+				// This method is already running on the background thread, so we
+				// know that mHealthRecorder will exist. That doesn't stop us being
+				// paranoid.
+				// This method is cheap, so don't spawn a new runnable.
+				final HealthRecorder rec = mHealthRecorder;
+				if (rec != null) {
+					rec.recordGeckoStartupTime(mGeckoReadyStartupTimer.getElapsed());
+				}
+			} else if (event.equals("ToggleChrome:Hide")) {
+				toggleChrome(false);
+			} else if (event.equals("ToggleChrome:Show")) {
+				toggleChrome(true);
+			} else if (event.equals("ToggleChrome:Focus")) {
+				focusChrome();
+			} else if (event.equals("DOMFullScreen:Start")) {
+				// Local ref to layerView for thread safety
+				LayerView layerView = mLayerView;
+				if (layerView != null) {
+					layerView.setFullScreen(true);
+				}
+			} else if (event.equals("DOMFullScreen:Stop")) {
+				// Local ref to layerView for thread safety
+				LayerView layerView = mLayerView;
+				if (layerView != null) {
+					layerView.setFullScreen(false);
+				}
+			} else if (event.equals("Permissions:Data")) {
+				String host = message.getString("host");
+				JSONArray permissions = message.getJSONArray("permissions");
+				showSiteSettingsDialog(host, permissions);
+			} else if (event.equals("Session:StatePurged")) {
+				onStatePurged();
+			} else if (event.equals("Bookmark:Insert")) {
+				final String url = message.getString("url");
+				final String title = message.getString("title");
+				final Context context = this;
+				ThreadUtils.postToUiThread(new Runnable() {
+					@Override
+					public void run() {
+						Toast.makeText(context, R.string.bookmark_added, Toast.LENGTH_SHORT).show();
+						ThreadUtils.postToBackgroundThread(new Runnable() {
+							@Override
+							public void run() {
+								BrowserDB.addBookmark(getContentResolver(), title, url);
+							}
+						});
+					}
+				});
+			} else if (event.equals("Accessibility:Event")) {
+				GeckoAccessibility.sendAccessibilityEvent(message);
+			} else if (event.equals("Accessibility:Ready")) {
+				GeckoAccessibility.updateAccessibilitySettings(this);
+			} else if (event.equals("Shortcut:Remove")) {
+				final String url = message.getString("url");
+				final String origin = message.getString("origin");
+				final String title = message.getString("title");
+				final String type = message.getString("shortcutType");
+				GeckoAppShell.removeShortcut(title, url, origin, type);
+			} else if (event.equals("Share:Text")) {
+				String text = message.getString("text");
+				GeckoAppShell.openUriExternal(text, "text/plain", "", "", Intent.ACTION_SEND, "");
+			} else if (event.equals("Image:SetAs")) {
+				String src = message.getString("url");
+				setImageAs(src);
+			} else if (event.equals("Sanitize:ClearHistory")) {
+				handleClearHistory();
+			} else if (event.equals("Update:Check")) {
+				startService(new Intent(UpdateServiceHelper.ACTION_CHECK_FOR_UPDATE, null, this, UpdateService.class));
+			} else if (event.equals("Update:Download")) {
+				startService(new Intent(UpdateServiceHelper.ACTION_DOWNLOAD_UPDATE, null, this, UpdateService.class));
+			} else if (event.equals("Update:Install")) {
+				startService(new Intent(UpdateServiceHelper.ACTION_APPLY_UPDATE, null, this, UpdateService.class));
+			} else if (event.equals("PrivateBrowsing:Data")) {
+				// null strings return "null" (http://code.google.com/p/android/issues/detail?id=13830)
+				if (message.isNull("session")) {
+					mPrivateBrowsingSession = null;
+				} else {
+					mPrivateBrowsingSession = message.getString("session");
+				}
+			} else if (event.equals("Contact:Add")) {
+				if (!message.isNull("email")) {
+					Uri contactUri = Uri.parse(message.getString("email"));
+					Intent i = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT, contactUri);
+					startActivity(i);
+				} else if (!message.isNull("phone")) {
+					Uri contactUri = Uri.parse(message.getString("phone"));
+					Intent i = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT, contactUri);
+					startActivity(i);
+				} else {
+					// something went wrong.
+					Log.e(LOGTAG, "Received Contact:Add message with no email nor phone number");
+				}
+			} else if (event.equals("Intent:GetHandlers")) {
+				Intent intent = GeckoAppShell.getOpenURIIntent(sAppContext, message.optString("url"),
+						message.optString("mime"), message.optString("action"), message.optString("title"));
+				String[] handlers = GeckoAppShell.getHandlersForIntent(intent);
+				List<String> appList = Arrays.asList(handlers);
+				JSONObject handlersJSON = new JSONObject();
+				handlersJSON.put("apps", new JSONArray(appList));
+				EventDispatcher.sendResponse(message, handlersJSON);
+			} else if (event.equals("Intent:Open")) {
+				GeckoAppShell.openUriExternal(message.optString("url"),
+						message.optString("mime"), message.optString("packageName"),
+						message.optString("className"), message.optString("action"), message.optString("title"));
+			} else if (event.equals("Intent:OpenForResult")) {
+				Intent intent = GeckoAppShell.getOpenURIIntent(this,
+						message.optString("url"),
+						message.optString("mime"),
+						message.optString("action"),
+						message.optString("title"));
+				intent.setClassName(message.optString("packageName"), message.optString("className"));
+
+				intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+
+				final JSONObject originalMessage = message;
+				ActivityHandlerHelper.startIntentForActivity(this,
+						intent,
+						new ActivityResultHandler() {
+							@Override
+							public void onActivityResult(int resultCode, Intent data) {
+								JSONObject response = new JSONObject();
+
+								try {
+									if (data != null) {
+										response.put("extras", bundleToJSON(data.getExtras()));
+									}
+									response.put("resultCode", resultCode);
+								} catch (JSONException e) {
+									Log.w(LOGTAG, "Error building JSON response.", e);
+								}
+
+								EventDispatcher.sendResponse(originalMessage, response);
+							}
+						});
+			} else if (event.equals("Locale:Set")) {
+				setLocale(message.getString("locale"));
+			} else if (event.equals("NativeApp:IsDebuggable")) {
+				JSONObject ret = new JSONObject();
+				ret.put("isDebuggable", getIsDebuggable() ? "true" : "false");
+				EventDispatcher.sendResponse(message, ret);
+			} else if (event.equals("SystemUI:Visibility")) {
+				setSystemUiVisible(message.getBoolean("visible"));
+			}
+		} catch (Exception e) {
+			Log.e(LOGTAG, "Exception handling message \"" + event + "\":", e);
+		}
+	}
+
+	void onStatePurged() {
+	}
+
+	/**
+	 * @param aPermissions Array of JSON objects to represent site permissions.
+	 *                     Example: { type: "offline-app", setting: "Store Offline Data", value: "Allow" }
+	 */
+	private void showSiteSettingsDialog(String aHost, JSONArray aPermissions) {
+		final AlertDialog.Builder builder = new AlertDialog.Builder(this);
+
+		View customTitleView = getLayoutInflater().inflate(R.layout.site_setting_title, null);
+		((TextView) customTitleView.findViewById(R.id.title)).setText(R.string.site_settings_title);
+		((TextView) customTitleView.findViewById(R.id.host)).setText(aHost);
+		builder.setCustomTitle(customTitleView);
+
+		// If there are no permissions to clear, show the user a message about that.
+		// In the future, we want to disable the menu item if there are no permissions to clear.
+		if (aPermissions.length() == 0) {
+			builder.setMessage(R.string.site_settings_no_settings);
+		} else {
+
+			ArrayList<HashMap<String, String>> itemList = new ArrayList<HashMap<String, String>>();
+			for (int i = 0; i < aPermissions.length(); i++) {
+				try {
+					JSONObject permObj = aPermissions.getJSONObject(i);
+					HashMap<String, String> map = new HashMap<String, String>();
+					map.put("setting", permObj.getString("setting"));
+					map.put("value", permObj.getString("value"));
+					itemList.add(map);
+				} catch (JSONException e) {
+					Log.w(LOGTAG, "Exception populating settings items.", e);
+				}
+			}
+
+			// setMultiChoiceItems doesn't support using an adapter, so we're creating a hack with
+			// setSingleChoiceItems and changing the choiceMode below when we create the dialog
+			builder.setSingleChoiceItems(new SimpleAdapter(
+					GeckoApp.this,
+					itemList,
+					R.layout.site_setting_item,
+					new String[]{"setting", "value"},
+					new int[]{R.id.setting, R.id.value}
+			), -1, new DialogInterface.OnClickListener() {
+				@Override
+				public void onClick(DialogInterface dialog, int id) {
+				}
+			});
+
+			builder.setPositiveButton(R.string.site_settings_clear, new DialogInterface.OnClickListener() {
+				@Override
+				public void onClick(DialogInterface dialog, int id) {
+					ListView listView = ((AlertDialog) dialog).getListView();
+					SparseBooleanArray checkedItemPositions = listView.getCheckedItemPositions();
+
+					// An array of the indices of the permissions we want to clear
+					JSONArray permissionsToClear = new JSONArray();
+					for (int i = 0; i < checkedItemPositions.size(); i++)
+						if (checkedItemPositions.get(i))
+							permissionsToClear.put(i);
+
+					GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent(
+							"Permissions:Clear", permissionsToClear.toString()));
+				}
+			});
+		}
+
+		builder.setNegativeButton(R.string.site_settings_cancel, new DialogInterface.OnClickListener() {
+			@Override
+			public void onClick(DialogInterface dialog, int id) {
+				dialog.cancel();
+			}
+		});
+
+		ThreadUtils.postToUiThread(new Runnable() {
+			@Override
+			public void run() {
+				Dialog dialog = builder.create();
+				dialog.show();
+
+				ListView listView = ((AlertDialog) dialog).getListView();
+				if (listView != null) {
+					listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
+					int listSize = listView.getAdapter().getCount();
+					for (int i = 0; i < listSize; i++)
+						listView.setItemChecked(i, true);
+				}
+			}
+		});
+	}
+
+	public void showToast(final int resId, final int duration) {
+		ThreadUtils.postToUiThread(new Runnable() {
+			@Override
+			public void run() {
+				Toast.makeText(GeckoApp.this, resId, duration).show();
+			}
+		});
+	}
+
+	public void showNormalToast(final String message, final String duration) {
+		ThreadUtils.postToUiThread(new Runnable() {
+			@Override
+			public void run() {
+				Toast toast;
+				if (duration.equals("long")) {
+					toast = Toast.makeText(GeckoApp.this, message, Toast.LENGTH_LONG);
+				} else {
+					toast = Toast.makeText(GeckoApp.this, message, Toast.LENGTH_SHORT);
+				}
+				toast.show();
+			}
+		});
+	}
+
+	protected ButtonToast getButtonToast() {
+		if (mToast != null) {
+			return mToast;
+		}
+
+		ViewStub toastStub = (ViewStub) findViewById(R.id.toast_stub);
+		mToast = new ButtonToast(toastStub.inflate());
+
+		return mToast;
+	}
+
+	void showButtonToast(final String message, final String buttonText,
+	                     final String buttonIcon, final String buttonId) {
+		BitmapUtils.getDrawable(GeckoApp.this, buttonIcon, new BitmapUtils.BitmapLoader() {
+			@Override
+			public void onBitmapFound(final Drawable d) {
+				getButtonToast().show(false, message, buttonText, d, new ButtonToast.ToastListener() {
+					@Override
+					public void onButtonClicked() {
+						GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Toast:Click", buttonId));
+					}
+
+					@Override
+					public void onToastHidden(ButtonToast.ReasonHidden reason) {
+						if (reason == ButtonToast.ReasonHidden.TIMEOUT) {
+							GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Toast:Hidden", buttonId));
+						}
+					}
+				});
+			}
+		});
+	}
+
+	private JSONObject bundleToJSON(Bundle bundle) {
+		JSONObject json = new JSONObject();
+		if (bundle == null) {
+			return json;
+		}
+
+		for (String key : bundle.keySet()) {
+			try {
+				json.put(key, bundle.get(key));
+			} catch (JSONException e) {
+				Log.w(LOGTAG, "Error building JSON response.", e);
+			}
+		}
+
+		return json;
+	}
+
+	private void addFullScreenPluginView(View view) {
+		if (mFullScreenPluginView != null) {
+			Log.w(LOGTAG, "Already have a fullscreen plugin view");
+			return;
+		}
+
+		setFullScreen(true);
+
+		view.setWillNotDraw(false);
+		if (view instanceof SurfaceView) {
+			((SurfaceView) view).setZOrderOnTop(true);
+		}
+
+		mFullScreenPluginContainer = new FullScreenHolder(this);
+
+		FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(
+				ViewGroup.LayoutParams.FILL_PARENT,
+				ViewGroup.LayoutParams.FILL_PARENT,
+				Gravity.CENTER);
+		mFullScreenPluginContainer.addView(view, layoutParams);
+
+
+		FrameLayout decor = (FrameLayout) getWindow().getDecorView();
+		decor.addView(mFullScreenPluginContainer, layoutParams);
+
+		mFullScreenPluginView = view;
+	}
+
+	public void addPluginView(final View view, final RectF rect, final boolean isFullScreen) {
+		ThreadUtils.postToUiThread(new Runnable() {
+			@Override
+			public void run() {
+				Tabs tabs = Tabs.getInstance();
+				Tab tab = tabs.getSelectedTab();
+
+				if (isFullScreen) {
+					addFullScreenPluginView(view);
+					return;
+				}
+
+				PluginLayer layer = (PluginLayer) tab.getPluginLayer(view);
+				if (layer == null) {
+					layer = new PluginLayer(view, rect, mLayerView.getRenderer().getMaxTextureSize());
+					tab.addPluginLayer(view, layer);
+				} else {
+					layer.reset(rect);
+					layer.setVisible(true);
+				}
+
+				mLayerView.addLayer(layer);
+			}
+		});
+	}
+
+	private void removeFullScreenPluginView(View view) {
+		if (mFullScreenPluginView == null) {
+			Log.w(LOGTAG, "Don't have a fullscreen plugin view");
+			return;
+		}
+
+		if (mFullScreenPluginView != view) {
+			Log.w(LOGTAG, "Passed view is not the current full screen view");
+			return;
+		}
+
+		mFullScreenPluginContainer.removeView(mFullScreenPluginView);
+
+		// We need do do this on the next iteration in order to avoid
+		// a deadlock, see comment below in FullScreenHolder
+		ThreadUtils.postToUiThread(new Runnable() {
+			@Override
+			public void run() {
+				mLayerView.showSurface();
+			}
+		});
+
+		FrameLayout decor = (FrameLayout) getWindow().getDecorView();
+		decor.removeView(mFullScreenPluginContainer);
+
+		mFullScreenPluginView = null;
+
+		GeckoScreenOrientation.getInstance().unlock();
+		setFullScreen(false);
+	}
+
+	public void removePluginView(final View view, final boolean isFullScreen) {
+		ThreadUtils.postToUiThread(new Runnable() {
+			@Override
+			public void run() {
+				Tabs tabs = Tabs.getInstance();
+				Tab tab = tabs.getSelectedTab();
+
+				if (isFullScreen) {
+					removeFullScreenPluginView(view);
+					return;
+				}
+
+				PluginLayer layer = (PluginLayer) tab.removePluginLayer(view);
+				if (layer != null) {
+					layer.destroy();
+				}
+			}
+		});
+	}
+
+	// This method starts downloading an image synchronously and displays the Chooser activity to set the image as wallpaper.
+	private void setImageAs(final String aSrc) {
+		boolean isDataURI = aSrc.startsWith("data:");
+		Bitmap image = null;
+		InputStream is = null;
+		ByteArrayOutputStream os = null;
+		try {
+			if (isDataURI) {
+				int dataStart = aSrc.indexOf(",");
+				byte[] buf = Base64.decode(aSrc.substring(dataStart + 1), Base64.DEFAULT);
+				image = BitmapUtils.decodeByteArray(buf);
+			} else {
+				int byteRead;
+				byte[] buf = new byte[4192];
+				os = new ByteArrayOutputStream();
+				URL url = new URL(aSrc);
+				is = url.openStream();
+
+				// Cannot read from same stream twice. Also, InputStream from
+				// URL does not support reset. So converting to byte array.
+
+				while ((byteRead = is.read(buf)) != -1) {
+					os.write(buf, 0, byteRead);
+				}
+				byte[] imgBuffer = os.toByteArray();
+				image = BitmapUtils.decodeByteArray(imgBuffer);
+			}
+			if (image != null) {
+				String path = Media.insertImage(getContentResolver(), image, null, null);
+				final Intent intent = new Intent(Intent.ACTION_ATTACH_DATA);
+				intent.addCategory(Intent.CATEGORY_DEFAULT);
+				intent.setData(Uri.parse(path));
+
+				// Removes the image from storage once the chooser activity ends.
+				ActivityHandlerHelper.startIntentForActivity(this,
+						Intent.createChooser(intent, sAppContext.getString(R.string.set_image_chooser_title)),
+						new ActivityResultHandler() {
+							@Override
+							public void onActivityResult(int resultCode, Intent data) {
+								getContentResolver().delete(intent.getData(), null, null);
+							}
+						});
+			} else {
+				Toast.makeText(sAppContext, R.string.set_image_fail, Toast.LENGTH_SHORT).show();
+			}
+		} catch (OutOfMemoryError ome) {
+			Log.e(LOGTAG, "Out of Memory when converting to byte array", ome);
+		} catch (IOException ioe) {
+			Log.e(LOGTAG, "I/O Exception while setting wallpaper", ioe);
+		} finally {
+			if (is != null) {
+				try {
+					is.close();
+				} catch (IOException ioe) {
+					Log.w(LOGTAG, "I/O Exception while closing stream", ioe);
+				}
+			}
+			if (os != null) {
+				try {
+					os.close();
+				} catch (IOException ioe) {
+					Log.w(LOGTAG, "I/O Exception while closing stream", ioe);
+				}
+			}
+		}
+	}
+
+	private int getBitmapSampleSize(BitmapFactory.Options options, int idealWidth, int idealHeight) {
+		int width = options.outWidth;
+		int height = options.outHeight;
+		int inSampleSize = 1;
+		if (height > idealHeight || width > idealWidth) {
+			if (width > height) {
+				inSampleSize = Math.round((float) height / (float) idealHeight);
+			} else {
+				inSampleSize = Math.round((float) width / (float) idealWidth);
+			}
+		}
+		return inSampleSize;
+	}
+
+	private void hidePluginLayer(Layer layer) {
+		LayerView layerView = mLayerView;
+		layerView.removeLayer(layer);
+		layerView.requestRender();
+	}
+
+	private void showPluginLayer(Layer layer) {
+		LayerView layerView = mLayerView;
+		layerView.addLayer(layer);
+		layerView.requestRender();
+	}
+
+	public void requestRender() {
+		mLayerView.requestRender();
+	}
+
+	public void hidePlugins(Tab tab) {
+		for (Layer layer : tab.getPluginLayers()) {
+			if (layer instanceof PluginLayer) {
+				((PluginLayer) layer).setVisible(false);
+			}
+
+			hidePluginLayer(layer);
+		}
+
+		requestRender();
+	}
+
+	public void showPlugins() {
+		Tabs tabs = Tabs.getInstance();
+		Tab tab = tabs.getSelectedTab();
+
+		showPlugins(tab);
+	}
+
+	public void showPlugins(Tab tab) {
+		for (Layer layer : tab.getPluginLayers()) {
+			showPluginLayer(layer);
+
+			if (layer instanceof PluginLayer) {
+				((PluginLayer) layer).setVisible(true);
+			}
+		}
+
+		requestRender();
+	}
+
+	public void setFullScreen(final boolean fullscreen) {
+		ThreadUtils.postToUiThread(new Runnable() {
+			@Override
+			public void run() {
+				// Hide/show the system notification bar
+				Window window = getWindow();
+				window.setFlags(fullscreen ?
+						WindowManager.LayoutParams.FLAG_FULLSCREEN : 0,
+						WindowManager.LayoutParams.FLAG_FULLSCREEN);
+
+				if (Build.VERSION.SDK_INT >= 11)
+					window.getDecorView().setSystemUiVisibility(fullscreen ? 1 : 0);
+			}
+		});
+	}
+
+	/**
+	 * Check and start the Java profiler if MOZ_PROFILER_STARTUP env var is specified
+	 */
+	protected void earlyStartJavaSampler(Intent intent) {
+		String env = intent.getStringExtra("env0");
+		for (int i = 1; env != null; i++) {
+			if (env.startsWith("MOZ_PROFILER_STARTUP=")) {
+				if (!env.endsWith("=")) {
+					GeckoJavaSampler.start(10, 1000);
+					Log.d(LOGTAG, "Profiling Java on startup");
+				}
+				break;
+			}
+			env = intent.getStringExtra("env" + i);
+		}
+	}
+
+	/**
+	 * Called when the activity is first created.
+	 * <p/>
+	 * Here we initialize all of our profile settings, Firefox Health Report,
+	 * and other one-shot constructions.
+	 */
+	@Override
+	public void onCreate(Bundle savedInstanceState) {
+		GeckoAppShell.registerGlobalExceptionHandler();
+
+		// Enable Android Strict Mode for developers' local builds (the "default" channel).
+		if ("default".equals(AppConstants.MOZ_UPDATE_CHANNEL)) {
+			enableStrictMode();
+		}
+
+		// The clock starts...now. Better hurry!
+		mJavaUiStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_JAVAUI");
+		mGeckoReadyStartupTimer = new Telemetry.UptimeTimer("FENNEC_STARTUP_TIME_GECKOREADY");
+
+		Intent intent = getIntent();
+		String args = intent.getStringExtra("args");
+		earlyStartJavaSampler(intent);
+
+		if (mProfile == null) {
+			String profileName = null;
+			String profilePath = null;
+			if (args != null) {
+				if (args.contains("-P")) {
+					Pattern p = Pattern.compile("(?:-P\\s*)(\\w*)(\\s*)");
+					Matcher m = p.matcher(args);
+					if (m.find()) {
+						profileName = m.group(1);
+					}
+				}
+
+				if (args.contains("-profile")) {
+					Pattern p = Pattern.compile("(?:-profile\\s*)(\\S*)(\\s*)");
+					Matcher m = p.matcher(args);
+					if (m.find()) {
+						profilePath = m.group(1);
+					}
+					if (profileName == null) {
+						try {
+							profileName = getDefaultProfileName();
+						} catch (NoMozillaDirectoryException e) {
+							Log.wtf(LOGTAG, "Unable to fetch default profile name!", e);
+							// There's nothing at all we can do now. If the Mozilla directory
+							// didn't exist, then we're screwed.
+							// Crash here so we can fix the bug.
+							throw new RuntimeException(e);
+						}
+						if (profileName == null)
+							profileName = GeckoProfile.DEFAULT_PROFILE;
+					}
+					GeckoProfile.sIsUsingCustomProfile = true;
+				}
+
+				if (profileName != null || profilePath != null) {
+					mProfile = GeckoProfile.get(this, profileName, profilePath);
+				}
+			}
+		}
+
+		BrowserDB.initialize(getProfile().getName());
+
+		// Workaround for <http://code.google.com/p/android/issues/detail?id=20915>.
+		try {
+			Class.forName("android.os.AsyncTask");
+		} catch (ClassNotFoundException e) {
+		}
+
+		MemoryMonitor.getInstance().init(getApplicationContext());
+
+		sAppContext = this;
+		GeckoAppShell.setContextGetter(this);
+		GeckoAppShell.setGeckoInterface(this);
+		ThreadUtils.setUiThread(Thread.currentThread(), new Handler());
+
+		Tabs.getInstance().attachToContext(this);
+		try {
+			Favicons.attachToContext(this);
+		} catch (Exception e) {
+			Log.e(LOGTAG, "Exception starting favicon cache. Corrupt resources?", e);
+		}
+
+		// Did the OS locale change while we were backgrounded? If so,
+		// we need to die so that Gecko will re-init add-ons that touch
+		// the UI.
+		// This is using a sledgehammer to crack a nut, but it'll do for
+		// now.
+		if (LocaleManager.systemLocaleDidChange()) {
+			Log.i(LOGTAG, "System locale changed. Restarting.");
+			doRestart();
+			GeckoAppShell.systemExit();
+			return;
+		}
+
+		if (GeckoThread.isCreated()) {
+			// This happens when the GeckoApp activity is destroyed by Android
+			// without killing the entire application (see Bug 769269).
+			mIsRestoringActivity = true;
+			Telemetry.HistogramAdd("FENNEC_RESTORING_ACTIVITY", 1);
+		}
+
+		// Fix for Bug 830557 on Tegra boards running Froyo.
+		// This fix must be done before doing layout.
+		// Assume the bug is fixed in Gingerbread and up.
+		if (Build.VERSION.SDK_INT < 9) {
+			try {
+				Class<?> inputBindResultClass =
+						Class.forName("com.android.internal.view.InputBindResult");
+				java.lang.reflect.Field creatorField =
+						inputBindResultClass.getField("CREATOR");
+				Log.i(LOGTAG, "froyo startup fix: " + String.valueOf(creatorField.get(null)));
+			} catch (Exception e) {
+				Log.w(LOGTAG, "froyo startup fix failed", e);
+			}
+		}
+
+		Bundle stateBundle = getIntent().getBundleExtra(EXTRA_STATE_BUNDLE);
+		if (stateBundle != null) {
+			// Use the state bundle if it was given as an intent extra. This is
+			// only intended to be used internally via Robocop, so a boolean
+			// is read from a private shared pref to prevent other apps from
+			// injecting states.
+			SharedPreferences prefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
+			if (prefs.getBoolean(PREFS_ALLOW_STATE_BUNDLE, false)) {
+				Log.i(LOGTAG, "Restoring state from intent bundle");
+				prefs.edit().remove(PREFS_ALLOW_STATE_BUNDLE).commit();
+				savedInstanceState = stateBundle;
+			}
+		} else if (savedInstanceState != null) {
+			// Bug 896992 - This intent has already been handled; reset the intent.
+			setIntent(new Intent(Intent.ACTION_MAIN));
+		}
+
+		super.onCreate(savedInstanceState);
+
+		GeckoScreenOrientation.getInstance().update(getResources().getConfiguration().orientation);
+
+		setContentView(getLayout());
+
+		// Set up Gecko layout.
+		mGeckoLayout = (RelativeLayout) findViewById(R.id.gecko_layout);
+		mMainLayout = (RelativeLayout) findViewById(R.id.main_layout);
+
+		// Determine whether we should restore tabs.
+		mShouldRestore = getSessionRestoreState(savedInstanceState);
+
+		if (mShouldRestore && savedInstanceState != null) {
+			boolean wasInBackground =
+					savedInstanceState.getBoolean(SAVED_STATE_IN_BACKGROUND, false);
+
+			// Don't log OOM-kills if only one activity was destroyed. (For example
+			// from "Don't keep activities" on ICS)
+			if (!wasInBackground && !mIsRestoringActivity) {
+				Telemetry.HistogramAdd("FENNEC_WAS_KILLED", 1);
+			}
+
+			mPrivateBrowsingSession = savedInstanceState.getString(SAVED_STATE_PRIVATE_SESSION);
+		}
+
+		// Perform background initialization.
+		ThreadUtils.postToBackgroundThread(new Runnable() {
+			@Override
+			public void run() {
+				final SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+
+				// Wait until now to set this, because we'd rather throw an exception than
+				// have a caller of LocaleManager regress startup.
+				LocaleManager.setContextGetter(GeckoApp.this);
+				LocaleManager.initialize();
+
+				SessionInformation previousSession = SessionInformation.fromSharedPrefs(prefs);
+				if (previousSession.wasKilled()) {
+					Telemetry.HistogramAdd("FENNEC_WAS_KILLED", 1);
+				}
+
+				SharedPreferences.Editor editor = prefs.edit();
+				editor.putBoolean(GeckoApp.PREFS_OOM_EXCEPTION, false);
+
+				// Put a flag to check if we got a normal `onSaveInstanceState`
+				// on exit, or if we were suddenly killed (crash or native OOM).
+				editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
+
+				editor.commit();
+
+				// The lifecycle of mHealthRecorder is "shortly after onCreate"
+				// through "onDestroy" -- essentially the same as the lifecycle
+				// of the activity itself.
+				final String profilePath = getProfile().getDir().getAbsolutePath();
+				final EventDispatcher dispatcher = GeckoAppShell.getEventDispatcher();
+				Log.i(LOGTAG, "Creating HealthRecorder.");
+
+				final String osLocale = Locale.getDefault().toString();
+				String appLocale = LocaleManager.getAndApplyPersistedLocale();
+				Log.d(LOGTAG, "OS locale is " + osLocale + ", app locale is " + appLocale);
+
+				if (appLocale == null) {
+					appLocale = osLocale;
+				}
+
+				mHealthRecorder = GeckoApp.this.createHealthRecorder(GeckoApp.this,
+						profilePath,
+						dispatcher,
+						osLocale,
+						appLocale,
+						previousSession);
+
+				final String uiLocale = appLocale;
+				ThreadUtils.postToUiThread(new Runnable() {
+					@Override
+					public void run() {
+						GeckoApp.this.onLocaleReady(uiLocale);
+					}
+				});
+			}
+		});
+
+		GeckoAppShell.setNotificationClient(makeNotificationClient());
+		NotificationHelper.init(getApplicationContext());
+	}
+
+	/**
+	 * At this point, the resource system and the rest of the browser are
+	 * aware of the locale.
+	 * <p/>
+	 * Now we can display strings!
+	 */
+	@Override
+	public void onLocaleReady(final String locale) {
+		if (!ThreadUtils.isOnUiThread()) {
+			throw new RuntimeException("onLocaleReady must always be called from the UI thread.");
+		}
+
+		// The URL bar hint needs to be populated.
+		TextView urlBar = (TextView) findViewById(R.id.url_bar_title);
+		if (urlBar == null) {
+			return;
+		}
+		final String hint = getResources().getString(R.string.url_bar_default_text);
+		urlBar.setHint(hint);
+
+		// Allow onConfigurationChanged to take care of the rest.
+		onConfigurationChanged(getResources().getConfiguration());
+	}
+
+	protected void initializeChrome() {
+		mDoorHangerPopup = new DoorHangerPopup(this);
+		mPluginContainer = (AbsoluteLayout) findViewById(R.id.plugin_container);
+		mFormAssistPopup = (FormAssistPopup) findViewById(R.id.form_assist_popup);
+
+		if (mCameraView == null) {
+			if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
+				mCameraView = new SurfaceView(this);
+				((SurfaceView) mCameraView).getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+			} else {
+				mCameraView = new TextureView(this);
+			}
+		}
+
+		if (mLayerView == null) {
+			LayerView layerView = (LayerView) findViewById(R.id.layer_view);
+			layerView.initializeView(GeckoAppShell.getEventDispatcher());
+			mLayerView = layerView;
+			GeckoAppShell.setLayerView(layerView);
+			// bind the GeckoEditable instance to the new LayerView
+			GeckoAppShell.notifyIMEContext(GeckoEditableListener.IME_STATE_DISABLED, "", "", "");
+		}
+		setFullScreen(true);
+		z_back_bar = findViewById(R.id.z_back_bar);
+		z_back_bar.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View view) {
+				onBackPressed();
+			}
+		});
+	}
+
+	/**
+	 * Loads the initial tab at Fennec startup.
+	 * <p/>
+	 * If Fennec was opened with an external URL, that URL will be loaded.
+	 * Otherwise, unless there was a session restore, the default URL
+	 * (about:home) be loaded.
+	 *
+	 * @param url External URL to load, or null to load the default URL
+	 */
+	protected void loadStartupTab(String url) {
+		if (url == null) {
+			if (!mShouldRestore) {
+				z_back_bar.setVisibility(View.GONE);
+				// Show about:home if we aren't restoring previous session and
+				// there's no external URL.
+				Tabs.getInstance().loadUrl(AboutPages.UPDATER, Tabs.LOADURL_NEW_TAB | Tabs.LOADURL_USER_ENTERED | Tabs.LOADURL_EXTERNAL);
+			}
+		} else {
+			z_back_bar.setVisibility(View.VISIBLE);
+			// If given an external URL, load it
+			int flags = Tabs.LOADURL_NEW_TAB | Tabs.LOADURL_USER_ENTERED | Tabs.LOADURL_EXTERNAL;
+			Tabs.getInstance().loadUrl(url, flags);
+		}
+	}
+
+	private void initialize() {
+		mInitialized = true;
+
+		Intent intent = getIntent();
+		String action = intent.getAction();
+
+		String passedUri = null;
+		final String uri = getURIFromIntent(intent);
+		if (!TextUtils.isEmpty(uri)) {
+			passedUri = uri;
+		}
+
+		final boolean isExternalURL = passedUri != null &&
+				!AboutPages.isAboutHome(passedUri);
+		StartupAction startupAction;
+		if (isExternalURL) {
+			startupAction = StartupAction.URL;
+		} else {
+			startupAction = StartupAction.NORMAL;
+		}
+
+		// Start migrating as early as possible, can do this in
+		// parallel with Gecko load.
+		checkMigrateProfile();
+
+		Uri data = intent.getData();
+		if (data != null && "http".equals(data.getScheme())) {
+			startupAction = StartupAction.PREFETCH;
+			ThreadUtils.postToBackgroundThread(new PrefetchRunnable(data.toString()));
+		}
+
+		Tabs.registerOnTabsChangedListener(this);
+
+		initializeChrome();
+
+		// If we are doing a restore, read the session data and send it to Gecko
+		if (!mIsRestoringActivity) {
+			String restoreMessage = null;
+			if (mShouldRestore) {
+				try {
+					// restoreSessionTabs() will create simple tab stubs with the
+					// URL and title for each page, but we also need to restore
+					// session history. restoreSessionTabs() will inject the IDs
+					// of the tab stubs into the JSON data (which holds the session
+					// history). This JSON data is then sent to Gecko so session
+					// history can be restored for each tab.
+					restoreMessage = restoreSessionTabs(isExternalURL);
+				} catch (SessionRestoreException e) {
+					// If restore failed, do a normal startup
+					Log.e(LOGTAG, "An error occurred during restore", e);
+					mShouldRestore = false;
+				}
+			}
+
+			GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Session:Restore", restoreMessage));
+		}
+
+		// External URLs should always be loaded regardless of whether Gecko is
+		// already running.
+		if (isExternalURL) {
+			loadStartupTab(passedUri);
+		} else if (!mIsRestoringActivity) {
+			loadStartupTab(null);
+		}
+
+		// We now have tab stubs from the last session. Any future tabs should
+		// be animated.
+		Tabs.getInstance().notifyListeners(null, Tabs.TabEvents.RESTORED);
+
+		// If we're not restoring, move the session file so it can be read for
+		// the last tabs section.
+		if (!mShouldRestore) {
+			getProfile().moveSessionFile();
+		}
+
+		Telemetry.HistogramAdd("FENNEC_STARTUP_GECKOAPP_ACTION", startupAction.ordinal());
+
+		if (!mIsRestoringActivity) {
+			GeckoThread.setArgs(intent.getStringExtra("args"));
+			GeckoThread.setAction(intent.getAction());
+			GeckoThread.setUri(passedUri);
+		}
+		if (!ACTION_DEBUG.equals(action) &&
+				GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.Launching, GeckoThread.LaunchState.Launched)) {
+			GeckoThread.createAndStart();
+		} else if (ACTION_DEBUG.equals(action) &&
+				GeckoThread.checkAndSetLaunchState(GeckoThread.LaunchState.Launching, GeckoThread.LaunchState.WaitForDebugger)) {
+			ThreadUtils.getUiHandler().postDelayed(new Runnable() {
+				@Override
+				public void run() {
+					GeckoThread.setLaunchState(GeckoThread.LaunchState.Launching);
+					GeckoThread.createAndStart();
+				}
+			}, 1000 * 5 /* 5 seconds */);
+		}
+
+		// Check if launched from data reporting notification.
+		if (ACTION_LAUNCH_SETTINGS.equals(action)) {
+			Intent settingsIntent = new Intent(GeckoApp.this, GeckoPreferences.class);
+			// Copy extras.
+			settingsIntent.putExtras(intent);
+			startActivity(settingsIntent);
+		}
+
+		//app state callbacks
+		mAppStateListeners = new LinkedList<GeckoAppShell.AppStateListener>();
+
+		//register for events
+		registerEventListener("log");
+		registerEventListener("Reader:ListCountRequest");
+		registerEventListener("Reader:ListStatusRequest");
+		registerEventListener("Reader:Added");
+		registerEventListener("Reader:Removed");
+		registerEventListener("Reader:Share");
+		registerEventListener("Reader:FaviconRequest");
+		registerEventListener("onCameraCapture");
+		registerEventListener("Gecko:Ready");
+		registerEventListener("Gecko:DelayedStartup");
+		registerEventListener("Toast:Show");
+		registerEventListener("DOMFullScreen:Start");
+		registerEventListener("DOMFullScreen:Stop");
+		registerEventListener("ToggleChrome:Hide");
+		registerEventListener("ToggleChrome:Show");
+		registerEventListener("ToggleChrome:Focus");
+		registerEventListener("Permissions:Data");
+		registerEventListener("Session:StatePurged");
+		registerEventListener("Bookmark:Insert");
+		registerEventListener("Accessibility:Event");
+		registerEventListener("Accessibility:Ready");
+		registerEventListener("Shortcut:Remove");
+		registerEventListener("Share:Text");
+		registerEventListener("Image:SetAs");
+		registerEventListener("Sanitize:ClearHistory");
+		registerEventListener("Update:Check");
+		registerEventListener("Update:Download");
+		registerEventListener("Update:Install");
+		registerEventListener("PrivateBrowsing:Data");
+		registerEventListener("Contact:Add");
+		registerEventListener("Intent:Open");
+		registerEventListener("Intent:OpenForResult");
+		registerEventListener("Intent:GetHandlers");
+		registerEventListener("Locale:Set");
+		registerEventListener("NativeApp:IsDebuggable");
+		registerEventListener("SystemUI:Visibility");
+
+		EventListener.registerEvents();
+
+		if (SmsManager.getInstance() != null) {
+			SmsManager.getInstance().start();
+		}
+
+		mContactService = new ContactService(GeckoAppShell.getEventDispatcher(), this);
+
+		mPromptService = new PromptService(this);
+
+		mTextSelection = new TextSelection((TextSelectionHandle) findViewById(R.id.start_handle),
+				(TextSelectionHandle) findViewById(R.id.middle_handle),
+				(TextSelectionHandle) findViewById(R.id.end_handle),
+				GeckoAppShell.getEventDispatcher(),
+				this);
+
+		PrefsHelper.getPref("app.update.autodownload", new PrefsHelper.PrefHandlerBase() {
+			@Override
+			public void prefValue(String pref, String value) {
+				UpdateServiceHelper.registerForUpdates(GeckoApp.this, value);
+			}
+		});
+
+		PrefsHelper.getPref("app.geo.reportdata", new PrefsHelper.PrefHandlerBase() {
+			@Override
+			public void prefValue(String pref, int value) {
+				if (value == 1)
+					mShouldReportGeoData = true;
+				else
+					mShouldReportGeoData = false;
+			}
+		});
+
+		// Trigger the completion of the telemetry timer that wraps activity startup,
+		// then grab the duration to give to FHR.
+		mJavaUiStartupTimer.stop();
+		final long javaDuration = mJavaUiStartupTimer.getElapsed();
+
+		ThreadUtils.getBackgroundHandler().postDelayed(new Runnable() {
+			@Override
+			public void run() {
+				final HealthRecorder rec = mHealthRecorder;
+				if (rec != null) {
+					rec.recordJavaStartupTime(javaDuration);
+				}
+
+				// Record our launch time for the announcements service
+				// to use in assessing inactivity.
+				final Context context = GeckoApp.this;
+				AnnouncementsBroadcastService.recordLastLaunch(context);
+
+				// Kick off our background services. We do this by invoking the broadcast
+				// receiver, which uses the system alarm infrastructure to perform tasks at
+				// intervals.
+				GeckoPreferences.broadcastAnnouncementsPref(context);
+				GeckoPreferences.broadcastHealthReportUploadPref(context);
+				if (!GeckoThread.checkLaunchState(GeckoThread.LaunchState.Launched)) {
+					return;
+				}
+			}
+		}, 50);
+
+		if (mIsRestoringActivity) {
+			GeckoThread.setLaunchState(GeckoThread.LaunchState.GeckoRunning);
+			Tab selectedTab = Tabs.getInstance().getSelectedTab();
+			if (selectedTab != null)
+				Tabs.getInstance().notifyListeners(selectedTab, Tabs.TabEvents.SELECTED);
+			geckoConnected();
+			GeckoAppShell.setLayerClient(mLayerView.getLayerClient());
+			GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Viewport:Flush", null));
+		}
+
+		if (ACTION_ALERT_CALLBACK.equals(action)) {
+			processAlertCallback(intent);
+		}
+	}
+
+	private String restoreSessionTabs(final boolean isExternalURL) throws SessionRestoreException {
+		try {
+			String sessionString = getProfile().readSessionFile(false);
+			if (sessionString == null) {
+				throw new SessionRestoreException("Could not read from session file");
+			}
+
+			// If we are doing an OOM restore, parse the session data and
+			// stub the restored tabs immediately. This allows the UI to be
+			// updated before Gecko has restored.
+			if (mShouldRestore) {
+				final JSONArray tabs = new JSONArray();
+				SessionParser parser = new SessionParser() {
+					@Override
+					public void onTabRead(SessionTab sessionTab) {
+						JSONObject tabObject = sessionTab.getTabObject();
+
+						int flags = Tabs.LOADURL_NEW_TAB;
+						flags |= ((isExternalURL || !sessionTab.isSelected()) ? Tabs.LOADURL_DELAY_LOAD : 0);
+						flags |= (tabObject.optBoolean("desktopMode") ? Tabs.LOADURL_DESKTOP : 0);
+						flags |= (tabObject.optBoolean("isPrivate") ? Tabs.LOADURL_PRIVATE : 0);
+
+						Tab tab = Tabs.getInstance().loadUrl(sessionTab.getUrl(), flags);
+						tab.updateTitle(sessionTab.getTitle());
+
+						try {
+							tabObject.put("tabId", tab.getId());
+						} catch (JSONException e) {
+							Log.e(LOGTAG, "JSON error", e);
+						}
+						tabs.put(tabObject);
+					}
+				};
+
+				if (mPrivateBrowsingSession == null) {
+					parser.parse(sessionString);
+				} else {
+					parser.parse(sessionString, mPrivateBrowsingSession);
+				}
+
+				if (tabs.length() > 0) {
+					sessionString = new JSONObject().put("windows", new JSONArray().put(new JSONObject().put("tabs", tabs))).toString();
+				} else {
+					throw new SessionRestoreException("No tabs could be read from session file");
+				}
+			}
+
+			JSONObject restoreData = new JSONObject();
+			restoreData.put("sessionString", sessionString);
+			return restoreData.toString();
+
+		} catch (JSONException e) {
+			throw new SessionRestoreException(e);
+		}
+	}
+
+	public GeckoProfile getProfile() {
+		// fall back to default profile if we didn't load a specific one
+		if (mProfile == null) {
+			mProfile = GeckoProfile.get(this);
+		}
+		return mProfile;
+	}
+
+	/**
+	 * Determine whether the session should be restored.
+	 *
+	 * @param savedInstanceState Saved instance state given to the activity
+	 * @return Whether to restore
+	 */
+	protected boolean getSessionRestoreState(Bundle savedInstanceState) {
+		final SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+		boolean shouldRestore = false;
+
+		final int versionCode = getVersionCode();
+		if (prefs.getInt(PREFS_VERSION_CODE, 0) != versionCode) {
+			// If the version has changed, the user has done an upgrade, so restore
+			// previous tabs.
+			ThreadUtils.postToBackgroundThread(new Runnable() {
+				@Override
+				public void run() {
+					prefs.edit()
+							.putInt(PREFS_VERSION_CODE, versionCode)
+							.commit();
+				}
+			});
+
+			shouldRestore = true;
+		} else if (savedInstanceState != null || getSessionRestorePreference().equals("always") || getRestartFromIntent()) {
+			// We're coming back from a background kill by the OS, the user
+			// has chosen to always restore, or we just restarted.
+			shouldRestore = true;
+		}
+
+		return shouldRestore;
+	}
+
+	private String getSessionRestorePreference() {
+		return PreferenceManager.getDefaultSharedPreferences(this)
+				.getString(GeckoPreferences.PREFS_RESTORE_SESSION, "quit");
+	}
+
+	private boolean getRestartFromIntent() {
+		return getIntent().getBooleanExtra("didRestart", false);
+	}
+
+	/**
+	 * Enable Android StrictMode checks (for supported OS versions).
+	 * http://developer.android.com/reference/android/os/StrictMode.html
+	 */
+	private void enableStrictMode() {
+		if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
+			return;
+		}
+
+		Log.d(LOGTAG, "Enabling Android StrictMode");
+
+		StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
+				.detectAll()
+				.penaltyLog()
+				.build());
+
+		StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
+				.detectAll()
+				.penaltyLog()
+				.build());
+	}
+
+	public void enableCameraView() {
+		// Start listening for orientation events
+		mCameraOrientationEventListener = new OrientationEventListener(this) {
+			@Override
+			public void onOrientationChanged(int orientation) {
+				if (mAppStateListeners != null) {
+					for (GeckoAppShell.AppStateListener listener : mAppStateListeners) {
+						listener.onOrientationChanged();
+					}
+				}
+			}
+		};
+		mCameraOrientationEventListener.enable();
+
+		// Try to make it fully transparent.
+		if (mCameraView instanceof SurfaceView) {
+			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
+				mCameraView.setAlpha(0.0f);
+			}
+		} else if (mCameraView instanceof TextureView) {
+			mCameraView.setAlpha(0.0f);
+		}
+		RelativeLayout mCameraLayout = (RelativeLayout) findViewById(R.id.camera_layout);
+		// Some phones (eg. nexus S) need at least a 8x16 preview size
+		mCameraLayout.addView(mCameraView,
+				new AbsoluteLayout.LayoutParams(8, 16, 0, 0));
+	}
+
+	public void disableCameraView() {
+		if (mCameraOrientationEventListener != null) {
+			mCameraOrientationEventListener.disable();
+			mCameraOrientationEventListener = null;
+		}
+		RelativeLayout mCameraLayout = (RelativeLayout) findViewById(R.id.camera_layout);
+		mCameraLayout.removeView(mCameraView);
+	}
+
+	public String getDefaultUAString() {
+		return HardwareUtils.isTablet() ? AppConstants.USER_AGENT_FENNEC_TABLET :
+				AppConstants.USER_AGENT_FENNEC_MOBILE;
+	}
+
+	public String getUAStringForHost(String host) {
+		// With our standard UA String, we get a 200 response code and
+		// client-side redirect from t.co. This bot-like UA gives us a
+		// 301 response code
+		if ("t.co".equals(host)) {
+			return AppConstants.USER_AGENT_BOT_LIKE;
+		}
+		return getDefaultUAString();
+	}
+
+	class PrefetchRunnable implements Runnable {
+		private String mPrefetchUrl;
+
+		PrefetchRunnable(String prefetchUrl) {
+			mPrefetchUrl = prefetchUrl;
+		}
+
+		@Override
+		public void run() {
+			HttpURLConnection connection = null;
+			try {
+				URL url = new URL(mPrefetchUrl);
+				// data url should have an http scheme
+				connection = (HttpURLConnection) url.openConnection();
+				connection.setRequestProperty("User-Agent", getUAStringForHost(url.getHost()));
+				connection.setInstanceFollowRedirects(false);
+				connection.setRequestMethod("GET");
+				connection.connect();
+			} catch (Exception e) {
+				Log.e(LOGTAG, "Exception prefetching URL", e);
+			} finally {
+				if (connection != null)
+					connection.disconnect();
+			}
+		}
+	}
+
+	private void processAlertCallback(Intent intent) {
+		String alertName = "";
+		String alertCookie = "";
+		Uri data = intent.getData();
+		if (data != null) {
+			alertName = data.getQueryParameter("name");
+			if (alertName == null)
+				alertName = "";
+			alertCookie = data.getQueryParameter("cookie");
+			if (alertCookie == null)
+				alertCookie = "";
+		}
+		handleNotification(ACTION_ALERT_CALLBACK, alertName, alertCookie);
+	}
+
+	@Override
+	protected void onNewIntent(Intent intent) {
+		if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoExiting)) {
+			// We're exiting and shouldn't try to do anything else. In the case
+			// where we are hung while exiting, we should force the process to exit.
+			GeckoAppShell.systemExit();
+			return;
+		}
+
+		// if we were previously OOM killed, we can end up here when launching
+		// from external shortcuts, so set this as the intent for initialization
+		if (!mInitialized) {
+			setIntent(intent);
+			return;
+		}
+
+		final String action = intent.getAction();
+
+		if (ACTION_LOAD.equals(action)) {
+			String uri = intent.getDataString();
+			Tabs.getInstance().loadUrl(uri);
+		} else if (Intent.ACTION_VIEW.equals(action)) {
+			String uri = intent.getDataString();
+			Tabs.getInstance().loadUrl(uri, Tabs.LOADURL_NEW_TAB |
+					Tabs.LOADURL_USER_ENTERED |
+					Tabs.LOADURL_EXTERNAL);
+		} else if (action != null && action.startsWith(ACTION_WEBAPP_PREFIX)) {
+			// A lightweight mechanism for loading a web page as a webapp
+			// without installing the app natively nor registering it in the DOM
+			// application registry.
+			String uri = getURIFromIntent(intent);
+			GeckoAppShell.sendEventToGecko(GeckoEvent.createWebappLoadEvent(uri));
+		} else if (ACTION_BOOKMARK.equals(action)) {
+			String uri = getURIFromIntent(intent);
+			GeckoAppShell.sendEventToGecko(GeckoEvent.createBookmarkLoadEvent(uri));
+		} else if (Intent.ACTION_SEARCH.equals(action)) {
+			String uri = getURIFromIntent(intent);
+			GeckoAppShell.sendEventToGecko(GeckoEvent.createURILoadEvent(uri));
+		} else if (ACTION_ALERT_CALLBACK.equals(action)) {
+			processAlertCallback(intent);
+		} else if (ACTION_LAUNCH_SETTINGS.equals(action)) {
+			// Check if launched from data reporting notification.
+			Intent settingsIntent = new Intent(GeckoApp.this, GeckoPreferences.class);
+			// Copy extras.
+			settingsIntent.putExtras(intent);
+			startActivity(settingsIntent);
+		}
+	}
+
+	/*
+	 * Handles getting a uri from and intent in a way that is backwards
+	 * compatable with our previous implementations
+	 */
+	protected String getURIFromIntent(Intent intent) {
+		final String action = intent.getAction();
+		if (ACTION_ALERT_CALLBACK.equals(action))
+			return null;
+
+		String uri = intent.getDataString();
+		if (uri != null)
+			return uri;
+
+		if ((action != null && action.startsWith(ACTION_WEBAPP_PREFIX)) || ACTION_BOOKMARK.equals(action)) {
+			uri = intent.getStringExtra("args");
+			if (uri != null && uri.startsWith("--url=")) {
+				uri.replace("--url=", "");
+			}
+		}
+		return uri;
+	}
+
+	protected int getOrientation() {
+		return GeckoScreenOrientation.getInstance().getAndroidOrientation();
+	}
+
+	@Override
+	public void onResume() {
+		// After an onPause, the activity is back in the foreground.
+		// Undo whatever we did in onPause.
+		super.onResume();
+
+		int newOrientation = getResources().getConfiguration().orientation;
+		if (GeckoScreenOrientation.getInstance().update(newOrientation)) {
+			refreshChrome();
+		}
+
+		// User may have enabled/disabled accessibility.
+		GeckoAccessibility.updateAccessibilitySettings(this);
+
+		if (mAppStateListeners != null) {
+			for (GeckoAppShell.AppStateListener listener : mAppStateListeners) {
+				listener.onResume();
+			}
+		}
+
+		// We use two times: a pseudo-unique wall-clock time to identify the
+		// current session across power cycles, and the elapsed realtime to
+		// track the duration of the session.
+		final long now = System.currentTimeMillis();
+		final long realTime = android.os.SystemClock.elapsedRealtime();
+
+		ThreadUtils.postToBackgroundThread(new Runnable() {
+			@Override
+			public void run() {
+				// Now construct the new session on HealthRecorder's behalf. We do this here
+				// so it can benefit from a single near-startup prefs commit.
+				SessionInformation currentSession = new SessionInformation(now, realTime);
+
+				SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+				SharedPreferences.Editor editor = prefs.edit();
+				editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
+				currentSession.recordBegin(editor);
+				editor.commit();
+
+				final HealthRecorder rec = mHealthRecorder;
+				if (rec != null) {
+					rec.setCurrentSession(currentSession);
+				} else {
+					Log.w(LOGTAG, "Can't record session: rec is null.");
+				}
+			}
+		});
+	}
+
+	@Override
+	public void onWindowFocusChanged(boolean hasFocus) {
+		super.onWindowFocusChanged(hasFocus);
+
+		if (!mInitialized && hasFocus) {
+			initialize();
+			getWindow().setBackgroundDrawable(null);
+		}
+	}
+
+	@Override
+	public void onPause() {
+		final HealthRecorder rec = mHealthRecorder;
+		final Context context = this;
+
+		// In some way it's sad that Android will trigger StrictMode warnings
+		// here as the whole point is to save to disk while the activity is not
+		// interacting with the user.
+		ThreadUtils.postToBackgroundThread(new Runnable() {
+			@Override
+			public void run() {
+				SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+				SharedPreferences.Editor editor = prefs.edit();
+				editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, true);
+				if (rec != null) {
+					rec.recordSessionEnd("P", editor);
+				}
+
+				// If we haven't done it before, cleanup any old files in our old temp dir
+				if (prefs.getBoolean(GeckoApp.PREFS_CLEANUP_TEMP_FILES, true)) {
+					File tempDir = GeckoLoader.getGREDir(GeckoApp.this);
+					FileUtils.delTree(tempDir, new FileUtils.NameAndAgeFilter(null, ONE_DAY_MS), false);
+
+					editor.putBoolean(GeckoApp.PREFS_CLEANUP_TEMP_FILES, false);
+				}
+
+				editor.commit();
+
+				// In theory, the first browser session will not run long enough that we need to
+				// prune during it and we'd rather run it when the browser is inactive so we wait
+				// until here to register the prune service.
+				GeckoPreferences.broadcastHealthReportPrune(context);
+			}
+		});
+
+		if (mAppStateListeners != null) {
+			for (GeckoAppShell.AppStateListener listener : mAppStateListeners) {
+				listener.onPause();
+			}
+		}
+
+		super.onPause();
+	}
+
+	@Override
+	public void onRestart() {
+		ThreadUtils.postToBackgroundThread(new Runnable() {
+			@Override
+			public void run() {
+				SharedPreferences prefs = GeckoApp.getAppSharedPreferences();
+				SharedPreferences.Editor editor = prefs.edit();
+				editor.putBoolean(GeckoApp.PREFS_WAS_STOPPED, false);
+				editor.commit();
+			}
+		});
+
+		super.onRestart();
+	}
+
+	@Override
+	public void onDestroy() {
+		unregisterEventListener("log");
+		unregisterEventListener("Reader:ListCountRequest");
+		unregisterEventListener("Reader:ListStatusRequest");
+		unregisterEventListener("Reader:Added");
+		unregisterEventListener("Reader:Removed");
+		unregisterEventListener("Reader:Share");
+		unregisterEventListener("Reader:FaviconRequest");
+		unregisterEventListener("onCameraCapture");
+		unregisterEventListener("Gecko:Ready");
+		unregisterEventListener("Gecko:DelayedStartup");
+		unregisterEventListener("Toast:Show");
+		unregisterEventListener("DOMFullScreen:Start");
+		unregisterEventListener("DOMFullScreen:Stop");
+		unregisterEventListener("ToggleChrome:Hide");
+		unregisterEventListener("ToggleChrome:Show");
+		unregisterEventListener("ToggleChrome:Focus");
+		unregisterEventListener("Permissions:Data");
+		unregisterEventListener("Session:StatePurged");
+		unregisterEventListener("Bookmark:Insert");
+		unregisterEventListener("Accessibility:Event");
+		unregisterEventListener("Accessibility:Ready");
+		unregisterEventListener("Shortcut:Remove");
+		unregisterEventListener("Share:Text");
+		unregisterEventListener("Image:SetAs");
+		unregisterEventListener("Sanitize:ClearHistory");
+		unregisterEventListener("Update:Check");
+		unregisterEventListener("Update:Download");
+		unregisterEventListener("Update:Install");
+		unregisterEventListener("PrivateBrowsing:Data");
+		unregisterEventListener("Contact:Add");
+		unregisterEventListener("Intent:Open");
+		unregisterEventListener("Intent:GetHandlers");
+		unregisterEventListener("Locale:Set");
+		unregisterEventListener("NativeApp:IsDebuggable");
+		unregisterEventListener("SystemUI:Visibility");
+
+		EventListener.unregisterEvents();
+
+		deleteTempFiles();
+
+		if (mLayerView != null)
+			mLayerView.destroy();
+		if (mDoorHangerPopup != null)
+			mDoorHangerPopup.destroy();
+		if (mFormAssistPopup != null)
+			mFormAssistPopup.destroy();
+		if (mContactService != null)
+			mContactService.destroy();
+		if (mPromptService != null)
+			mPromptService.destroy();
+		if (mTextSelection != null)
+			mTextSelection.destroy();
+		NotificationHelper.destroy();
+
+		if (SmsManager.getInstance() != null) {
+			SmsManager.getInstance().stop();
+			if (isFinishing())
+				SmsManager.getInstance().shutdown();
+		}
+
+		final HealthRecorder rec = mHealthRecorder;
+		mHealthRecorder = null;
+		if (rec != null && rec.isEnabled()) {
+			// Closing a BrowserHealthRecorder could incur a write.
+			ThreadUtils.postToBackgroundThread(new Runnable() {
+				@Override
+				public void run() {
+					rec.close();
+				}
+			});
+		}
+
+		Favicons.close();
+
+		super.onDestroy();
+
+		Tabs.unregisterOnTabsChangedListener(this);
+	}
+
+	protected void registerEventListener(String event) {
+		GeckoAppShell.getEventDispatcher().registerEventListener(event, this);
+	}
+
+	protected void unregisterEventListener(String event) {
+		GeckoAppShell.getEventDispatcher().unregisterEventListener(event, this);
+	}
+
+	// Get a temporary directory, may return null
+	public static File getTempDirectory() {
+		File dir = sAppContext.getExternalFilesDir("temp");
+		return dir;
+	}
+
+	// Delete any files in our temporary directory
+	public static void deleteTempFiles() {
+		File dir = getTempDirectory();
+		if (dir == null)
+			return;
+		File[] files = dir.listFiles();
+		if (files == null)
+			return;
+		for (File file : files) {
+			file.delete();
+		}
+	}
+
+	@Override
+	public void onConfigurationChanged(Configuration newConfig) {
+		Log.d(LOGTAG, "onConfigurationChanged: " + newConfig.locale);
+		LocaleManager.correctLocale(getResources(), newConfig);
+
+		// onConfigurationChanged is not called for 180 degree orientation changes,
+		// we will miss such rotations and the screen orientation will not be
+		// updated.
+		if (GeckoScreenOrientation.getInstance().update(newConfig.orientation)) {
+			if (mFormAssistPopup != null)
+				mFormAssistPopup.hide();
+			refreshChrome();
+		}
+		super.onConfigurationChanged(newConfig);
+	}
+
+	public String getContentProcessName() {
+		return AppConstants.MOZ_CHILD_PROCESS_NAME;
+	}
+
+	public void addEnvToIntent(Intent intent) {
+		Map<String, String> envMap = System.getenv();
+		Set<Map.Entry<String, String>> envSet = envMap.entrySet();
+		Iterator<Map.Entry<String, String>> envIter = envSet.iterator();
+		int c = 0;
+		while (envIter.hasNext()) {
+			Map.Entry<String, String> entry = envIter.next();
+			intent.putExtra("env" + c, entry.getKey() + "="
+					+ entry.getValue());
+			c++;
+		}
+	}
+
+	public void doRestart() {
+		doRestart(RESTARTER_ACTION, null);
+	}
+
+	public void doRestart(String args) {
+		doRestart(RESTARTER_ACTION, args);
+	}
+
+	public void doRestart(String action, String args) {
+		Log.d(LOGTAG, "doRestart(\"" + action + "\")");
+		try {
+			Intent intent = new Intent(action);
+			intent.setClassName(AppConstants.ANDROID_PACKAGE_NAME, RESTARTER_CLASS);
+	        /* TODO: addEnvToIntent(intent); */
+			if (args != null)
+				intent.putExtra("args", args);
+			intent.putExtra("didRestart", true);
+			Log.d(LOGTAG, "Restart intent: " + intent.toString());
+			GeckoAppShell.killAnyZombies();
+			startActivity(intent);
+		} catch (Exception e) {
+			Log.e(LOGTAG, "Error effecting restart.", e);
+		}
+
+		finish();
+		// Give the restart process time to start before we die
+		GeckoAppShell.waitForAnotherGeckoProc();
+	}
+
+	public void handleNotification(String action, String alertName, String alertCookie) {
+		// If Gecko isn't running yet, we ignore the notification. Note that
+		// even if Gecko is running but it was restarted since the notification
+		// was created, the notification won't be handled (bug 849653).
+		if (GeckoThread.checkLaunchState(GeckoThread.LaunchState.GeckoRunning)) {
+			GeckoAppShell.handleNotification(action, alertName, alertCookie);
+		}
+	}
+
+	private void checkMigrateProfile() {
+		final File profileDir = getProfile().getDir();
+
+		if (profileDir != null) {
+			final GeckoApp app = GeckoApp.sAppContext;
+
+			ThreadUtils.postToBackgroundThread(new Runnable() {
+				@Override
+				public void run() {
+					Handler handler = new Handler();
+					handler.postDelayed(new DeferredCleanupTask(), CLEANUP_DEFERRAL_SECONDS * 1000);
+				}
+			});
+		}
+	}
+
+	private class DeferredCleanupTask implements Runnable {
+		// The cleanup-version setting is recorded to avoid repeating the same
+		// tasks on subsequent startups; CURRENT_CLEANUP_VERSION may be updated
+		// if we need to do additional cleanup for future Gecko versions.
+
+		private static final String CLEANUP_VERSION = "cleanup-version";
+		private static final int CURRENT_CLEANUP_VERSION = 1;
+
+		@Override
+		public void run() {
+			long cleanupVersion = getAppSharedPreferences().getInt(CLEANUP_VERSION, 0);
+
+			if (cleanupVersion < 1) {
+				// Reduce device storage footprint by removing .ttf files from
+				// the res/fonts directory: we no longer need to copy our
+				// bundled fonts out of the APK in order to use them.
+				// See https://bugzilla.mozilla.org/show_bug.cgi?id=878674.
+				File dir = new File("res/fonts");
+				if (dir.exists() && dir.isDirectory()) {
+					for (File file : dir.listFiles()) {
+						if (file.isFile() && file.getName().endsWith(".ttf")) {
+							Log.i(LOGTAG, "deleting " + file.toString());
+							file.delete();
+						}
+					}
+					if (!dir.delete()) {
+						Log.w(LOGTAG, "unable to delete res/fonts directory (not empty?)");
+					} else {
+						Log.i(LOGTAG, "res/fonts directory deleted");
+					}
+				}
+			}
+
+			// Additional cleanup needed for future versions would go here
+
+			if (cleanupVersion != CURRENT_CLEANUP_VERSION) {
+				SharedPreferences.Editor editor = getAppSharedPreferences().edit();
+				editor.putInt(CLEANUP_VERSION, CURRENT_CLEANUP_VERSION);
+				editor.commit();
+			}
+		}
+	}
+
+	public PromptService getPromptService() {
+		return mPromptService;
+	}
+
+	@Override
+	public void onBackPressed() {
+		Tab selectedTab = Tabs.getInstance().getSelectedTab();
+		Log.v("Cuong", "Selected tab " + selectedTab + ":" + selectedTab.canDoBack());
+		if (selectedTab != null && selectedTab.canDoBack()) {
+			selectedTab.doBack();
+		} else {
+			GeckoAppShell.systemExit();
+		}
 //        if (getSupportFragmentManager().getBackStackEntryCount() > 0) {
 //            super.onBackPressed();
 //            return;
@@ -2386,486 +2420,487 @@
 //        }
 //
 //        moveTaskToBack(true);
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (!ActivityHandlerHelper.handleActivityResult(requestCode, resultCode, data)) {
-            super.onActivityResult(requestCode, resultCode, data);
-        }
-    }
-
-    public AbsoluteLayout getPluginContainer() { return mPluginContainer; }
-
-    // Accelerometer.
-    @Override
-    public void onAccuracyChanged(Sensor sensor, int accuracy) {
-    }
-
-    @Override
-    public void onSensorChanged(SensorEvent event) {
-        GeckoAppShell.sendEventToGecko(GeckoEvent.createSensorEvent(event));
-    }
-
-    // Geolocation.
-    @Override
-    public void onLocationChanged(Location location) {
-        // No logging here: user-identifying information.
-        GeckoAppShell.sendEventToGecko(GeckoEvent.createLocationEvent(location));
-        if (mShouldReportGeoData)
-            collectAndReportLocInfo(location);
-    }
-
-    public void setCurrentSignalStrenth(SignalStrength ss) {
-        if (ss.isGsm())
-            mSignalStrenth = ss.getGsmSignalStrength();
-    }
-
-    private int getCellInfo(JSONArray cellInfo) {
-        TelephonyManager tm = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);
-        if (tm == null)
-            return TelephonyManager.PHONE_TYPE_NONE;
-        List<NeighboringCellInfo> cells = tm.getNeighboringCellInfo();
-        CellLocation cl = tm.getCellLocation();
-        String mcc = "", mnc = "";
-        if (cl instanceof GsmCellLocation) {
-            JSONObject obj = new JSONObject();
-            GsmCellLocation gcl = (GsmCellLocation)cl;
-            try {
-                obj.put("lac", gcl.getLac());
-                obj.put("cid", gcl.getCid());
-
-                int psc = (Build.VERSION.SDK_INT >= 9) ? gcl.getPsc() : -1;
-                obj.put("psc", psc);
-
-                switch(tm.getNetworkType()) {
-                case TelephonyManager.NETWORK_TYPE_GPRS:
-                case TelephonyManager.NETWORK_TYPE_EDGE:
-                    obj.put("radio", "gsm");
-                    break;
-                case TelephonyManager.NETWORK_TYPE_UMTS:
-                case TelephonyManager.NETWORK_TYPE_HSDPA:
-                case TelephonyManager.NETWORK_TYPE_HSUPA:
-                case TelephonyManager.NETWORK_TYPE_HSPA:
-                case TelephonyManager.NETWORK_TYPE_HSPAP:
-                    obj.put("radio", "umts");
-                    break;
-                }
-                String mcc_mnc = tm.getNetworkOperator();
-                if (mcc_mnc.length() > 3) {
-                    mcc = mcc_mnc.substring(0, 3);
-                    mnc = mcc_mnc.substring(3);
-                    obj.put("mcc", mcc);
-                    obj.put("mnc", mnc);
-                }
-                obj.put("asu", mSignalStrenth);
-            } catch(JSONException jsonex) {}
-            cellInfo.put(obj);
-        }
-        if (cells != null) {
-            for (NeighboringCellInfo nci : cells) {
-                try {
-                    JSONObject obj = new JSONObject();
-                    obj.put("lac", nci.getLac());
-                    obj.put("cid", nci.getCid());
-                    obj.put("psc", nci.getPsc());
-                    obj.put("mcc", mcc);
-                    obj.put("mnc", mnc);
-
-                    int dbm;
-                    switch(nci.getNetworkType()) {
-                    case TelephonyManager.NETWORK_TYPE_GPRS:
-                    case TelephonyManager.NETWORK_TYPE_EDGE:
-                        obj.put("radio", "gsm");
-                        break;
-                    case TelephonyManager.NETWORK_TYPE_UMTS:
-                    case TelephonyManager.NETWORK_TYPE_HSDPA:
-                    case TelephonyManager.NETWORK_TYPE_HSUPA:
-                    case TelephonyManager.NETWORK_TYPE_HSPA:
-                    case TelephonyManager.NETWORK_TYPE_HSPAP:
-                        obj.put("radio", "umts");
-                        break;
-                    }
-
-                    obj.put("asu", nci.getRssi());
-                    cellInfo.put(obj);
-                } catch(JSONException jsonex) {}
-            }
-        }
-        return tm.getPhoneType();
-    }
-
-    private static boolean shouldLog(final ScanResult sr) {
-        return sr.SSID == null || !sr.SSID.endsWith("_nomap");
-    }
-
-    private void collectAndReportLocInfo(Location location) {
-        final JSONObject locInfo = new JSONObject();
-        WifiManager wm = (WifiManager)getSystemService(Context.WIFI_SERVICE);
-        wm.startScan();
-        try {
-            JSONArray cellInfo = new JSONArray();
-
-            String radioType = getRadioTypeName(getCellInfo(cellInfo));
-            if (radioType != null) {
-                locInfo.put("radio", radioType);
-            }
-
-            locInfo.put("lon", location.getLongitude());
-            locInfo.put("lat", location.getLatitude());
-
-            // If we have an accuracy, round it up to the next meter.
-            if (location.hasAccuracy()) {
-                locInfo.put("accuracy", (int) Math.ceil(location.getAccuracy()));
-            }
-
-            // If we have an altitude, round it to the nearest meter.
-            if (location.hasAltitude()) {
-                locInfo.put("altitude", Math.round(location.getAltitude()));
-            }
-
-            // Reduce timestamp precision so as to expose less PII.
-            DateFormat df = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
-            locInfo.put("time", df.format(new Date(location.getTime())));
-            locInfo.put("cell", cellInfo);
-
-            JSONArray wifiInfo = new JSONArray();
-            List<ScanResult> aps = wm.getScanResults();
-            if (aps != null) {
-                for (ScanResult ap : aps) {
-                    if (!shouldLog(ap))
-                        continue;
-
-                    JSONObject obj = new JSONObject();
-                    obj.put("key", ap.BSSID);
-                    obj.put("frequency", ap.frequency);
-                    obj.put("signal", ap.level);
-                    wifiInfo.put(obj);
-                }
-            }
-            locInfo.put("wifi", wifiInfo);
-        } catch (JSONException jsonex) {
-            Log.w(LOGTAG, "json exception", jsonex);
-            return;
-        }
-
-        ThreadUtils.postToBackgroundThread(new Runnable() {
-            public void run() {
-                try {
-                    URL url = new URL(LOCATION_URL);
-                    HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
-                    try {
-                        urlConnection.setDoOutput(true);
-
-                        // Workaround for a bug in Android HttpURLConnection. When the library
-                        // reuses a stale connection, the connection may fail with an EOFException.
-                        if (Build.VERSION.SDK_INT >= 14 && Build.VERSION.SDK_INT <= 18) {
-                            urlConnection.setRequestProperty("Connection", "Close");
-                        }
-
-                        JSONArray batch = new JSONArray();
-                        batch.put(locInfo);
-                        JSONObject wrapper = new JSONObject();
-                        wrapper.put("items", batch);
-                        byte[] bytes = wrapper.toString().getBytes();
-                        urlConnection.setFixedLengthStreamingMode(bytes.length);
-                        OutputStream out = new BufferedOutputStream(urlConnection.getOutputStream());
-                        out.write(bytes);
-                        out.flush();
-                    } catch (JSONException jsonex) {
-                        Log.e(LOGTAG, "error wrapping data as a batch", jsonex);
-                    } catch (IOException ioex) {
-                        Log.e(LOGTAG, "error submitting data", ioex);
-                    } finally {
-                        urlConnection.disconnect();
-                    }
-                } catch (IOException ioex) {
-                    Log.e(LOGTAG, "error submitting data", ioex);
-                }
-            }
-        });
-    }
-
-    private static String getRadioTypeName(int phoneType) {
-        switch (phoneType) {
-            case TelephonyManager.PHONE_TYPE_CDMA:
-                return "cdma";
-
-            case TelephonyManager.PHONE_TYPE_GSM:
-                return "gsm";
-
-            case TelephonyManager.PHONE_TYPE_NONE:
-            case TelephonyManager.PHONE_TYPE_SIP:
-                // These devices have no radio.
-                return null;
-
-            default:
-                Log.e(LOGTAG, "", new IllegalArgumentException("Unexpected PHONE_TYPE: " + phoneType));
-                return null;
-        }
-    }
-
-    @Override
-    public void onProviderDisabled(String provider)
-    {
-    }
-
-    @Override
-    public void onProviderEnabled(String provider)
-    {
-    }
-
-    @Override
-    public void onStatusChanged(String provider, int status, Bundle extras)
-    {
-    }
-
-    // Called when a Gecko Hal WakeLock is changed
-    public void notifyWakeLockChanged(String topic, String state) {
-        PowerManager.WakeLock wl = mWakeLocks.get(topic);
-        if (state.equals("locked-foreground") && wl == null) {
-            PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-            wl = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, topic);
-            wl.acquire();
-            mWakeLocks.put(topic, wl);
-        } else if (!state.equals("locked-foreground") && wl != null) {
-            wl.release();
-            mWakeLocks.remove(topic);
-        }
-    }
-
-    public void notifyCheckUpdateResult(String result) {
-        GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Update:CheckResult", result));
-    }
-
-    protected void geckoConnected() {
-        mLayerView.geckoConnected();
-        mLayerView.setOverScrollMode(View.OVER_SCROLL_NEVER);
-    }
-
-    public void setAccessibilityEnabled(boolean enabled) {
-    }
-
-    public static class MainLayout extends RelativeLayout {
-        private TouchEventInterceptor mTouchEventInterceptor;
-        private MotionEventInterceptor mMotionEventInterceptor;
-
-        public MainLayout(Context context, AttributeSet attrs) {
-            super(context, attrs);
-        }
-
-        public void setTouchEventInterceptor(TouchEventInterceptor interceptor) {
-            mTouchEventInterceptor = interceptor;
-        }
-
-        public void setMotionEventInterceptor(MotionEventInterceptor interceptor) {
-            mMotionEventInterceptor = interceptor;
-        }
-
-        @Override
-        public boolean onInterceptTouchEvent(MotionEvent event) {
-            if (mTouchEventInterceptor != null && mTouchEventInterceptor.onInterceptTouchEvent(this, event)) {
-                return true;
-            }
-            return super.onInterceptTouchEvent(event);
-        }
-
-        @Override
-        public boolean onTouchEvent(MotionEvent event) {
-            if (mTouchEventInterceptor != null && mTouchEventInterceptor.onTouch(this, event)) {
-                return true;
-            }
-            return super.onTouchEvent(event);
-        }
-
-        @Override
-        public boolean onGenericMotionEvent(MotionEvent event) {
-            if (mMotionEventInterceptor != null && mMotionEventInterceptor.onInterceptMotionEvent(this, event)) {
-                return true;
-            }
-            return super.onGenericMotionEvent(event);
-        }
-
-        @Override
-        public void setDrawingCacheEnabled(boolean enabled) {
-            // Instead of setting drawing cache in the view itself, we simply
-            // enable drawing caching on its children. This is mainly used in
-            // animations (see PropertyAnimator)
-            super.setChildrenDrawnWithCacheEnabled(enabled);
-        }
-    }
-
-    private class FullScreenHolder extends FrameLayout {
-
-        public FullScreenHolder(Context ctx) {
-            super(ctx);
-        }
-
-        @Override
-        public void addView(View view, int index) {
-            /**
-             * This normally gets called when Flash adds a separate SurfaceView
-             * for the video. It is unhappy if we have the LayerView underneath
-             * it for some reason so we need to hide that. Hiding the LayerView causes
-             * its surface to be destroyed, which causes a pause composition
-             * event to be sent to Gecko. We synchronously wait for that to be
-             * processed. Simultaneously, however, Flash is waiting on a mutex so
-             * the post() below is an attempt to avoid a deadlock.
-             */
-            super.addView(view, index);
-
-            ThreadUtils.postToUiThread(new Runnable() {
-                @Override
-                public void run() {
-                    mLayerView.hideSurface();
-                }
-            });
-        }
-
-        /**
-         * The methods below are simply copied from what Android WebKit does.
-         * It wasn't ever called in my testing, but might as well
-         * keep it in case it is for some reason. The methods
-         * all return true because we don't want any events
-         * leaking out from the fullscreen view.
-         */
-        @Override
-        public boolean onKeyDown(int keyCode, KeyEvent event) {
-            if (event.isSystem()) {
-                return super.onKeyDown(keyCode, event);
-            }
-            mFullScreenPluginView.onKeyDown(keyCode, event);
-            return true;
-        }
-
-        @Override
-        public boolean onKeyUp(int keyCode, KeyEvent event) {
-            if (event.isSystem()) {
-                return super.onKeyUp(keyCode, event);
-            }
-            mFullScreenPluginView.onKeyUp(keyCode, event);
-            return true;
-        }
-
-        @Override
-        public boolean onTouchEvent(MotionEvent event) {
-            return true;
-        }
-
-        @Override
-        public boolean onTrackballEvent(MotionEvent event) {
-            mFullScreenPluginView.onTrackballEvent(event);
-            return true;
-        }
-    }
-
-    protected NotificationClient makeNotificationClient() {
-        // Don't use a notification service; we may be killed in the background
-        // during downloads.
-        return new AppNotificationClient(getApplicationContext());
-    }
-
-    private int getVersionCode() {
-        int versionCode = 0;
-        try {
-            versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;
-        } catch (NameNotFoundException e) {
-            Log.wtf(LOGTAG, getPackageName() + " not found", e);
-        }
-        return versionCode;
-    }
-
-    protected boolean getIsDebuggable() {
-        // Return false so Fennec doesn't appear to be debuggable.  WebappImpl
-        // then overrides this and returns the value of android:debuggable for
-        // the webapp APK, so webapps get the behavior supported by this method
-        // (i.e. automatic configuration and enabling of the remote debugger).
-        return false;
-
-        // If we ever want to expose this for Fennec, here's how we would do it:
-        // int flags = 0;
-        // try {
-        //     flags = getPackageManager().getPackageInfo(getPackageName(), 0).applicationInfo.flags;
-        // } catch (NameNotFoundException e) {
-        //     Log.wtf(LOGTAG, getPackageName() + " not found", e);
-        // }
-        // return (flags & android.content.pm.ApplicationInfo.FLAG_DEBUGGABLE) != 0;
-    }
-
-    // FHR reason code for a session end prior to a restart for a
-    // locale change.
-    private static final String SESSION_END_LOCALE_CHANGED = "L";
-
-    /**
-     * Use LocaleManager to change our persisted and current locales,
-     * and poke HealthRecorder to tell it of our changed state.
-     */
-    private void setLocale(final String locale) {
-        if (locale == null) {
-            return;
-        }
-        final String resultant = LocaleManager.setSelectedLocale(locale);
-        if (resultant == null) {
-            return;
-        }
-
-        final boolean startNewSession = true;
-        final boolean shouldRestart = false;
-
-        // If the HealthRecorder is not yet initialized (unlikely), the locale change won't
-        // trigger a session transition and subsequent events will be recorded in an environment
-        // with the wrong locale.
-        final HealthRecorder rec = mHealthRecorder;
-        if (rec != null) {
-            rec.onAppLocaleChanged(resultant);
-            rec.onEnvironmentChanged(startNewSession, SESSION_END_LOCALE_CHANGED);
-        }
-
-        if (!shouldRestart) {
-            ThreadUtils.postToUiThread(new Runnable() {
-                @Override
-                public void run() {
-                    GeckoApp.this.onLocaleReady(resultant);
-                }
-            });
-            return;
-        }
-
-        // Do this in the background so that the health recorder has its
-        // time to finish.
-        ThreadUtils.postToBackgroundThread(new Runnable() {
-            @Override
-            public void run() {
-                GeckoApp.this.doRestart();
-                GeckoApp.this.finish();
-            }
-        });
-    }
-
-    private void setSystemUiVisible(final boolean visible) {
-        if (Build.VERSION.SDK_INT < 14) {
-            return;
-        }
-
-        ThreadUtils.postToUiThread(new Runnable() {
-            @Override
-            public void run() {
-                if (visible) {
-                    mMainLayout.setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE);
-                } else {
-                    mMainLayout.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE);
-                }
-            }
-        });
-    }
-
-    protected HealthRecorder createHealthRecorder(final Context context,
-                                                  final String profilePath,
-                                                  final EventDispatcher dispatcher,
-                                                  final String osLocale,
-                                                  final String appLocale,
-                                                  final SessionInformation previousSession) {
-        // GeckoApp does not need to record any health information - return a stub.
-        return new StubbedHealthRecorder();
-    }
+	}
+
+	@Override
+	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+		if (!ActivityHandlerHelper.handleActivityResult(requestCode, resultCode, data)) {
+			super.onActivityResult(requestCode, resultCode, data);
+		}
+	}
+
+	public AbsoluteLayout getPluginContainer() {
+		return mPluginContainer;
+	}
+
+	// Accelerometer.
+	@Override
+	public void onAccuracyChanged(Sensor sensor, int accuracy) {
+	}
+
+	@Override
+	public void onSensorChanged(SensorEvent event) {
+		GeckoAppShell.sendEventToGecko(GeckoEvent.createSensorEvent(event));
+	}
+
+	// Geolocation.
+	@Override
+	public void onLocationChanged(Location location) {
+		// No logging here: user-identifying information.
+		GeckoAppShell.sendEventToGecko(GeckoEvent.createLocationEvent(location));
+		if (mShouldReportGeoData)
+			collectAndReportLocInfo(location);
+	}
+
+	public void setCurrentSignalStrenth(SignalStrength ss) {
+		if (ss.isGsm())
+			mSignalStrenth = ss.getGsmSignalStrength();
+	}
+
+	private int getCellInfo(JSONArray cellInfo) {
+		TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
+		if (tm == null)
+			return TelephonyManager.PHONE_TYPE_NONE;
+		List<NeighboringCellInfo> cells = tm.getNeighboringCellInfo();
+		CellLocation cl = tm.getCellLocation();
+		String mcc = "", mnc = "";
+		if (cl instanceof GsmCellLocation) {
+			JSONObject obj = new JSONObject();
+			GsmCellLocation gcl = (GsmCellLocation) cl;
+			try {
+				obj.put("lac", gcl.getLac());
+				obj.put("cid", gcl.getCid());
+
+				int psc = (Build.VERSION.SDK_INT >= 9) ? gcl.getPsc() : -1;
+				obj.put("psc", psc);
+
+				switch (tm.getNetworkType()) {
+					case TelephonyManager.NETWORK_TYPE_GPRS:
+					case TelephonyManager.NETWORK_TYPE_EDGE:
+						obj.put("radio", "gsm");
+						break;
+					case TelephonyManager.NETWORK_TYPE_UMTS:
+					case TelephonyManager.NETWORK_TYPE_HSDPA:
+					case TelephonyManager.NETWORK_TYPE_HSUPA:
+					case TelephonyManager.NETWORK_TYPE_HSPA:
+					case TelephonyManager.NETWORK_TYPE_HSPAP:
+						obj.put("radio", "umts");
+						break;
+				}
+				String mcc_mnc = tm.getNetworkOperator();
+				if (mcc_mnc.length() > 3) {
+					mcc = mcc_mnc.substring(0, 3);
+					mnc = mcc_mnc.substring(3);
+					obj.put("mcc", mcc);
+					obj.put("mnc", mnc);
+				}
+				obj.put("asu", mSignalStrenth);
+			} catch (JSONException jsonex) {
+			}
+			cellInfo.put(obj);
+		}
+		if (cells != null) {
+			for (NeighboringCellInfo nci : cells) {
+				try {
+					JSONObject obj = new JSONObject();
+					obj.put("lac", nci.getLac());
+					obj.put("cid", nci.getCid());
+					obj.put("psc", nci.getPsc());
+					obj.put("mcc", mcc);
+					obj.put("mnc", mnc);
+
+					int dbm;
+					switch (nci.getNetworkType()) {
+						case TelephonyManager.NETWORK_TYPE_GPRS:
+						case TelephonyManager.NETWORK_TYPE_EDGE:
+							obj.put("radio", "gsm");
+							break;
+						case TelephonyManager.NETWORK_TYPE_UMTS:
+						case TelephonyManager.NETWORK_TYPE_HSDPA:
+						case TelephonyManager.NETWORK_TYPE_HSUPA:
+						case TelephonyManager.NETWORK_TYPE_HSPA:
+						case TelephonyManager.NETWORK_TYPE_HSPAP:
+							obj.put("radio", "umts");
+							break;
+					}
+
+					obj.put("asu", nci.getRssi());
+					cellInfo.put(obj);
+				} catch (JSONException jsonex) {
+				}
+			}
+		}
+		return tm.getPhoneType();
+	}
+
+	private static boolean shouldLog(final ScanResult sr) {
+		return sr.SSID == null || !sr.SSID.endsWith("_nomap");
+	}
+
+	private void collectAndReportLocInfo(Location location) {
+		final JSONObject locInfo = new JSONObject();
+		WifiManager wm = (WifiManager) getSystemService(Context.WIFI_SERVICE);
+		wm.startScan();
+		try {
+			JSONArray cellInfo = new JSONArray();
+
+			String radioType = getRadioTypeName(getCellInfo(cellInfo));
+			if (radioType != null) {
+				locInfo.put("radio", radioType);
+			}
+
+			locInfo.put("lon", location.getLongitude());
+			locInfo.put("lat", location.getLatitude());
+
+			// If we have an accuracy, round it up to the next meter.
+			if (location.hasAccuracy()) {
+				locInfo.put("accuracy", (int) Math.ceil(location.getAccuracy()));
+			}
+
+			// If we have an altitude, round it to the nearest meter.
+			if (location.hasAltitude()) {
+				locInfo.put("altitude", Math.round(location.getAltitude()));
+			}
+
+			// Reduce timestamp precision so as to expose less PII.
+			DateFormat df = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
+			locInfo.put("time", df.format(new Date(location.getTime())));
+			locInfo.put("cell", cellInfo);
+
+			JSONArray wifiInfo = new JSONArray();
+			List<ScanResult> aps = wm.getScanResults();
+			if (aps != null) {
+				for (ScanResult ap : aps) {
+					if (!shouldLog(ap))
+						continue;
+
+					JSONObject obj = new JSONObject();
+					obj.put("key", ap.BSSID);
+					obj.put("frequency", ap.frequency);
+					obj.put("signal", ap.level);
+					wifiInfo.put(obj);
+				}
+			}
+			locInfo.put("wifi", wifiInfo);
+		} catch (JSONException jsonex) {
+			Log.w(LOGTAG, "json exception", jsonex);
+			return;
+		}
+
+		ThreadUtils.postToBackgroundThread(new Runnable() {
+			public void run() {
+				try {
+					URL url = new URL(LOCATION_URL);
+					HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
+					try {
+						urlConnection.setDoOutput(true);
+
+						// Workaround for a bug in Android HttpURLConnection. When the library
+						// reuses a stale connection, the connection may fail with an EOFException.
+						if (Build.VERSION.SDK_INT >= 14 && Build.VERSION.SDK_INT <= 18) {
+							urlConnection.setRequestProperty("Connection", "Close");
+						}
+
+						JSONArray batch = new JSONArray();
+						batch.put(locInfo);
+						JSONObject wrapper = new JSONObject();
+						wrapper.put("items", batch);
+						byte[] bytes = wrapper.toString().getBytes();
+						urlConnection.setFixedLengthStreamingMode(bytes.length);
+						OutputStream out = new BufferedOutputStream(urlConnection.getOutputStream());
+						out.write(bytes);
+						out.flush();
+					} catch (JSONException jsonex) {
+						Log.e(LOGTAG, "error wrapping data as a batch", jsonex);
+					} catch (IOException ioex) {
+						Log.e(LOGTAG, "error submitting data", ioex);
+					} finally {
+						urlConnection.disconnect();
+					}
+				} catch (IOException ioex) {
+					Log.e(LOGTAG, "error submitting data", ioex);
+				}
+			}
+		});
+	}
+
+	private static String getRadioTypeName(int phoneType) {
+		switch (phoneType) {
+			case TelephonyManager.PHONE_TYPE_CDMA:
+				return "cdma";
+
+			case TelephonyManager.PHONE_TYPE_GSM:
+				return "gsm";
+
+			case TelephonyManager.PHONE_TYPE_NONE:
+			case TelephonyManager.PHONE_TYPE_SIP:
+				// These devices have no radio.
+				return null;
+
+			default:
+				Log.e(LOGTAG, "", new IllegalArgumentException("Unexpected PHONE_TYPE: " + phoneType));
+				return null;
+		}
+	}
+
+	@Override
+	public void onProviderDisabled(String provider) {
+	}
+
+	@Override
+	public void onProviderEnabled(String provider) {
+	}
+
+	@Override
+	public void onStatusChanged(String provider, int status, Bundle extras) {
+	}
+
+	// Called when a Gecko Hal WakeLock is changed
+	public void notifyWakeLockChanged(String topic, String state) {
+		PowerManager.WakeLock wl = mWakeLocks.get(topic);
+		if (state.equals("locked-foreground") && wl == null) {
+			PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
+			wl = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, topic);
+			wl.acquire();
+			mWakeLocks.put(topic, wl);
+		} else if (!state.equals("locked-foreground") && wl != null) {
+			wl.release();
+			mWakeLocks.remove(topic);
+		}
+	}
+
+	public void notifyCheckUpdateResult(String result) {
+		GeckoAppShell.sendEventToGecko(GeckoEvent.createBroadcastEvent("Update:CheckResult", result));
+	}
+
+	protected void geckoConnected() {
+		mLayerView.geckoConnected();
+		mLayerView.setOverScrollMode(View.OVER_SCROLL_NEVER);
+	}
+
+	public void setAccessibilityEnabled(boolean enabled) {
+	}
+
+	public static class MainLayout extends RelativeLayout {
+		private TouchEventInterceptor mTouchEventInterceptor;
+		private MotionEventInterceptor mMotionEventInterceptor;
+
+		public MainLayout(Context context, AttributeSet attrs) {
+			super(context, attrs);
+		}
+
+		public void setTouchEventInterceptor(TouchEventInterceptor interceptor) {
+			mTouchEventInterceptor = interceptor;
+		}
+
+		public void setMotionEventInterceptor(MotionEventInterceptor interceptor) {
+			mMotionEventInterceptor = interceptor;
+		}
+
+		@Override
+		public boolean onInterceptTouchEvent(MotionEvent event) {
+			if (mTouchEventInterceptor != null && mTouchEventInterceptor.onInterceptTouchEvent(this, event)) {
+				return true;
+			}
+			return super.onInterceptTouchEvent(event);
+		}
+
+		@Override
+		public boolean onTouchEvent(MotionEvent event) {
+			if (mTouchEventInterceptor != null && mTouchEventInterceptor.onTouch(this, event)) {
+				return true;
+			}
+			return super.onTouchEvent(event);
+		}
+
+		@Override
+		public boolean onGenericMotionEvent(MotionEvent event) {
+			if (mMotionEventInterceptor != null && mMotionEventInterceptor.onInterceptMotionEvent(this, event)) {
+				return true;
+			}
+			return super.onGenericMotionEvent(event);
+		}
+
+		@Override
+		public void setDrawingCacheEnabled(boolean enabled) {
+			// Instead of setting drawing cache in the view itself, we simply
+			// enable drawing caching on its children. This is mainly used in
+			// animations (see PropertyAnimator)
+			super.setChildrenDrawnWithCacheEnabled(enabled);
+		}
+	}
+
+	private class FullScreenHolder extends FrameLayout {
+
+		public FullScreenHolder(Context ctx) {
+			super(ctx);
+		}
+
+		@Override
+		public void addView(View view, int index) {
+			/**
+			 * This normally gets called when Flash adds a separate SurfaceView
+			 * for the video. It is unhappy if we have the LayerView underneath
+			 * it for some reason so we need to hide that. Hiding the LayerView causes
+			 * its surface to be destroyed, which causes a pause composition
+			 * event to be sent to Gecko. We synchronously wait for that to be
+			 * processed. Simultaneously, however, Flash is waiting on a mutex so
+			 * the post() below is an attempt to avoid a deadlock.
+			 */
+			super.addView(view, index);
+
+			ThreadUtils.postToUiThread(new Runnable() {
+				@Override
+				public void run() {
+					mLayerView.hideSurface();
+				}
+			});
+		}
+
+		/**
+		 * The methods below are simply copied from what Android WebKit does.
+		 * It wasn't ever called in my testing, but might as well
+		 * keep it in case it is for some reason. The methods
+		 * all return true because we don't want any events
+		 * leaking out from the fullscreen view.
+		 */
+		@Override
+		public boolean onKeyDown(int keyCode, KeyEvent event) {
+			if (event.isSystem()) {
+				return super.onKeyDown(keyCode, event);
+			}
+			mFullScreenPluginView.onKeyDown(keyCode, event);
+			return true;
+		}
+
+		@Override
+		public boolean onKeyUp(int keyCode, KeyEvent event) {
+			if (event.isSystem()) {
+				return super.onKeyUp(keyCode, event);
+			}
+			mFullScreenPluginView.onKeyUp(keyCode, event);
+			return true;
+		}
+
+		@Override
+		public boolean onTouchEvent(MotionEvent event) {
+			return true;
+		}
+
+		@Override
+		public boolean onTrackballEvent(MotionEvent event) {
+			mFullScreenPluginView.onTrackballEvent(event);
+			return true;
+		}
+	}
+
+	protected NotificationClient makeNotificationClient() {
+		// Don't use a notification service; we may be killed in the background
+		// during downloads.
+		return new AppNotificationClient(getApplicationContext());
+	}
+
+	private int getVersionCode() {
+		int versionCode = 0;
+		try {
+			versionCode = getPackageManager().getPackageInfo(getPackageName(), 0).versionCode;
+		} catch (NameNotFoundException e) {
+			Log.wtf(LOGTAG, getPackageName() + " not found", e);
+		}
+		return versionCode;
+	}
+
+	protected boolean getIsDebuggable() {
+		// Return false so Fennec doesn't appear to be debuggable.  WebappImpl
+		// then overrides this and returns the value of android:debuggable for
+		// the webapp APK, so webapps get the behavior supported by this method
+		// (i.e. automatic configuration and enabling of the remote debugger).
+		return false;
+
+		// If we ever want to expose this for Fennec, here's how we would do it:
+		// int flags = 0;
+		// try {
+		//     flags = getPackageManager().getPackageInfo(getPackageName(), 0).applicationInfo.flags;
+		// } catch (NameNotFoundException e) {
+		//     Log.wtf(LOGTAG, getPackageName() + " not found", e);
+		// }
+		// return (flags & android.content.pm.ApplicationInfo.FLAG_DEBUGGABLE) != 0;
+	}
+
+	// FHR reason code for a session end prior to a restart for a
+	// locale change.
+	private static final String SESSION_END_LOCALE_CHANGED = "L";
+
+	/**
+	 * Use LocaleManager to change our persisted and current locales,
+	 * and poke HealthRecorder to tell it of our changed state.
+	 */
+	private void setLocale(final String locale) {
+		if (locale == null) {
+			return;
+		}
+		final String resultant = LocaleManager.setSelectedLocale(locale);
+		if (resultant == null) {
+			return;
+		}
+
+		final boolean startNewSession = true;
+		final boolean shouldRestart = false;
+
+		// If the HealthRecorder is not yet initialized (unlikely), the locale change won't
+		// trigger a session transition and subsequent events will be recorded in an environment
+		// with the wrong locale.
+		final HealthRecorder rec = mHealthRecorder;
+		if (rec != null) {
+			rec.onAppLocaleChanged(resultant);
+			rec.onEnvironmentChanged(startNewSession, SESSION_END_LOCALE_CHANGED);
+		}
+
+		if (!shouldRestart) {
+			ThreadUtils.postToUiThread(new Runnable() {
+				@Override
+				public void run() {
+					GeckoApp.this.onLocaleReady(resultant);
+				}
+			});
+			return;
+		}
+
+		// Do this in the background so that the health recorder has its
+		// time to finish.
+		ThreadUtils.postToBackgroundThread(new Runnable() {
+			@Override
+			public void run() {
+				GeckoApp.this.doRestart();
+				GeckoApp.this.finish();
+			}
+		});
+	}
+
+	private void setSystemUiVisible(final boolean visible) {
+		if (Build.VERSION.SDK_INT < 14) {
+			return;
+		}
+
+		ThreadUtils.postToUiThread(new Runnable() {
+			@Override
+			public void run() {
+				if (visible) {
+					mMainLayout.setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE);
+				} else {
+					mMainLayout.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE);
+				}
+			}
+		});
+	}
+
+	protected HealthRecorder createHealthRecorder(final Context context,
+	                                              final String profilePath,
+	                                              final EventDispatcher dispatcher,
+	                                              final String osLocale,
+	                                              final String appLocale,
+	                                              final SessionInformation previousSession) {
+		// GeckoApp does not need to record any health information - return a stub.
+		return new StubbedHealthRecorder();
+	}
 }
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/base/GeckoApplication.java
--- a/mobile/android/base/GeckoApplication.java	Mon Mar 31 18:21:24 2014 +0700
+++ b/mobile/android/base/GeckoApplication.java	Tue Apr 08 21:42:33 2014 +0700
@@ -99,7 +99,10 @@
         FilePicker.init(getApplicationContext());
         GeckoLoader.loadMozGlue();
         HomeConfigInvalidator.getInstance().init(getApplicationContext());
-        super.onCreate();
+	    //Auto play flash
+	    org.mozilla.gecko.PrefsHelper.setPref("plugin.enable", "1");
+
+	    super.onCreate();
     }
 
     public boolean isApplicationInBackground() {
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/base/resources/drawable-hdpi/g_exit_bar_bg_phone.9.png
Binary file mobile/android/base/resources/drawable-hdpi/g_exit_bar_bg_phone.9.png has changed
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/base/resources/drawable-hdpi/z_icon.png
Binary file mobile/android/base/resources/drawable-hdpi/z_icon.png has changed
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/base/resources/layout/gecko_app.xml
--- a/mobile/android/base/resources/layout/gecko_app.xml	Mon Mar 31 18:21:24 2014 +0700
+++ b/mobile/android/base/resources/layout/gecko_app.xml	Tue Apr 08 21:42:33 2014 +0700
@@ -2,119 +2,166 @@
 <!-- This Source Code Form is subject to the terms of the Mozilla Public
    - License, v. 2.0. If a copy of the MPL was not distributed with this
    - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
+<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              xmlns:gecko="http://schemas.android.com/apk/res-auto"
+              android:layout_width="fill_parent"
+              android:layout_height="wrap_content">
 
-<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
-                xmlns:gecko="http://schemas.android.com/apk/res-auto"
-                android:layout_width="fill_parent"
-                android:layout_height="fill_parent">
+    <RelativeLayout
+            android:id="@+id/z_back_bar"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:background="@drawable/g_exit_bar_bg_phone"
+            android:layout_alignParentTop="true"
+            android:visibility="gone">
 
-    <ViewStub android:id="@+id/tabs_panel"
-              android:layout="@layout/tabs_panel_view"
+        <ImageView
+                android:id="@+id/game_exit_icon"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_centerHorizontal="true"
+                android:clickable="false"
+                android:paddingLeft="5dp"
+                android:paddingRight="5dp"
+                android:layout_centerVertical="true"
+                android:src="@drawable/z_icon"/>
+
+        <TextView
+                android:id="@+id/game_exit_header_left"
+                android:textColor="#999"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_centerVertical="true"
+                android:layout_toLeftOf="@id/game_exit_icon"
+                android:text="@string/gameplay_exit_left"/>
+
+        <TextView
+                android:id="@+id/game_exit_header_right"
+                android:textColor="#999"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_centerVertical="true"
+                android:layout_toRightOf="@id/game_exit_icon"
+                android:text="@string/gameplay_exit_right"/>
+
+    </RelativeLayout>
+
+    <RelativeLayout
+            android:layout_width="fill_parent"
+            android:layout_height="fill_parent"
+            android:layout_below="@id/z_back_bar">
+
+        <ViewStub android:id="@+id/tabs_panel"
+                  android:layout="@layout/tabs_panel_view"
+                  android:layout_width="fill_parent"
+                  android:layout_height="fill_parent"/>
+
+        <view class="org.mozilla.gecko.GeckoApp$MainLayout"
+              android:id="@+id/main_layout"
               android:layout_width="fill_parent"
-              android:layout_height="fill_parent"/>
+              android:layout_height="fill_parent"
+              android:background="@android:color/transparent">
 
-   <view class="org.mozilla.gecko.GeckoApp$MainLayout"
-         android:id="@+id/main_layout"
-         android:layout_width="fill_parent"
-         android:layout_height="fill_parent"
-         android:background="@android:color/transparent">
 
-        <RelativeLayout android:id="@+id/gecko_layout"
-                        android:layout_width="fill_parent"
-                        android:layout_height="fill_parent"
-                        android:layout_above="@+id/find_in_page">
+            <RelativeLayout android:id="@+id/gecko_layout"
+                            android:layout_width="fill_parent"
+                            android:layout_height="fill_parent"
+                            android:layout_above="@+id/find_in_page">
+                >
 
-            <include layout="@layout/shared_ui_components"/>
+                <include layout="@layout/shared_ui_components"/>
 
-            <FrameLayout android:id="@+id/home_pager_container"
+                <FrameLayout android:id="@+id/home_pager_container"
+                             android:layout_width="fill_parent"
+                             android:layout_height="fill_parent"
+                             android:visibility="gone">
+
+                    <ViewStub android:id="@+id/home_pager_stub"
+                              android:layout="@layout/home_pager"
+                              android:layout_width="fill_parent"
+                              android:layout_height="fill_parent"/>
+
+                    <ViewStub android:id="@+id/home_banner_stub"
+                              android:layout="@layout/home_banner"
+                              android:layout_width="fill_parent"
+                              android:layout_height="@dimen/home_banner_height"
+                              android:layout_gravity="bottom"/>
+
+                </FrameLayout>
+
+            </RelativeLayout>
+
+            <org.mozilla.gecko.FindInPageBar android:id="@+id/find_in_page"
+                                             android:layout_width="fill_parent"
+                                             android:layout_height="wrap_content"
+                                             android:layout_alignParentBottom="true"
+                                             style="@style/FindBar"
+                                             android:visibility="gone"/>
+
+            <org.mozilla.gecko.MediaCastingBar android:id="@+id/media_casting"
+                                               android:layout_width="fill_parent"
+                                               android:layout_height="wrap_content"
+                                               android:layout_alignParentBottom="true"
+                                               style="@style/FindBar"
+                                               android:visibility="gone"/>
+
+            <RelativeLayout android:id="@+id/camera_layout"
+                            android:layout_height="wrap_content"
+                            android:layout_width="wrap_content"
+                            android:layout_alignParentRight="true"
+                            android:layout_alignParentBottom="true">
+            </RelativeLayout>
+
+            <FrameLayout android:id="@+id/search_container"
                          android:layout_width="fill_parent"
                          android:layout_height="fill_parent"
-                         android:visibility="gone">
+                         android:layout_below="@+id/browser_actionbar"
+                         android:background="@android:color/white"
+                         android:visibility="invisible"/>
 
-                <ViewStub android:id="@+id/home_pager_stub"
-                          android:layout="@layout/home_pager"
-                          android:layout_width="fill_parent"
-                          android:layout_height="fill_parent"/>
+            <!-- When focus is cleared from from BrowserToolbar's EditText to
+                 lower the virtual keyboard, focus will be returned to the root
+                 view. To make sure the EditText is not the first focusable view in
+                 the root view, BrowserToolbar should be specified as low in the
+                 view hierarchy as possible. -->
 
-                <ViewStub android:id="@+id/home_banner_stub"
-                          android:layout="@layout/home_banner"
-                          android:layout_width="fill_parent"
-                          android:layout_height="@dimen/home_banner_height"
-                          android:layout_gravity="bottom"/>
 
-            </FrameLayout>
+            <org.mozilla.gecko.widget.GeckoViewFlipper android:id="@id/browser_actionbar"
+                                                       android:layout_width="fill_parent"
+                                                       android:layout_height="@dimen/browser_toolbar_height"
+                                                       android:clickable="true"
+                                                       android:focusable="true">
 
-        </RelativeLayout>
+                <org.mozilla.gecko.toolbar.BrowserToolbar
+                        android:id="@+id/browser_toolbar"
+                        style="@style/BrowserToolbar"
+                        android:layout_width="fill_parent"
+                        android:layout_height="@dimen/browser_toolbar_height"
+                        android:clickable="true"
+                        android:focusable="true"
+                        android:background="@drawable/url_bar_bg"/>
 
-        <org.mozilla.gecko.FindInPageBar android:id="@+id/find_in_page"
-                                         android:layout_width="fill_parent"
-                                         android:layout_height="wrap_content"
-                                         android:layout_alignParentBottom="true"
-                                         style="@style/FindBar"
-                                         android:visibility="gone"/>
+                <org.mozilla.gecko.ActionModeCompatView android:id="@+id/actionbar"
+                                                        android:layout_height="fill_parent"
+                                                        android:layout_width="fill_parent"
+                                                        style="@style/GeckoActionBar"/>
 
-        <org.mozilla.gecko.MediaCastingBar android:id="@+id/media_casting"
-                                           android:layout_width="fill_parent"
-                                           android:layout_height="wrap_content"
-                                           android:layout_alignParentBottom="true"
-                                           style="@style/FindBar"
-                                           android:visibility="gone"/>
+            </org.mozilla.gecko.widget.GeckoViewFlipper>
 
-        <RelativeLayout android:id="@+id/camera_layout"
-                        android:layout_height="wrap_content"
-                        android:layout_width="wrap_content"
-                        android:layout_alignParentRight="true"
-                        android:layout_alignParentBottom="true">
-        </RelativeLayout>
+            <org.mozilla.gecko.toolbar.ToolbarProgressView android:id="@+id/progress"
+                                                           android:layout_width="fill_parent"
+                                                           android:layout_height="14dp"
+                                                           android:layout_marginTop="-8dp"
+                                                           android:layout_below="@id/browser_actionbar"
+                                                           android:src="@drawable/progress"
+                                                           android:background="@null"
+                                                           android:visibility="gone"/>
 
-        <FrameLayout android:id="@+id/search_container"
-                     android:layout_width="fill_parent"
-                     android:layout_height="fill_parent"
-                     android:layout_below="@+id/browser_actionbar"
-                     android:background="@android:color/white"
-                     android:visibility="invisible"/>
+        </view>
 
-        <!-- When focus is cleared from from BrowserToolbar's EditText to
-             lower the virtual keyboard, focus will be returned to the root
-             view. To make sure the EditText is not the first focusable view in
-             the root view, BrowserToolbar should be specified as low in the
-             view hierarchy as possible. -->
+        <ViewStub android:id="@+id/toast_stub"
+                  android:layout="@layout/button_toast"
+                  style="@style/Toast"/>
 
-        <org.mozilla.gecko.widget.GeckoViewFlipper android:id="@id/browser_actionbar"
-                android:layout_width="fill_parent"
-                android:layout_height="@dimen/browser_toolbar_height"
-                android:clickable="true"
-                android:focusable="true">
-
-            <org.mozilla.gecko.toolbar.BrowserToolbar
-                android:id="@+id/browser_toolbar"
-                style="@style/BrowserToolbar"
-                android:layout_width="fill_parent"
-                android:layout_height="@dimen/browser_toolbar_height"
-                android:clickable="true"
-                android:focusable="true"
-                android:background="@drawable/url_bar_bg"/>
-
-            <org.mozilla.gecko.ActionModeCompatView android:id="@+id/actionbar"
-                                                    android:layout_height="fill_parent"
-                                                    android:layout_width="fill_parent"
-                                                    style="@style/GeckoActionBar"/>
-
-        </org.mozilla.gecko.widget.GeckoViewFlipper>
-
-        <org.mozilla.gecko.toolbar.ToolbarProgressView android:id="@+id/progress"
-                                                       android:layout_width="fill_parent"
-                                                       android:layout_height="14dp"
-                                                       android:layout_marginTop="-8dp"
-                                                       android:layout_below="@id/browser_actionbar"
-                                                       android:src="@drawable/progress"
-                                                       android:background="@null"
-                                                       android:visibility="gone" />
-
-    </view>
-
-    <ViewStub android:id="@+id/toast_stub"
-              android:layout="@layout/button_toast"
-              style="@style/Toast"/>
-
-</RelativeLayout>
+    </RelativeLayout>
+</RelativeLayout>
\ No newline at end of file
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/base/strings.xml.in
--- a/mobile/android/base/strings.xml.in	Mon Mar 31 18:21:24 2014 +0700
+++ b/mobile/android/base/strings.xml.in	Tue Apr 08 21:42:33 2014 +0700
@@ -402,4 +402,6 @@
   <!-- Miscellaneous -->
   <string name="ellipsis">&ellipsis;</string>
 
+  <string name="gameplay_exit_left">Tap this</string>
+  <string name="gameplay_exit_right">to go back</string>
 </resources>
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/branding/official/configure.sh
--- a/mobile/android/branding/official/configure.sh	Mon Mar 31 18:21:24 2014 +0700
+++ b/mobile/android/branding/official/configure.sh	Tue Apr 08 21:42:33 2014 +0700
@@ -2,7 +2,12 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-MOZ_APP_DISPLAYNAME=Firefox
-ANDROID_PACKAGE_NAME=org.mozilla.firefox
+
+ANDROID_PACKAGE_NAME=com.zoodles.kidbrowser
+MOZ_APP_DISPLAYNAME="Zoodles Kid Browser"
 MOZ_UPDATER=
 MOZ_ANDROID_ANR_REPORTER=
+MOZ_TELEMETRY_REPORTING=
+MOZ_SERVICES_HEALTHREPORT=
+MOZ_CRASHREPORTER=
+
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/branding/unofficial/configure.sh
--- a/mobile/android/branding/unofficial/configure.sh	Mon Mar 31 18:21:24 2014 +0700
+++ b/mobile/android/branding/unofficial/configure.sh	Tue Apr 08 21:42:33 2014 +0700
@@ -2,7 +2,11 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-ANDROID_PACKAGE_NAME=org.mozilla.fennec_`echo $USER`
-MOZ_APP_DISPLAYNAME="Fennec `echo $USER`"
+ANDROID_PACKAGE_NAME=com.zoodles.kidbrowser
+MOZ_APP_DISPLAYNAME="Zoodles Kid Browser"
 MOZ_UPDATER=
 MOZ_ANDROID_ANR_REPORTER=
+MOZ_TELEMETRY_REPORTING=
+MOZ_SERVICES_HEALTHREPORT=
+MOZ_CRASHREPORTER=
+
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/chrome/content/about.xhtml
--- a/mobile/android/chrome/content/about.xhtml	Mon Mar 31 18:21:24 2014 +0700
+++ b/mobile/android/chrome/content/about.xhtml	Tue Apr 08 21:42:33 2014 +0700
@@ -22,52 +22,15 @@
 </head>
 
 <body dir="&locale.dir;">
-  <div id="header">
-    <div id="wordmark"></div>
-#expand <p id="version">__MOZ_APP_VERSION__</p>
-  </div>
-
-  <div id="banner">
-    <div id="logo"/>
-#ifdef MOZ_UPDATER
-    <div id="updateBox">
-      <a id="updateLink" href="" onclick="checkForUpdates();">&aboutPage.checkForUpdates.link;</a>
-      <span id="update-message-checking">&aboutPage.checkForUpdates.checking;</span>
-      <span id="update-message-none">&aboutPage.checkForUpdates.none;</span>
-      <span id="update-message-found" onclick="downloadUpdate()">&aboutPage.checkForUpdates.available2;</span>
-      <span id="update-message-downloading">&aboutPage.checkForUpdates.downloading;</span>
-      <span id="update-message-downloaded" onclick="installUpdate()">&aboutPage.checkForUpdates.downloaded2;</span>
-    </div>
-#endif
-
-    <div id="messages">
-      <p id="distributionAbout" hidden="true"/>
-      <p id="distributionID" hidden="true"/>
-      <p id="telemetry" hidden="true">
-        &aboutPage.warningVersion;
-#ifdef MOZ_TELEMETRY_ON_BY_DEFAULT
-        &aboutPage.telemetryStart;<a href="http://www.mozilla.org/">&aboutPage.telemetryMozillaLink;</a>&aboutPage.telemetryEnd;
-#endif
-      </p>
-    </div>
-
-  </div>
-
     <ul id="aboutLinks">
-      <div class="top-border"></div>
-      <li><a id="faqURL">&aboutPage.faq.label;</a></li>
-      <li><a id="supportURL">&aboutPage.support.label;</a></li>
-      <li><a id="privacyURL">&aboutPage.privacyPolicy.label;</a></li>
+      <li><a href="http://www.mozilla.org/en-US/legal/privacy/firefox.html">&aboutPage.privacyPolicy.label;</a></li>
       <li><a href="about:rights">&aboutPage.rights.label;</a></li>
-      <li><a id="releaseNotesURL">&aboutPage.relNotes.label;</a></li>
-      <li><a id="creditsURL">&aboutPage.credits.label;</a></li>
+      <li><a href="http://www.mozilla.org/credits/">&aboutPage.credits.label;</a></li>
       <li><a href="about:license">&aboutPage.license.label;</a></li>
       <div class="bottom-border"></div>
     </ul>
 
-    <div id="aboutDetails">
-      <p>&logoTrademark;</p>
-    </div>
+
 
     <script type="application/javascript;version=1.8"><![CDATA[
       let Ci = Components.interfaces, Cc = Components.classes, Cu = Components.utils, Cr = Components.results;
diff -r 7f5ef5ff0c59 -r 76920633b762 mobile/android/confvars.sh
--- a/mobile/android/confvars.sh	Mon Mar 31 18:21:24 2014 +0700
+++ b/mobile/android/confvars.sh	Tue Apr 08 21:42:33 2014 +0700
@@ -55,15 +55,15 @@
 # Enable navigator.mozPay
 MOZ_PAY=1
 
-# Enable UI for healthreporter
-MOZ_SERVICES_HEALTHREPORT=1
+# Enable UI for healthreporter, KidBrowser no more report
+MOZ_SERVICES_HEALTHREPORT=0
 
 # Enable FirefoxAccounts
-MOZ_SERVICES_FXACCOUNTS=1
+MOZ_SERVICES_FXACCOUNTS=0
 
 # Wifi-AP/cell tower data reporting is enabled on non-release builds.
 if test ! "$RELEASE_BUILD"; then
-MOZ_DATA_REPORTING=1
+MOZ_DATA_REPORTING=0
 fi
 
 # Enable the production cert for verifying signed packaged apps.
# HG changeset patch
# User Cuong Thai <thailycuong1202@gmail.com>
# Date 1397877435 -25200
#      Sat Apr 19 10:17:15 2014 +0700
# Branch better_hide_status_menu
# Node ID 2d4930711bac852cba8a4ee15226146429c2a30e
# Parent  76920633b7622a390e3e7dd92e0f26a58d5bf7bb
Update icons

diff -r 76920633b762 -r 2d4930711bac b2g/branding/official/content/icon48.png
Binary file b2g/branding/official/content/icon48.png has changed
diff -r 76920633b762 -r 2d4930711bac b2g/branding/official/content/logo.png
Binary file b2g/branding/official/content/logo.png has changed
diff -r 76920633b762 -r 2d4930711bac b2g/branding/unofficial/content/logo.png
Binary file b2g/branding/unofficial/content/logo.png has changed
diff -r 76920633b762 -r 2d4930711bac browser/branding/official/content/about-logo.png
Binary file browser/branding/official/content/about-logo.png has changed
diff -r 76920633b762 -r 2d4930711bac browser/branding/official/content/about-logo@2x.png
Binary file browser/branding/official/content/about-logo@2x.png has changed
diff -r 76920633b762 -r 2d4930711bac browser/branding/official/content/icon48.png
Binary file browser/branding/official/content/icon48.png has changed
diff -r 76920633b762 -r 2d4930711bac browser/branding/official/content/icon64.png
Binary file browser/branding/official/content/icon64.png has changed
diff -r 76920633b762 -r 2d4930711bac browser/branding/official/content/metro_firstrun_logo@1.8x.png
Binary file browser/branding/official/content/metro_firstrun_logo@1.8x.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/base/AndroidManifest.xml.in
--- a/mobile/android/base/AndroidManifest.xml.in	Tue Apr 08 21:42:33 2014 +0700
+++ b/mobile/android/base/AndroidManifest.xml.in	Sat Apr 19 10:17:15 2014 +0700
@@ -17,6 +17,7 @@
 #include ../services/manifests/HealthReportAndroidManifest_permissions.xml.in
 #include ../services/manifests/SyncAndroidManifest_permissions.xml.in
 
+    <uses-permission android:name="android.permission.GET_TASKS"/>
 #ifndef RELEASE_BUILD
     <uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
     <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
@@ -69,7 +70,7 @@
     <uses-permission android:name="android.permission.CAMERA" />
     <uses-feature android:name="android.hardware.camera" android:required="false"/>
     <uses-feature android:name="android.hardware.camera.autofocus" android:required="false"/>
-
+    <uses-permission android:name="android.permission.EXPAND_STATUS_BAR" />
     <!-- App requires OpenGL ES 2.0 -->
     <uses-feature android:glEsVersion="0x00020000" android:required="true" />
 
diff -r 76920633b762 -r 2d4930711bac mobile/android/base/GeckoActivity.java
--- a/mobile/android/base/GeckoActivity.java	Tue Apr 08 21:42:33 2014 +0700
+++ b/mobile/android/base/GeckoActivity.java	Sat Apr 19 10:17:15 2014 +0700
@@ -4,12 +4,19 @@
 
 package org.mozilla.gecko;
 
+import android.app.ActivityManager;
 import android.content.ComponentName;
+import android.content.Context;
 import android.content.Intent;
 import android.support.v4.app.FragmentActivity;
+import android.os.Build;
+import android.app.Activity;
+import java.lang.reflect.Method;
+import java.util.List;
 
 public class GeckoActivity extends FragmentActivity implements GeckoActivityStatus {
-    // has this activity recently started another Gecko activity?
+	private static final String KID_MODE_PACKAGE = "com.zoodles.kidmode";
+	// has this activity recently started another Gecko activity?
     private boolean mGeckoActivityOpened = false;
 
     /**
@@ -97,4 +104,42 @@
         MemoryMonitor.getInstance().onTrimMemory(level);
         super.onTrimMemory(level);
     }
+
+	@Override
+	public void onWindowFocusChanged(boolean hasFocus) {
+		if(isKidModeRunning()) {
+			closeStatusBar(this);
+		}
+	}
+
+	private boolean isKidModeRunning() {
+		ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
+		List<ActivityManager.RunningTaskInfo> runningTaskInfo = am.getRunningTasks(2);
+
+		for (int i = 0; i < runningTaskInfo.size(); i++) {
+			if(KID_MODE_PACKAGE.equalsIgnoreCase(runningTaskInfo.get(i).topActivity.getPackageName())){
+				return true;
+			}
+		}
+		return false;
+	}
+
+
+	public void closeStatusBar(Activity activity) {
+		try {
+			Object service = activity.getSystemService("statusbar");
+			Class<?> statusbarManager = Class
+					.forName("android.app.StatusBarManager");
+			Method collapse = null;
+			if (android.os.Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN) {
+				collapse = statusbarManager.getMethod("collapse");
+			} else {
+				collapse = statusbarManager.getMethod("collapsePanels");
+			}
+			collapse.setAccessible(true);
+			collapse.invoke(service);
+		} catch (Exception ex) {
+			ex.printStackTrace();
+		}
+	}
 }
diff -r 76920633b762 -r 2d4930711bac mobile/android/base/resources/drawable-hdpi/icon.png
Binary file mobile/android/base/resources/drawable-hdpi/icon.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/base/resources/drawable-mdpi/icon.png
Binary file mobile/android/base/resources/drawable-mdpi/icon.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/base/resources/drawable-xhdpi/icon.png
Binary file mobile/android/base/resources/drawable-xhdpi/icon.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/branding/official/res/drawable-hdpi/icon.png
Binary file mobile/android/branding/official/res/drawable-hdpi/icon.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/branding/official/res/drawable-mdpi/icon.png
Binary file mobile/android/branding/official/res/drawable-mdpi/icon.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/branding/official/res/drawable-xhdpi/icon.png
Binary file mobile/android/branding/official/res/drawable-xhdpi/icon.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/branding/official/res/drawable-xxhdpi/icon.png
Binary file mobile/android/branding/official/res/drawable-xxhdpi/icon.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/branding/unofficial/res/drawable-hdpi/icon.png
Binary file mobile/android/branding/unofficial/res/drawable-hdpi/icon.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/branding/unofficial/res/drawable-mdpi/icon.png
Binary file mobile/android/branding/unofficial/res/drawable-mdpi/icon.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/branding/unofficial/res/drawable-xhdpi/icon.png
Binary file mobile/android/branding/unofficial/res/drawable-xhdpi/icon.png has changed
diff -r 76920633b762 -r 2d4930711bac mobile/android/branding/unofficial/res/drawable-xxhdpi/icon.png
Binary file mobile/android/branding/unofficial/res/drawable-xxhdpi/icon.png has changed
